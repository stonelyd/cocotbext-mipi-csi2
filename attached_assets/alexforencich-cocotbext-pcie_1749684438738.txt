Directory structure:
└── alexforencich-cocotbext-pcie/
    ├── README.md
    ├── LICENSE
    ├── MANIFEST.in
    ├── setup.cfg
    ├── setup.py
    ├── cocotbext/
    │   └── pcie/
    │       ├── core/
    │       │   ├── __init__.py
    │       │   ├── bridge.py
    │       │   ├── device.py
    │       │   ├── dllp.py
    │       │   ├── endpoint.py
    │       │   ├── function.py
    │       │   ├── msi.py
    │       │   ├── pci.py
    │       │   ├── port.py
    │       │   ├── rc.py
    │       │   ├── region.py
    │       │   ├── switch.py
    │       │   ├── tlp.py
    │       │   ├── utils.py
    │       │   ├── version.py
    │       │   └── caps/
    │       │       ├── __init__.py
    │       │       ├── aer.py
    │       │       ├── common.py
    │       │       ├── msi.py
    │       │       ├── pcie.py
    │       │       └── pm.py
    │       ├── intel/
    │       │   ├── ptile/
    │       │   │   ├── __init__.py
    │       │   │   ├── interface.py
    │       │   │   └── ptile_model.py
    │       │   └── s10/
    │       │       ├── __init__.py
    │       │       ├── interface.py
    │       │       └── s10_model.py
    │       └── xilinx/
    │           └── us/
    │               ├── __init__.py
    │               ├── interface.py
    │               ├── tlp.py
    │               ├── us_model.py
    │               └── usp_model.py
    ├── tests/
    │   ├── Makefile
    │   ├── pcie/
    │   │   ├── Makefile
    │   │   ├── test_pcie.py
    │   │   └── test_pcie.v
    │   ├── pcie_ptile/
    │   │   ├── Makefile
    │   │   ├── test_pcie_ptile.py
    │   │   └── test_pcie_ptile.v
    │   ├── pcie_s10/
    │   │   ├── Makefile
    │   │   ├── test_pcie_s10.py
    │   │   └── test_pcie_s10.v
    │   ├── pcie_us/
    │   │   ├── Makefile
    │   │   ├── test_pcie_us.py
    │   │   └── test_pcie_us.v
    │   └── pcie_usp/
    │       ├── Makefile
    │       ├── test_pcie_usp.py
    │       └── test_pcie_usp.v
    └── .github/
        └── workflows/
            └── regression-tests.yml

================================================
FILE: README.md
================================================
# PCI express simulation framework for Cocotb

[![Regression Tests](https://github.com/alexforencich/cocotbext-pcie/actions/workflows/regression-tests.yml/badge.svg)](https://github.com/alexforencich/cocotbext-pcie/actions/workflows/regression-tests.yml)
[![codecov](https://codecov.io/gh/alexforencich/cocotbext-pcie/branch/master/graph/badge.svg)](https://codecov.io/gh/alexforencich/cocotbext-pcie)
[![PyPI version](https://badge.fury.io/py/cocotbext-pcie.svg)](https://pypi.org/project/cocotbext-pcie)
[![Downloads](https://pepy.tech/badge/cocotbext-pcie)](https://pepy.tech/project/cocotbext-pcie)

GitHub repository: https://github.com/alexforencich/cocotbext-pcie

## Introduction

PCI express simulation framework for [cocotb](https://github.com/cocotb/cocotb).

## Installation

Installation from pip (release version, stable):

    $ pip install cocotbext-pcie

Installation from git (latest development version, potentially unstable):

    $ pip install https://github.com/alexforencich/cocotbext-pcie/archive/master.zip

Installation for active development:

    $ git clone https://github.com/alexforencich/cocotbext-pcie
    $ pip install -e cocotbext-pcie

## Documentation and usage examples

See the `tests` directory, [verilog-pcie](https://github.com/alexforencich/verilog-pcie), and [corundum](https://github.com/corundum/corundum) for complete testbenches using these modules.

### Core PCIe simulation framework

The core PCIe simulation framework is included in `cocotbext.pcie.core`.  This framework implements an extensive event driven simulation of a complete PCI express system, including root complex, switches, devices, and functions, including support for configuration spaces, capabilities and extended capabilities, and memory and IO operations between devices.  The framework includes code to enumerate the bus, initialize configuration space registers and allocate BARs, route messages between devices, perform memory read and write operations, allocate DMA accessible memory regions in the root complex, and handle message signaled interrupts.  Any module can be connected to a cosimulated design, enabling testing of not only isolated components and host-device communication but also communication between multiple components such as device-to-device DMA and message passing.

### PCIe IP core models

#### Xilinx UltraScale and UltraScale+

Models of the Xilinx UltraScale and UltraScale+ PCIe hard cores are included in `cocotbext.pcie.xilinx.us`.  These modules can be used in combination with the PCIe BFM to test an HDL design that targets Xilinx UltraScale, UltraScale+, or Virtex 7 series FPGAs, up to PCIe gen 3 x16 or PCIe gen 4 x8.  The models currently only support operation as a device, not as a root port.

#### Intel Stratix 10 H-Tile/L-Tile

Models of the Intel Stratix 10 H-Tile/L-Tile PCIe hard cores are included in `cocotbext.pcie.intel.s10`.  These modules can be used in combination with the PCIe BFM to test an HDL design that targets Intel Stratix 10 GX, SX, TX, and MX series FPGAs that contain H-Tiles or L-Tiles, up to PCIe gen 3 x16.  The models currently only support operation as a device, not as a root port.

#### Intel P-Tile

Models of the Intel P-Tile PCIe hard cores are included in `cocotbext.pcie.intel.ptile`.  These modules can be used in combination with the PCIe BFM to test an HDL design that targets Intel Stratix 10 DX or Agilex F series FPGAs that contain P-Tiles, up to PCIe gen 4 x16.  The models currently only support operation as a device, not as a root port.



================================================
FILE: LICENSE
================================================
Copyright (c) 2020 Alex Forencich

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.





================================================
FILE: MANIFEST.in
================================================
include LICENSE
include README.md
recursive-include tests Makefile test_*.py test_*.v



================================================
FILE: setup.cfg
================================================
# package information
[metadata]
name = cocotbext-pcie
version = attr: cocotbext.pcie.core.version.__version__
description = PCI express simulation framework for cocotb
keywords = pcie, cocotb
author = Alex Forencich
author_email = alex@alexforencich.com
license = MIT
url = https://github.com/alexforencich/cocotbext-pcie
project_urls =
    Bug Tracker = https://github.com/alexforencich/cocotbext-pcie/issues
    Source Code = https://github.com/alexforencich/cocotbext-pcie
download_url = https://github.com/alexforencich/cocotbext-pcie/tarball/master
long_description = file: README.md
long_description_content_type = text/markdown
platforms = any
classifiers =
    Development Status :: 3 - Alpha
    Framework :: cocotb
    License :: OSI Approved :: MIT License
    Operating System :: OS Independent
    Programming Language :: Python :: 3
    Topic :: Scientific/Engineering :: Electronic Design Automation (EDA)

[options]
packages = find_namespace:
python_requires = >=3.6
install_requires =
    cocotb >= 1.6.0
    cocotbext-axi >= 0.1.16

[options.extras_require]
test =
    pytest
    cocotb-test

[options.packages.find]
include = cocotbext.*

# pytest configuration
[tool:pytest]
testpaths =
    tests
addopts =
    --import-mode importlib

# tox configuration
[tox:tox]
envlist = py37, py38, py39, py310
skip_missing_interpreters = true
minversion = 3.18.0
requires = virtualenv >= 16.1

[gh-actions]
python =
    3.8: py38
    3.9: py39
    3.10: py310
    3.11: py311
    3.12: py312
    3.13: py313

[testenv]
setenv =
    COVERAGE=1
usedevelop = True

deps =
    pytest == 8.3.4
    pytest-xdist == 3.6.1
    cocotb == 1.9.2
    cocotb-bus == 0.2.1
    cocotb-test == 0.2.6
    cocotbext-axi == 0.1.24
    coverage == 7.0.5
    pytest-cov == 4.0.0

commands =
    pytest --cov=cocotbext --cov=tests --cov-branch {posargs:-n auto --verbose}
    bash -c 'find . -type f -name "\.coverage" | xargs coverage combine --append'
    coverage report

allowlist_externals =
    bash

# combine if paths are different
[coverage:paths]
source =
    cocotbext/
    /*/cocotbext

# do not report dependencies
[coverage:report]
omit = 
   .tox/*



================================================
FILE: setup.py
================================================
from setuptools import setup
setup()



================================================
FILE: cocotbext/pcie/core/__init__.py
================================================
"""

Copyright (c) 2020 Alex Forencich

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

"""

from .version import __version__

from .function import Function
from .endpoint import Endpoint, MemoryEndpoint
from .device import Device
from .switch import Switch
from .rc import RootComplex



================================================
FILE: cocotbext/pcie/core/bridge.py
================================================
"""

Copyright (c) 2020 Alex Forencich

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

"""

from .function import Function
from .port import SimPort
from .tlp import Tlp, TlpType, CplStatus
from .utils import byte_mask_update, PcieId


class Bridge(Function):
    """PCIe bridge function, implements bridge config space and TLP routing"""
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        # configuration registers
        # Header type
        self.header_layout = 1
        self.multifunction_device = False
        # Base Address Registers
        self.bar = [0]*2
        self.bar_mask = [0]*2
        # Primary bus number
        self.pri_bus_num = 0
        # Secondary bus number
        self.sec_bus_num = 0
        # Subordinate bus number
        self.sub_bus_num = 0
        # Secondary latency timer
        self.sec_lat_timer = 0
        # IO base and limit registers
        self.io_base = 0x0000
        self.io_limit = 0x0fff
        self.io_addr_capability = 0x1
        # Secondary status
        self.sec_master_data_parity_error = False
        self.sec_signaled_target_abort = False
        self.sec_received_target_abort = False
        self.sec_received_master_abort = False
        self.sec_received_system_error = False
        self.sec_detected_parity_error = False
        # Memory and limit registers
        self.mem_base = 0x00000000
        self.mem_limit = 0x000fffff
        self.prefetchable_mem_base = 0x00000000
        self.prefetchable_mem_limit = 0x000fffff
        # Bridge control
        self.bridge_parity_error_response_enable = 0
        self.bridge_serr_enable = 0
        self.secondary_bus_reset = 0

        self.class_code = 0x060400
        self.pcie_cap.pcie_device_type = 0x6

        self.root = False

        self.upstream_tx_handler = None
        self.downstream_tx_handler = None

    """
    Bridge (type 1) config space

    31                                                                  0
    +---------------------------------+---------------------------------+
    |            Device ID            |            Vendor ID            |   0   0x00
    +---------------------------------+---------------------------------+
    |             Status              |             Command             |   1   0x04
    +---------------------------------+----------------+----------------+
    |                    Class Code                    |  Revision ID   |   2   0x08
    +----------------+----------------+----------------+----------------+
    |      BIST      |  Header Type   |    Primary     |   Cache Line   |   3   0x0C
    |                |                | Latency Timer  |      Size      |
    +----------------+----------------+----------------+----------------+
    |                      Base Address Register 0                      |   4   0x10
    +-------------------------------------------------------------------+
    |                      Base Address Register 1                      |   5   0x14
    +----------------+----------------+----------------+----------------+
    | Secondary      | Subordinate    | Secondary      | Primary        |   6   0x18
    | Latency Timer  | Bus Number     | Bus Number     | Bus Number     |
    +----------------+----------------+----------------+----------------+
    |        Secondary Status         |    IO Limit    |    IO Base     |   7   0x1C
    +---------------------------------+----------------+----------------+
    |          Memory Limit           |           Memory Base           |   8   0x20
    +---------------------------------+---------------------------------+
    |    Prefetchable Memory Limit    |    Prefetchable Memory Base     |   9   0x24
    +---------------------------------+---------------------------------+
    |                    Prefetchable Base Upper 32                     |  10   0x28
    +-------------------------------------------------------------------+
    |                    Prefetchable Limit Upper 32                    |  11   0x2C
    +---------------------------------+---------------------------------+
    |         IO Lim Upper 16         |        IO Base Lower 16         |  12   0x30
    +---------------------------------+----------------+----------------+
    |                     Reserved                     |    Cap Ptr     |  13   0x34
    +--------------------------------------------------+----------------+
    |                    Expansion ROM Base Address                     |  14   0x38
    +---------------------------------+----------------+----------------+
    |         Bridge Control          |    Int Pin     |    Int Line    |  15   0x3C
    +---------------------------------+----------------+----------------+

    """
    async def read_config_register(self, reg):
        if reg == 4:
            # Base Address Register 0
            return self.bar[0]
        elif reg == 5:
            # Base Address Register 1
            return self.bar[1]
        elif reg == 6:
            # Primary bus number
            val = self.pri_bus_num & 0xff
            # Secondary bus number
            val |= (self.sec_bus_num & 0xff) << 8
            # Subordinate bus number
            val |= (self.sub_bus_num & 0xff) << 16
            # Secondary latency timer
            val |= (self.sec_lat_timer & 0xff) << 24
            return val
        elif reg == 7:
            # IO base
            val = self.io_addr_capability & 0xf
            val |= (self.io_base & 0xf000) >> 8
            # IO limit
            val |= (self.io_addr_capability & 0xf) << 8
            val |= self.io_limit & 0xf000
            # Secondary status
            val |= bool(self.sec_master_data_parity_error) << 24
            val |= bool(self.sec_signaled_target_abort) << 27
            val |= bool(self.sec_received_target_abort) << 28
            val |= bool(self.sec_received_master_abort) << 29
            val |= bool(self.sec_received_system_error) << 30
            val |= bool(self.sec_detected_parity_error) << 31
            return val
        elif reg == 8:
            # Memory base
            val = (self.mem_base & 0xfff00000) >> 16
            # Memory limit
            val |= self.mem_limit & 0xfff00000
            return val
        elif reg == 9:
            # Prefetchable memory base
            val = (self.prefetchable_mem_base & 0xfff00000) >> 16
            # Prefetchable memory limit
            val |= self.prefetchable_mem_limit & 0xfff00000
            # supports 64 bit addresses
            val |= 0x00010001
            return val
        elif reg == 10:
            # Prefetchable memory base (upper)
            return (self.prefetchable_mem_base >> 32) & 0xffffffff
        elif reg == 11:
            # Prefetchable memory limit (upper)
            return (self.prefetchable_mem_limit >> 32) & 0xffffffff
        elif reg == 12:
            # IO base (upper)
            val = (self.io_base & 0xffff0000) >> 16
            # IO limit (upper)
            val |= self.io_limit & 0xffff0000
            return val
        elif reg == 13:
            # Capabilities pointer
            return self.capabilities_ptr
        elif reg == 14:
            # Expansion ROM Base Address
            val = bool(self.expansion_rom_enable)
            val |= self.expansion_rom_addr & 0xfffff800
            return val
        elif reg == 15:
            # Interrupt line
            val = self.interrupt_line & 0xff
            # Interrupt pin
            val |= (self.interrupt_pin & 0xff) << 8
            # Bridge control
            val |= bool(self.bridge_parity_error_response_enable) << 16
            val |= bool(self.bridge_serr_enable) << 17
            val |= bool(self.secondary_bus_reset) << 22
            return val
        else:
            return await super().read_config_register(reg)

    async def write_config_register(self, reg, data, mask):
        if reg == 4:
            # Base Address Register 0
            self.bar[0] = byte_mask_update(self.bar[0], mask, data, self.bar_mask[0])
        if reg == 5:
            # Base Address Register 1
            self.bar[1] = byte_mask_update(self.bar[1], mask, data, self.bar_mask[1])
        elif reg == 6:
            # Primary bus number
            if mask & 0x1:
                self.pri_bus_num = data & 0xff
            # Secondary bus number
            if mask & 0x2:
                self.sec_bus_num = (data >> 8) & 0xff
            # Subordinate bus number
            if mask & 0x4:
                self.sub_bus_num = (data >> 16) & 0xff
        elif reg == 7:
            # IO base
            if mask & 0x1:
                self.io_base = byte_mask_update(self.io_base, 0x2, data << 8, 0xf000)
            # IO limit
            if mask & 0x2:
                self.io_limit = byte_mask_update(self.io_limit, 0x2, data, 0xf000) | 0xfff
            if mask & 0x8:
                # Secondary status
                if data & 1 << 24:
                    self.sec_master_data_parity_error = False
                if data & 1 << 27:
                    self.sec_signaled_target_abort = False
                if data & 1 << 28:
                    self.sec_received_target_abort = False
                if data & 1 << 29:
                    self.sec_received_master_abort = False
                if data & 1 << 30:
                    self.sec_received_system_error = False
                if data & 1 << 31:
                    self.sec_detected_parity_error = False
        elif reg == 8:
            # Memory base
            self.mem_base = byte_mask_update(self.mem_base, (mask & 0x3) << 2, data << 16, 0xfff00000)
            # Memory limit
            self.mem_limit = byte_mask_update(self.mem_limit, (mask & 0xc), data, 0xfff00000) | 0xfffff
        elif reg == 9:
            # Prefetchable memory base
            self.prefetchable_mem_base = byte_mask_update(self.prefetchable_mem_base,
                (mask & 0x3) << 2, data << 16, 0xfff00000)
            # Prefetchable memory limit
            self.prefetchable_mem_limit = byte_mask_update(self.prefetchable_mem_limit,
                (mask & 0xc), data, 0xfff00000) | 0xfffff
        elif reg == 10:
            # Prefetchable memory base (upper)
            self.prefetchable_mem_base = byte_mask_update(self.prefetchable_mem_base, mask << 4, data << 32)
        elif reg == 11:
            # Prefetchable memory limit (upper)
            self.prefetchable_mem_limit = byte_mask_update(self.prefetchable_mem_limit, mask << 4, data << 32)
        elif reg == 12:
            # IO base (upper)
            self.io_base = byte_mask_update(self.io_base, (mask & 0x3) << 2, data << 16)
            # IO limit (upper)
            self.io_limit = byte_mask_update(self.io_limit, (mask & 0xc), data)
        elif reg == 14:
            # Expansion ROM Base Address
            self.expansion_rom_addr = byte_mask_update(self.expansion_rom_addr,
                mask, data, self.expansion_rom_addr_mask) & 0xfffff800
            if mask & 0x1:
                self.expansion_rom_enable = (data & 1) != 0
        elif reg == 15:
            # Interrupt line
            if mask & 1:
                self.interrupt_line = data & 0xff
            # bridge control
            if mask & 0x4:
                self.bridge_parity_error_response_enable = (data & 1 << 16 != 0)
                self.bridge_serr_enable = (data & 1 << 17 != 0)
                self.secondary_bus_reset = (data & 1 << 22 != 0)
        else:
            await super().write_config_register(reg, data, mask)

    def match_tlp_secondary(self, tlp):
        if tlp.fmt_type in {TlpType.CFG_READ_0, TlpType.CFG_WRITE_0}:
            # Config type 0
            return False
        elif tlp.fmt_type in {TlpType.CFG_READ_1, TlpType.CFG_WRITE_1}:
            # Config type 1
            return self.sec_bus_num <= tlp.completer_id.bus <= self.sub_bus_num and tlp.completer_id != PcieId(0, 0, 0)
        elif tlp.fmt_type in {TlpType.CPL, TlpType.CPL_DATA, TlpType.CPL_LOCKED, TlpType.CPL_LOCKED_DATA}:
            # Completion
            return self.sec_bus_num <= tlp.requester_id.bus <= self.sub_bus_num and tlp.requester_id != PcieId(0, 0, 0)
        elif tlp.fmt_type in {TlpType.MSG_ID, TlpType.MSG_DATA_ID}:
            # ID routed message
            return self.sec_bus_num <= tlp.completer_id.bus <= self.sub_bus_num and tlp.completer_id != PcieId(0, 0, 0)
        elif tlp.fmt_type in {TlpType.IO_READ, TlpType.IO_WRITE}:
            # IO read/write
            return self.io_base <= tlp.address <= self.io_limit
        elif tlp.fmt_type in {TlpType.MEM_READ, TlpType.MEM_READ_64, TlpType.MEM_WRITE, TlpType.MEM_WRITE_64}:
            # Memory read/write
            return (self.mem_base <= tlp.address <= self.mem_limit
                or self.prefetchable_mem_base <= tlp.address <= self.prefetchable_mem_limit)
        elif tlp.fmt_type in {TlpType.MSG_TO_RC, TlpType.MSG_DATA_TO_RC}:
            # Message to root complex
            return False
        elif tlp.fmt_type in {TlpType.MSG_BCAST, TlpType.MSG_DATA_BCAST}:
            # Message broadcast from root complex
            return True
        elif tlp.fmt_type in {TlpType.MSG_LOCAL, TlpType.MSG_DATA_LOCAL}:
            # Message local to receiver
            return False
        elif tlp.fmt_type in {TlpType.MSG_GATHER, TlpType.MSG_DATA_GATHER}:
            # Message gather to root complex
            return False
        else:
            raise Exception("Unknown/invalid packet type")

    async def upstream_send(self, tlp):
        assert tlp.check()
        if self.parity_error_response_enable and tlp.ep:
            self.log.warning("Sending poisoned TLP on primary interface, reporting master data parity error")
            self.master_data_parity_error = True
        if self.upstream_tx_handler is None:
            raise Exception("Transmit handler not set")
        await self.upstream_tx_handler(tlp)

    async def upstream_recv(self, tlp):
        self.log.debug("Routing downstream TLP: %r", tlp)
        assert tlp.check()
        if self.parity_error_response_enable and tlp.ep:
            self.log.warning("Received poisoned TLP on primary interface, reporting master data parity error")
            self.master_data_parity_error = True

        # TLPs targeting bridge function
        if self.match_tlp(tlp):
            if tlp.is_completion():
                if tlp.status == CplStatus.CA:
                    self.log.warning("Received completion with CA status on primary interface, reporting target abort")
                    self.received_target_abort = True
                elif tlp.status == CplStatus.UR:
                    self.log.warning("Received completion with UR status on primary interface, reporting master abort")
                    self.received_master_abort = True
            await self.handle_tlp(tlp)
            return

        # Route TLPs from primary side to secondary side
        if self.match_tlp_secondary(tlp):

            if tlp.fmt_type in {TlpType.CFG_READ_1, TlpType.CFG_WRITE_1} and tlp.completer_id.bus == self.sec_bus_num:
                # config type 1 targeted to directly connected device; change to type 0
                if tlp.fmt_type == TlpType.CFG_READ_1:
                    tlp.fmt_type = TlpType.CFG_READ_0
                elif tlp.fmt_type == TlpType.CFG_WRITE_1:
                    tlp.fmt_type = TlpType.CFG_WRITE_0

            await self.route_downstream_tlp(tlp, False)
            return

        tlp.release_fc()

        if tlp.fmt_type in {TlpType.CFG_READ_0, TlpType.CFG_WRITE_0}:
            # Config type 0
            self.log.warning("Failed to route config type 0 TLP: %r", tlp)
        elif tlp.fmt_type in {TlpType.CFG_READ_1, TlpType.CFG_WRITE_1}:
            # Config type 1
            self.log.warning("Failed to route config type 1 TLP: %r", tlp)
        elif tlp.fmt_type in {TlpType.CPL, TlpType.CPL_DATA, TlpType.CPL_LOCKED, TlpType.CPL_LOCKED_DATA}:
            # Completion
            self.log.warning("Unexpected completion: failed to route completion: %r", tlp)
            return  # no UR response for completion
        elif tlp.fmt_type in {TlpType.IO_READ, TlpType.IO_WRITE}:
            # IO read/write
            self.log.warning("No address match: IO request did not match secondary bus or any BARs: %r", tlp)
        elif tlp.fmt_type in {TlpType.MEM_READ, TlpType.MEM_READ_64}:
            # Memory read/write
            self.log.warning("No address match: memory read request did not match secondary bus or any BARs: %r", tlp)
        elif tlp.fmt_type in {TlpType.MEM_WRITE, TlpType.MEM_WRITE_64}:
            # Memory read/write
            self.log.warning("No address match: memory write request did not match secondary bus or any BARs: %r", tlp)
            return  # no UR response for write request
        else:
            raise Exception("TODO")

        # Unsupported request
        cpl = Tlp.create_ur_completion_for_tlp(tlp, self.pcie_id)
        self.log.debug("UR Completion: %r", cpl)
        await self.upstream_send(cpl)

    async def route_downstream_tlp(self, tlp, from_downstream=False):
        await self.downstream_send(tlp)

    async def downstream_send(self, tlp):
        assert tlp.check()
        if self.bridge_parity_error_response_enable and tlp.ep:
            self.log.warning("Sending poisoned TLP on secondary interface, reporting master data parity error")
            self.sec_master_data_parity_error = True
        if self.downstream_tx_handler is None:
            raise Exception("Transmit handler not set")
        await self.downstream_tx_handler(tlp)

    async def downstream_recv(self, tlp):
        self.log.debug("Routing upstream TLP: %r", tlp)
        assert tlp.check()
        if self.bridge_parity_error_response_enable and tlp.ep:
            self.log.warning("Received poisoned TLP on secondary interface, reporting master data parity error")
            self.sec_master_data_parity_error = True

        if tlp.fmt_type in {TlpType.CFG_READ_0, TlpType.CFG_WRITE_0, TlpType.CFG_READ_1, TlpType.CFG_WRITE_1}:
            # error
            pass
        elif not self.root and self.match_tlp(tlp):
            # TLPs targeting bridge function
            if tlp.is_completion():
                if tlp.status == CplStatus.CA:
                    self.log.warning("Received completion with CA status on secondary interface, reporting target abort")
                    self.sec_received_target_abort = True
                elif tlp.status == CplStatus.UR:
                    self.log.warning("Received completion with UR status on secondary interface, reporting master abort")
                    self.sec_received_master_abort = True
            await self.handle_tlp(tlp)
            return
        elif not self.match_tlp_secondary(tlp) or self.root:
            # Route TLPs from secondary side to primary side
            await self.upstream_send(tlp)
            return

        tlp.release_fc()

        if tlp.fmt_type in {TlpType.CFG_READ_0, TlpType.CFG_WRITE_0, TlpType.CFG_READ_1, TlpType.CFG_WRITE_1}:
            # Config type 1
            self.log.warning("Malformed TLP: received configuration request on downstream switch port: %r", tlp)
        elif tlp.fmt_type in {TlpType.CPL, TlpType.CPL_DATA, TlpType.CPL_LOCKED, TlpType.CPL_LOCKED_DATA}:
            # Completion
            self.log.warning("Unexpected completion: completion did not match primary bus: %r", tlp)
            return  # no UR response for completion
        elif tlp.fmt_type in {TlpType.IO_READ, TlpType.IO_WRITE}:
            # IO read/write
            self.log.warning("No address match: IO request did not match primary bus: %r", tlp)
        elif tlp.fmt_type in {TlpType.MEM_READ, TlpType.MEM_READ_64}:
            # Memory read/write
            self.log.warning("No address match: memory read request did not match primary bus: %r", tlp)
        elif tlp.fmt_type in {TlpType.MEM_WRITE, TlpType.MEM_WRITE_64}:
            # Memory read/write
            self.log.warning("No address match: memory write request did not match primary bus: %r", tlp)
            return  # no UR response for write request
        else:
            raise Exception("TODO")

        # Unsupported request
        cpl = Tlp.create_ur_completion_for_tlp(tlp, self.pcie_id)
        self.log.debug("UR Completion: %r", cpl)
        await self.downstream_send(cpl)

    async def send(self, tlp):
        # route local transmissions
        if self.match_tlp_secondary(tlp):
            if tlp.is_completion() and tlp.status == CplStatus.CA:
                self.log.warning("Sending completion with CA status on secondary interface, reporting target abort")
                self.signaled_target_abort = True
            await self.route_downstream_tlp(tlp, False)
        else:
            if tlp.is_completion() and tlp.status == CplStatus.CA:
                self.log.warning("Sending completion with CA status on primary interface, reporting target abort")
                self.signaled_target_abort = True
            await self.upstream_send(tlp)


class SwitchUpstreamPort(Bridge):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        self.pcie_cap.pcie_device_type = 0x5

        self.vendor_id = 0x1234
        self.device_id = 0x0003

        self.upstream_port = None
        self.upstream_tx_handler = None
        self.set_upstream_port(SimPort(fc_init=[[64, 1024, 64, 64, 64, 1024]]*8))

    def set_upstream_port(self, port):
        port.log = self.log
        port.parent = self
        port.rx_handler = self.upstream_recv
        self.upstream_port = port
        self.upstream_tx_handler = port.send

    def connect(self, port):
        self.upstream_port.connect(port)


class SwitchDownstreamPort(Bridge):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        self.pcie_cap.pcie_device_type = 0x6

        self.vendor_id = 0x1234
        self.device_id = 0x0004

        self.downstream_port = None
        self.downstream_tx_handler = None
        self.set_downstream_port(SimPort(fc_init=[[64, 1024, 64, 64, 64, 1024]]*8))

    def set_downstream_port(self, port):
        port.log = self.log
        port.parent = self
        port.rx_handler = self.downstream_recv
        self.downstream_port = port
        self.downstream_tx_handler = port.send

    def connect(self, port):
        self.downstream_port.connect(port)


class HostBridge(Bridge):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        self.pcie_cap.pcie_device_type = 0x5

        self.vendor_id = 0x1234
        self.device_id = 0x0001

        self.pri_bus_num = 0
        self.sec_bus_num = 0
        self.sub_bus_num = 255

        self.class_code = 0x060000

        self.root = True


class RootPort(SwitchDownstreamPort):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        self.pcie_cap.pcie_device_type = 0x4
        self.pcie_cap.crs_software_visibility = True

        self.vendor_id = 0x1234
        self.device_id = 0x0002



================================================
FILE: cocotbext/pcie/core/device.py
================================================
"""

Copyright (c) 2020 Alex Forencich

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

"""

import logging

from .endpoint import Endpoint
from .port import SimPort
from .tlp import Tlp, TlpType
from .utils import PcieId


class Device:
    """PCIe device, container for multiple functions"""
    def __init__(self, eps=None, *args, **kwargs):

        self._bus_num = 0

        self.log = logging.getLogger(f"cocotb.pcie.{type(self).__name__}.{id(self)}")
        self.log.name = f"cocotb.pcie.{type(self).__name__}[{self._bus_num:02x}]"

        self.default_function = Endpoint

        self.functions = []
        self.upstream_port = None

        self.set_port(SimPort(fc_init=[[64, 1024, 64, 64, 0, 0]]*8))

        if eps:
            try:
                for ep in eps:
                    self.append_function(ep)
            except TypeError:
                self.append_function(eps)

        super().__init__(*args, **kwargs)

    @property
    def bus_num(self):
        return self._bus_num

    @bus_num.setter
    def bus_num(self, value):
        if value < 0 or value > 255:
            raise ValueError("Out of range")
        if self._bus_num != value:
            self._bus_num = value
            self.log.name = f"cocotb.pcie.{type(self).__name__}[{self._bus_num:02x}]"

            for f in self.functions:
                f.pcie_id = f.pcie_id._replace(bus=self.bus_num)

    def next_free_function_number(self):
        self.functions.sort(key=lambda x: x.function_num)
        if not self.functions:
            return 0
        for x in range(len(self.functions)):
            if self.functions[x].function_num != x:
                return x
        if len(self.functions) < 8:
            return len(self.functions)
        return None

    def add_function(self, function):
        for f in self.functions:
            if f.function_num == function.function_num:
                raise Exception("Function number already in use")
        function.upstream_tx_handler = self.upstream_send
        self.functions.append(function)
        self.functions.sort(key=lambda x: x.function_num)
        if len(self.functions) > 1:
            for f in self.functions:
                f.multifunction_device = True
        return function

    def append_function(self, function):
        function.pcie_id = PcieId(self.bus_num, 0, self.next_free_function_number())
        return self.add_function(function)

    def make_function(self):
        return self.append_function(self.default_function())

    def set_port(self, port):
        port.log = self.log
        port.parent = self
        port.rx_handler = self.upstream_recv
        self.upstream_port = port

    def connect(self, port):
        self.upstream_port.connect(port)

    async def upstream_recv(self, tlp):
        self.log.debug("Got downstream TLP: %r", tlp)
        assert tlp.check()
        if tlp.fmt_type in {TlpType.CFG_READ_0, TlpType.CFG_WRITE_0}:
            # config type 0

            # capture address information
            self.bus_num = tlp.completer_id.bus

        # pass TLP to function
        for f in self.functions:
            if f.match_tlp(tlp):
                await f.upstream_recv(tlp)
                return

        tlp.release_fc()

        if tlp.fmt_type in {TlpType.CFG_READ_0, TlpType.CFG_WRITE_0}:
            # Config type 0
            self.log.warning("Function not found: failed to route config type 0 TLP: %r", tlp)
        elif tlp.fmt_type in {TlpType.CFG_READ_1, TlpType.CFG_WRITE_1}:
            # Config type 1
            self.log.warning("Malformed TLP: endpoint received config type 1 TLP: %r", tlp)
        elif tlp.fmt_type in {TlpType.CPL, TlpType.CPL_DATA, TlpType.CPL_LOCKED, TlpType.CPL_LOCKED_DATA}:
            # Completion
            self.log.warning("Unexpected completion: failed to route completion to function: %r", tlp)
            return  # no UR response for completion
        elif tlp.fmt_type in {TlpType.IO_READ, TlpType.IO_WRITE}:
            # IO read/write
            self.log.warning("No BAR match: IO request did not match any BARs: %r", tlp)
        elif tlp.fmt_type in {TlpType.MEM_READ, TlpType.MEM_READ_64}:
            # Memory read/write
            self.log.warning("No BAR match: memory read request did not match any BARs: %r", tlp)
        elif tlp.fmt_type in {TlpType.MEM_WRITE, TlpType.MEM_WRITE_64}:
            # Memory read/write
            self.log.warning("No BAR match: memory write request did not match any BARs: %r", tlp)
            return  # no UR response for write request
        else:
            raise Exception("TODO")

        # Unsupported request
        cpl = Tlp.create_ur_completion_for_tlp(tlp, PcieId(self.bus_num, 0, 0))
        self.log.debug("UR Completion: %r", cpl)
        await self.upstream_send(cpl)

    async def upstream_send(self, tlp):
        self.log.debug("Sending upstream TLP: %r", tlp)
        assert tlp.check()
        await self.upstream_port.send(tlp)

    async def send(self, tlp):
        await self.upstream_send(tlp)



================================================
FILE: cocotbext/pcie/core/dllp.py
================================================
"""

Copyright (c) 2021 Alex Forencich

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

"""

import enum
import struct


# DLLP types
class DllpType(enum.IntEnum):
    ACK                = 0b00000000
    MR_INIT            = 0b00000001
    DATA_LINK_FEATURE  = 0b00000010
    NAK                = 0b00010000
    PM_ENTER_L1        = 0b00100000
    PM_ENTER_L23       = 0b00100001
    PM_ACT_ST_REQ_L1   = 0b00100011
    PM_REQ_ACK         = 0b00100100
    VEND               = 0b00110000
    NOP                = 0b00110001
    INIT_FC1_P         = 0b01000000
    INIT_FC1_NP        = 0b01010000
    INIT_FC1_CPL       = 0b01100000
    MR_INIT_FC1        = 0b01110000
    INIT_FC2_P         = 0b11000000
    INIT_FC2_NP        = 0b11010000
    INIT_FC2_CPL       = 0b11100000
    MR_INIT_FC2        = 0b11110000
    UPDATE_FC_P        = 0b10000000
    UPDATE_FC_NP       = 0b10010000
    UPDATE_FC_CPL      = 0b10100000
    MR_UPDATE_FC       = 0b10110000


DLLP_FC_TYPE_MASK = 0b11111000
DLLP_FC_VC_MASK   = 0b00000111


class FcType(enum.Enum):
    P   = 0  # posted
    NP  = 1  # non-posted
    CPL = 2  # completion


dllp_type_fc_type_mapping = {
    DllpType.INIT_FC1_P:     FcType.P,
    DllpType.INIT_FC1_NP:    FcType.NP,
    DllpType.INIT_FC1_CPL:   FcType.CPL,
    DllpType.INIT_FC2_P:     FcType.P,
    DllpType.INIT_FC2_NP:    FcType.NP,
    DllpType.INIT_FC2_CPL:   FcType.CPL,
    DllpType.UPDATE_FC_P:    FcType.P,
    DllpType.UPDATE_FC_NP:   FcType.NP,
    DllpType.UPDATE_FC_CPL:  FcType.CPL,
}


class FcScale(enum.IntEnum):
    DIS  = 0  # scaled FC disabled
    SF1  = 1  # scaled FC enabled with scale factor 1
    SF4  = 2  # scaled FC enabled with scale factor 4
    SF16 = 3  # scaled FC enabled with scale factor 16


def crc16(data, crc=0xFFFF, poly=0xD008):
    for d in data:
        crc = crc ^ d
        for bit in range(0, 8):
            if crc & 1:
                crc = (crc >> 1) ^ poly
            else:
                crc = crc >> 1
    return crc


class Dllp:
    def __init__(self, dllp=None):
        self.type = DllpType.NOP
        self.seq = 0
        self.vc = 0
        self.hdr_scale = FcScale(0)
        self.hdr_fc = 0
        self.data_scale = FcScale(0)
        self.data_fc = 0
        self.feature_support = 0
        self.feature_ack = False

        if isinstance(dllp, Dllp):
            self.type = dllp.type
            self.seq = dllp.seq
            self.vc = dllp.vc
            self.hdr_scale = dllp.hdr_scale
            self.hdr_fc = dllp.hdr_fc
            self.data_scale = dllp.data_scale
            self.data_fc = dllp.data_fc
            self.feature_support = dllp.feature_support
            self.feature_ack = dllp.feature_ack

    @classmethod
    def create_ack(cls, seq):
        dllp = cls()
        dllp.type = DllpType.ACK
        dllp.seq = seq
        return dllp

    @classmethod
    def create_nak(cls, seq):
        dllp = cls()
        dllp.type = DllpType.NAK
        dllp.seq = seq
        return dllp

    def get_size(self):
        """Return size of DLLP in bytes"""
        return 6

    def get_wire_size(self):
        """Return size of DLLP in bytes, including overhead"""
        return 8

    def get_fc_type(self):
        return dllp_type_fc_type_mapping[self.type]

    def pack(self):
        """Pack DLLP as bytes"""
        dw = (self.type & 0xff) << 24

        if self.type in {DllpType.ACK, DllpType.NAK}:
            dw |= self.seq & 0xfff
        elif self.type in {DllpType.NOP, DllpType.PM_ENTER_L1, DllpType.PM_ENTER_L23,
                DllpType.PM_ACT_ST_REQ_L1, DllpType.PM_REQ_ACK}:
            pass
        elif self.type == DllpType.DATA_LINK_FEATURE:
            dw |= self.feature_support & 0x7fffff
            dw |= bool(self.feature_ack) << 23
        elif (self.type & DLLP_FC_TYPE_MASK) in {DllpType.INIT_FC1_P, DllpType.INIT_FC1_NP, DllpType.INIT_FC1_CPL,
                DllpType.INIT_FC2_P, DllpType.INIT_FC2_NP, DllpType.INIT_FC2_CPL, DllpType.UPDATE_FC_P,
                DllpType.UPDATE_FC_NP, DllpType.UPDATE_FC_CPL}:
            dw |= (self.vc & DLLP_FC_VC_MASK) << 24
            dw |= self.data_fc & 0xfff
            dw |= (self.data_scale & 0x3) << 12
            dw |= (self.hdr_fc & 0xff) << 14
            dw |= (self.hdr_scale & 0x3) << 22
        else:
            raise Exception("TODO")

        return struct.pack('>L', dw)

    def pack_crc(self):
        """Pack DLLP as bytes with CRC"""

        pkt = self.pack()
        pkt += struct.pack('<H', (~crc16(pkt)) & 0xffff)

        return pkt

    @classmethod
    def unpack(cls, pkt):
        """Unpack DLLP from bytes"""
        dllp = cls()

        dw, = struct.unpack_from('>L', pkt)

        dllp.type = (dw >> 24) & 0xff

        if dllp.type in {DllpType.ACK, DllpType.NAK}:
            dllp.seq = dw & 0xfff
        elif dllp.type in {DllpType.NOP, DllpType.PM_ENTER_L1, DllpType.PM_ENTER_L23,
                DllpType.PM_ACT_ST_REQ_L1, DllpType.PM_REQ_ACK}:
            pass
        elif dllp.type == DllpType.DATA_LINK_FEATURE:
            dllp.feature_support = dw & 0x7fffff
            dllp.feature_ack = bool(dw & 1 << 23)
        elif (dllp.type & DLLP_FC_TYPE_MASK) in {DllpType.INIT_FC1_P, DllpType.INIT_FC1_NP, DllpType.INIT_FC1_CPL,
                DllpType.INIT_FC2_P, DllpType.INIT_FC2_NP, DllpType.INIT_FC2_CPL, DllpType.UPDATE_FC_P,
                DllpType.UPDATE_FC_NP, DllpType.UPDATE_FC_CPL}:
            dllp.type = dllp.type & DLLP_FC_TYPE_MASK
            dllp.vc = (dw >> 24) & DLLP_FC_VC_MASK
            dllp.data_fc = dw & 0xfff
            dllp.data_scale = FcScale((dw >> 12) & 0x3)
            dllp.hdr_fc = (dw >> 14) & 0xff
            dllp.hdr_scale = FcScale((dw >> 22) & 0x3)
        else:
            raise Exception("TODO")

        dllp.type = DllpType(dllp.type)

        return dllp

    @classmethod
    def unpack_crc(cls, pkt):
        """Unpack DLLP from bytes with CRC"""

        if len(pkt) != 6:
            raise Exception("Invalid length")

        if crc16(pkt) != 0x556f:
            raise Exception("Invalid CRC")

        return cls.unpack(pkt[0:4])

    def __eq__(self, other):
        if isinstance(other, Dllp):
            return (
                self.type == other.type and
                self.seq == other.seq and
                self.vc == other.vc and
                self.hdr_scale == other.hdr_scale and
                self.hdr_fc == other.hdr_fc and
                self.data_scale == other.data_scale and
                self.data_fc == other.data_fc and
                self.feature_support == other.feature_support and
                self.feature_ack == other.feature_ack
            )
        return False

    def __repr__(self):
        return (
            f"{type(self).__name__}(type={self.type!s}, "
            f"seq={self.seq}, "
            f"vc={self.vc}, "
            f"hdr_scale={self.hdr_scale!s}, "
            f"hdr_fc={self.hdr_fc}, "
            f"data_scale={self.data_scale!s}, "
            f"data_fc={self.data_fc}, "
            f"feature_support={self.feature_support}, "
            f"feature_ack={self.feature_ack})"
        )

    def __bytes__(self):
        return self.pack()



================================================
FILE: cocotbext/pcie/core/endpoint.py
================================================
"""

Copyright (c) 2020 Alex Forencich

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

"""

import mmap
import struct

from .function import Function
from .tlp import Tlp, TlpType
from .utils import byte_mask_update


class Endpoint(Function):
    """PCIe endpoint function, implements endpoint config space"""
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        # configuration registers
        self.header_type = 0
        self.bar = [0]*6
        self.bar_mask = [0]*6
        self.subsystem_vendor_id = 0
        self.subsystem_id = 0

        self.pcie_device_type = 0

    """
    Endpoint (type 0) config space

    31                                                                  0
    +---------------------------------+---------------------------------+
    |            Device ID            |            Vendor ID            |   0   0x00
    +---------------------------------+---------------------------------+
    |             Status              |             Command             |   1   0x04
    +---------------------------------+----------------+----------------+
    |                    Class Code                    |  Revision ID   |   2   0x08
    +----------------+----------------+----------------+----------------+
    |      BIST      |  Header Type   |    Primary     |   Cache Line   |   3   0x0C
    |                |                | Latency Timer  |      Size      |
    +----------------+----------------+----------------+----------------+
    |                      Base Address Register 0                      |   4   0x10
    +-------------------------------------------------------------------+
    |                      Base Address Register 1                      |   5   0x14
    +-------------------------------------------------------------------+
    |                      Base Address Register 2                      |   6   0x18
    +-------------------------------------------------------------------+
    |                      Base Address Register 3                      |   7   0x1C
    +-------------------------------------------------------------------+
    |                      Base Address Register 4                      |   8   0x20
    +-------------------------------------------------------------------+
    |                      Base Address Register 5                      |   9   0x24
    +-------------------------------------------------------------------+
    |                       Cardbus CIS pointer                         |  10   0x28
    +---------------------------------+---------------------------------+
    |          Subsystem ID           |       Subsystem Vendor ID       |  11   0x2C
    +---------------------------------+---------------------------------+
    |                    Expansion ROM Base Address                     |  12   0x30
    +--------------------------------------------------+----------------+
    |                     Reserved                     |    Cap Ptr     |  13   0x34
    +--------------------------------------------------+----------------+
    |                             Reserved                              |  14   0x38
    +----------------+----------------+----------------+----------------+
    |    Max Lat     |    Min Gnt     |    Int Pin     |    Int Line    |  15   0x3C
    +----------------+----------------+----------------+----------------+
    """
    async def read_config_register(self, reg):
        if reg == 4:
            # Base Address Register 0
            return self.bar[0] & 0xffffffff
        elif reg == 5:
            # Base Address Register 1
            return self.bar[1] & 0xffffffff
        elif reg == 6:
            # Base Address Register 2
            return self.bar[2] & 0xffffffff
        elif reg == 7:
            # Base Address Register 3
            return self.bar[3] & 0xffffffff
        elif reg == 8:
            # Base Address Register 4
            return self.bar[4] & 0xffffffff
        elif reg == 9:
            # Base Address Register 5
            return self.bar[5] & 0xffffffff
        elif reg == 10:
            # Cardbus CIS pointer
            return 0
        elif reg == 11:
            # Subsystem vendor ID
            val = self.subsystem_vendor_id & 0xffff
            # Subsystem ID
            val |= (self.subsystem_id & 0xffff) << 16
            return val
        elif reg == 12:
            # Expansion ROM Base Address
            val = bool(self.expansion_rom_enable)
            val |= self.expansion_rom_addr & 0xfffff800
            return val
        elif reg == 13:
            # Capabilities pointer
            return self.capabilities_ptr & 0xff
        elif reg == 14:
            # reserved
            return 0
        elif reg == 15:
            # Interrupt line
            val = self.interrupt_line & 0xff
            # Interrupt pin
            val |= (self.interrupt_pin & 0xff) << 8
            # Min Gnt
            # Max Lat
            return val
        else:
            return await super().read_config_register(reg)

    async def write_config_register(self, reg, data, mask):
        if reg == 4:
            # Base Address Register 0
            self.bar[0] = byte_mask_update(self.bar[0], mask, data, self.bar_mask[0])
        elif reg == 5:
            # Base Address Register 1
            self.bar[1] = byte_mask_update(self.bar[1], mask, data, self.bar_mask[1])
        elif reg == 6:
            # Base Address Register 2
            self.bar[2] = byte_mask_update(self.bar[2], mask, data, self.bar_mask[2])
        elif reg == 7:
            # Base Address Register 3
            self.bar[3] = byte_mask_update(self.bar[3], mask, data, self.bar_mask[3])
        elif reg == 8:
            # Base Address Register 4
            self.bar[4] = byte_mask_update(self.bar[4], mask, data, self.bar_mask[4])
        elif reg == 9:
            # Base Address Register 5
            self.bar[5] = byte_mask_update(self.bar[5], mask, data, self.bar_mask[5])
        elif reg == 12:
            # Expansion ROM Base Address
            self.expansion_rom_addr = byte_mask_update(self.expansion_rom_addr,
                mask, data, self.expansion_rom_addr_mask) & 0xfffff800
            if mask & 0x1:
                self.expansion_rom_enable = (data & 1) != 0
        elif reg == 15:
            # Interrupt line
            if mask & 1:
                self.interrupt_line = data & 0xff
        else:
            await super().write_config_register(reg, data, mask)


class MemoryEndpoint(Endpoint):
    """PCIe endpoint function, implements BARs pointing to internal memory"""
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        self.regions = [None]*6
        self.bar_ptr = 0

        self.register_rx_tlp_handler(TlpType.IO_READ, self.handle_io_read_tlp)
        self.register_rx_tlp_handler(TlpType.IO_WRITE, self.handle_io_write_tlp)
        self.register_rx_tlp_handler(TlpType.MEM_READ, self.handle_mem_read_tlp)
        self.register_rx_tlp_handler(TlpType.MEM_READ_64, self.handle_mem_read_tlp)
        self.register_rx_tlp_handler(TlpType.MEM_WRITE, self.handle_mem_write_tlp)
        self.register_rx_tlp_handler(TlpType.MEM_WRITE_64, self.handle_mem_write_tlp)

    def add_region(self, size, read=None, write=None, ext=False, prefetch=False, io=False):
        if self.bar_ptr > 5 or (ext and self.bar_ptr > 4):
            raise Exception("No more BARs available")

        mem = None
        self.configure_bar(self.bar_ptr, size, ext, prefetch, io)
        if not read and not write:
            mem = mmap.mmap(-1, size)
            self.regions[self.bar_ptr] = mem
        else:
            self.regions[self.bar_ptr] = (read, write)
        if ext:
            self.bar_ptr += 2
        else:
            self.bar_ptr += 1
        return mem

    def add_io_region(self, size, read=None, write=None):
        return self.add_region(size, read, write, False, False, True)

    def add_mem_region(self, size, read=None, write=None):
        return self.add_region(size, read, write)

    def add_prefetchable_mem_region(self, size, read=None, write=None):
        return self.add_region(size, read, write, True, True)

    async def read_region(self, region, addr, length):
        if not self.regions[region]:
            raise Exception("Invalid region")
        if type(self.regions[region]) is tuple:
            return await self.regions[region][0](addr, length)
        else:
            return self.regions[region][addr:addr+length]

    async def write_region(self, region, addr, data):
        if not self.regions[region]:
            raise Exception("Invalid region")
        if type(self.regions[region]) is tuple:
            await self.regions[region][1](addr, data)
        else:
            self.regions[region][addr:addr+len(data)] = data

    async def handle_io_read_tlp(self, tlp):
        self.log.info("IO read, address 0x%08x, BE 0x%x, tag %d",
                tlp.address, tlp.first_be, tlp.tag)

        bar = self.match_bar(tlp.address, True)

        if not bar:
            self.log.warning("IO request did not match any BARs: %r", tlp)

            # Unsupported request
            cpl = Tlp.create_ur_completion_for_tlp(tlp, self.pcie_id)
            self.log.debug("UR Completion: %r", cpl)
            await self.send(cpl)
            return

        assert tlp.length == 1

        # prepare completion TLP
        cpl = Tlp.create_completion_data_for_tlp(tlp, self.pcie_id)

        region, addr = bar
        offset = 0
        start_offset = None
        mask = tlp.first_be

        # perform read
        data = bytearray(4)

        for k in range(4):
            if mask & (1 << k):
                if start_offset is None:
                    start_offset = offset
            else:
                if start_offset is not None and offset != start_offset:
                    data[start_offset:offset] = await self.read_region(region, addr+start_offset, offset-start_offset)
                start_offset = None

            offset += 1

        if start_offset is not None and offset != start_offset:
            data[start_offset:offset] = await self.read_region(region, addr+start_offset, offset-start_offset)

        cpl.set_data(data)
        cpl.byte_count = 4
        cpl.length = 1

        self.log.debug("Completion: %r", cpl)
        await self.send(cpl)

    async def handle_io_write_tlp(self, tlp):
        self.log.info("IO write, address 0x%08x, BE 0x%x, tag %d, data 0x%08x",
                tlp.address, tlp.first_be, tlp.tag, struct.unpack('<L', tlp.get_data())[0])

        bar = self.match_bar(tlp.address, True)

        if not bar:
            self.log.warning("IO request did not match any BARs: %r", tlp)

            # Unsupported request
            cpl = Tlp.create_ur_completion_for_tlp(tlp, self.pcie_id)
            self.log.debug("UR Completion: %r", cpl)
            await self.send(cpl)
            return

        assert tlp.length == 1

        # prepare completion TLP
        cpl = Tlp.create_completion_for_tlp(tlp, self.pcie_id)

        region, addr = bar
        offset = 0
        start_offset = None
        mask = tlp.first_be

        # perform write
        data = tlp.get_data()

        for k in range(4):
            if mask & (1 << k):
                if start_offset is None:
                    start_offset = offset
            else:
                if start_offset is not None and offset != start_offset:
                    await self.write_region(region, addr+start_offset, data[start_offset:offset])
                start_offset = None

            offset += 1

        if start_offset is not None and offset != start_offset:
            await self.write_region(region, addr+start_offset, data[start_offset:offset])

        cpl.byte_count = 4

        self.log.debug("Completion: %r", cpl)
        await self.send(cpl)

    async def handle_mem_read_tlp(self, tlp):
        self.log.info("Memory read, address 0x%08x, length %d, BE 0x%x/0x%x, tag %d",
                tlp.address, tlp.length, tlp.first_be, tlp.last_be, tlp.tag)

        bar = self.match_bar(tlp.address)

        if not bar:
            self.log.warning("Memory request did not match any BARs: %r", tlp)

            # Unsupported request
            cpl = Tlp.create_ur_completion_for_tlp(tlp, self.pcie_id)
            self.log.debug("UR Completion: %r", cpl)
            await self.send(cpl)
            return

        # perform operation
        region, addr = bar

        # check for 4k boundary crossing
        if tlp.length*4 > 0x1000 - (addr & 0xfff):
            print("Request crossed 4k boundary, discarding request")
            return

        # perform read
        data = bytearray(await self.read_region(region, addr, tlp.length*4))

        # prepare completion TLP(s)
        m = 0
        n = 0
        addr = tlp.address+tlp.get_first_be_offset()
        dw_length = tlp.length
        byte_length = tlp.get_be_byte_count()
        max_payload_dw = 32 << self.pcie_cap.max_payload_size
        rcb = 128
        rcb_mask = (rcb-1) & 0xfc

        while m < dw_length:
            cpl = Tlp.create_completion_data_for_tlp(tlp, self.pcie_id)

            cpl_dw_length = dw_length - m
            cpl.byte_count = byte_length - n
            if cpl_dw_length > max_payload_dw:
                # cut on RCB for largest possible TLP
                cpl_dw_length = max_payload_dw - ((addr & rcb_mask) >> 2)

            cpl.lower_address = addr & 0x7f

            cpl.set_data(data[m*4:(m+cpl_dw_length)*4])

            self.log.debug("Completion: %r", cpl)
            await self.send(cpl)

            m += cpl_dw_length
            n += cpl_dw_length*4 - (addr & 3)
            addr += cpl_dw_length*4 - (addr & 3)

    async def handle_mem_write_tlp(self, tlp):
        self.log.info("Memory write, address 0x%08x, length %d, BE 0x%x/0x%x",
                tlp.address, tlp.length, tlp.first_be, tlp.last_be)

        bar = self.match_bar(tlp.address)

        if not bar:
            self.log.warning("Memory request did not match any BARs: %r", tlp)
            return

        # perform operation
        region, addr = bar
        offset = 0
        start_offset = None
        mask = tlp.first_be

        # check for 4k boundary crossing
        if tlp.length*4 > 0x1000 - (addr & 0xfff):
            self.log.warning("Request crossed 4k boundary, discarding request")
            return

        # perform write
        data = tlp.get_data()

        # first dword
        for k in range(4):
            if mask & (1 << k):
                if start_offset is None:
                    start_offset = offset
            else:
                if start_offset is not None and offset != start_offset:
                    await self.write_region(region, addr+start_offset, data[start_offset:offset])
                start_offset = None

            offset += 1

        if tlp.length > 2:
            # middle dwords
            if start_offset is None:
                start_offset = offset
            offset += (tlp.length-2)*4

        if tlp.length > 1:
            # last dword
            mask = tlp.last_be

            for k in range(4):
                if mask & (1 << k):
                    if start_offset is None:
                        start_offset = offset
                else:
                    if start_offset is not None and offset != start_offset:
                        await self.write_region(region, addr+start_offset, data[start_offset:offset])
                    start_offset = None

                offset += 1

        if start_offset is not None and offset != start_offset:
            await self.write_region(region, addr+start_offset, data[start_offset:offset])

        # memory writes are posted, so don't send a completion



================================================
FILE: cocotbext/pcie/core/function.py
================================================
"""

Copyright (c) 2020 Alex Forencich

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

"""

import logging
import struct

from cocotb.queue import Queue
from cocotb.triggers import Event, Timer, First

from cocotbext.axi import AddressSpace

from .caps import PciCapList, PciExtCapList
from .caps import PmCapability, PcieCapability
from .region import MemoryTlpRegion, IoTlpRegion
from .tlp import Tlp, TlpType, TlpAttr, TlpTc, CplStatus
from .utils import PcieId


class Function:
    """PCIe function, implements config TLP handling"""
    def __init__(self, *args, **kwargs):
        self._pcie_id = PcieId()

        self.log = logging.getLogger(f"cocotb.pcie.{type(self).__name__}.{id(self)}")
        self.log.name = f"cocotb.pcie.{type(self).__name__}[{self._pcie_id}]"

        self.upstream_tx_handler = None

        self.current_tag = 0
        self.tag_count = 256
        self.tag_active = [False]*256
        self.tag_release = Event()

        self.rx_cpl_queues = [Queue() for k in range(256)]
        self.rx_cpl_sync = [Event() for k in range(256)]

        self.rx_tlp_handler = {}

        self.capabilities = PciCapList()
        self.ext_capabilities = PciExtCapList()

        # configuration registers
        # Vendor ID
        self.vendor_id = 0x1234
        # Device ID
        self.device_id = 0x00FF
        # Command
        self.io_space_enable = False
        self.memory_space_enable = False
        self.bus_master_enable = False
        self.parity_error_response_enable = False
        self.serr_enable = False
        self.interrupt_disable = False
        # Status
        self.interrupt_status = False
        self.capabilities_list = True
        self.master_data_parity_error = False
        self.signaled_target_abort = False
        self.received_target_abort = False
        self.received_master_abort = False
        self.signaled_system_error = False
        self.detected_parity_error = False
        # Revision ID
        self.revision_id = 0
        # Class code
        self.class_code = 0
        # Cache line size
        self.cache_line_size = 0
        # Latency timer
        self.latency_timer = 0
        # Header type
        self.header_layout = 0
        self.multifunction_device = False
        # BIST
        self.bist_capable = False
        self.start_bist = False
        self.bist_completion_code = 0
        # Base Address Registers
        self.bar = []
        self.bar_mask = []
        # Expansion ROM Base Address Register
        self.expansion_rom_addr = 0
        self.expansion_rom_addr_mask = 0
        self.expansion_rom_enable = 0
        # Capabilities pointer
        self.capabilities_ptr = 0
        # Interrupt line
        self.interrupt_line = 0
        # Interrupt pin
        self.interrupt_pin = 0

        self.register_rx_tlp_handler(TlpType.CFG_READ_0, self.handle_config_0_read_tlp)
        self.register_rx_tlp_handler(TlpType.CFG_WRITE_0, self.handle_config_0_write_tlp)

        self.pm_cap = PmCapability()
        self.register_capability(self.pm_cap)

        self.pcie_cap = PcieCapability()
        self.register_capability(self.pcie_cap)

        self.mem_address_space = AddressSpace(2**64)
        self.io_address_space = AddressSpace(2**32)

        self.mem_region = MemoryTlpRegion(self)
        self.io_region = IoTlpRegion(self)

        self.mem_address_space.register_region(self.mem_region, 0, 2**64)
        self.io_address_space.register_region(self.io_region, 0, 2**32)

        super().__init__(*args, **kwargs)

    @property
    def pcie_id(self):
        return self._pcie_id

    @pcie_id.setter
    def pcie_id(self, val):
        val = PcieId(val)
        if self._pcie_id != val:
            self.log.info("Assigned PCIe ID %s", val)
            self._pcie_id = val
            self.log.name = f"cocotb.pcie.{type(self).__name__}[{self._pcie_id}]"

    @property
    def bus_num(self):
        return self._pcie_id.bus

    @property
    def device_num(self):
        return self._pcie_id.device

    @property
    def function_num(self):
        return self._pcie_id.function

    """
    Common config space

    31                                                                  0
    +---------------------------------+---------------------------------+
    |            Device ID            |            Vendor ID            |   0   0x00
    +---------------------------------+---------------------------------+
    |             Status              |             Command             |   1   0x04
    +---------------------------------+----------------+----------------+
    |                    Class Code                    |  Revision ID   |   2   0x08
    +----------------+----------------+----------------+----------------+
    |      BIST      |  Header Type   |    Primary     |   Cache Line   |   3   0x0C
    |                |                | Latency Timer  |      Size      |
    +----------------+----------------+----------------+----------------+
    |                                                                   |   4   0x10
    +-------------------------------------------------------------------+
    |                                                                   |   5   0x14
    +-------------------------------------------------------------------+
    |                                                                   |   6   0x18
    +-------------------------------------------------------------------+
    |                                                                   |   7   0x1C
    +-------------------------------------------------------------------+
    |                                                                   |   8   0x20
    +-------------------------------------------------------------------+
    |                                                                   |   9   0x24
    +-------------------------------------------------------------------+
    |                                                                   |  10   0x28
    +-------------------------------------------------------------------+
    |                                                                   |  11   0x2C
    +-------------------------------------------------------------------+
    |                                                                   |  12   0x30
    +--------------------------------------------------+----------------+
    |                                                  |    Cap Ptr     |  13   0x34
    +--------------------------------------------------+----------------+
    |                                                                   |  14   0x38
    +---------------------------------+----------------+----------------+
    |                                 |    Int Pin     |    Int Line    |  15   0x3C
    +---------------------------------+----------------+----------------+
    """
    async def read_config_register(self, reg):
        if reg == 0:
            # Vendor ID
            val = self.vendor_id & 0xffff
            # Device ID
            val |= (self.device_id & 0xffff) << 16
            return val
        elif reg == 1:
            val = 0
            # Command
            val |= bool(self.io_space_enable) << 0
            val |= bool(self.memory_space_enable) << 1
            val |= bool(self.bus_master_enable) << 2
            val |= bool(self.parity_error_response_enable) << 6
            val |= bool(self.serr_enable) << 8
            val |= bool(self.interrupt_disable) << 10
            # Status
            val |= bool(self.interrupt_status) << 19
            val |= bool(self.capabilities_list) << 20
            val |= bool(self.master_data_parity_error) << 24
            val |= bool(self.signaled_target_abort) << 27
            val |= bool(self.received_target_abort) << 28
            val |= bool(self.received_master_abort) << 29
            val |= bool(self.signaled_system_error) << 30
            val |= bool(self.detected_parity_error) << 31
            return val
        elif reg == 2:
            # Revision ID
            val = self.revision_id & 0xff
            # Class code
            val |= (self.class_code & 0xffffff) << 8
            return val
        elif reg == 3:
            # Cache line size
            val = self.cache_line_size & 0xff
            # Latency timer
            val |= (self.latency_timer & 0xff) << 8
            # Header type
            val |= (self.header_layout & 0x7f) << 16
            val |= bool(self.multifunction_device) << 23
            # BIST
            val |= (self.bist_completion_code & 0xf) << 24
            val |= bool(self.start_bist) << 30
            val |= bool(self.bist_capable) << 31
            return val
        elif reg == 13:
            # Capabilities pointer
            return self.capabilities_ptr & 0xff
        elif reg == 15:
            # Interrupt line
            val = self.interrupt_line & 0xff
            # Interrupt pin
            val |= (self.interrupt_pin & 0xff) << 8
            return val
        elif 16 <= reg < 64:
            # PCIe capabilities
            return await self.read_capability_register(reg)
        elif 64 <= reg < 1024:
            # PCIe extended capabilities
            return await self.read_extended_capability_register(reg)
        else:
            return 0

    async def write_config_register(self, reg, data, mask):
        if reg == 1:
            # command
            if mask & 0x1:
                self.io_space_enable = (data & 1 << 0 != 0)
                self.memory_space_enable = (data & 1 << 1 != 0)
                self.bus_master_enable = (data & 1 << 2 != 0)
                self.parity_error_response_enable = (data & 1 << 6 != 0)
            if mask & 0x2:
                self.serr_enable = (data & 1 << 8 != 0)
                self.interrupt_disable = (data & 1 << 10 != 0)
            # status
            if mask & 0x8:
                if data & 1 << 24:
                    self.master_data_parity_error = False
                if data & 1 << 27:
                    self.signaled_target_abort = False
                if data & 1 << 28:
                    self.received_target_abort = False
                if data & 1 << 29:
                    self.received_master_abort = False
                if data & 1 << 30:
                    self.signaled_system_error = False
                if data & 1 << 31:
                    self.detected_parity_error = False
        elif reg == 3:
            if mask & 1:
                # Cache line size
                self.cache_line_size = data & 0xff
            if mask & 4:
                # BIST
                self.start_bist = bool(data & 1 << 30)
        elif reg == 15:
            # Interrupt line
            if mask & 1:
                self.interrupt_line = data & 0xff
        elif 16 <= reg < 64:
            # PCIe capabilities
            await self.write_capability_register(reg, data, mask)
        elif 64 <= reg < 1024:
            # PCIe extended capabilities
            await self.write_extended_capability_register(reg, data, mask)

    async def read_capability_register(self, reg):
        return await self.capabilities.read_register(reg)

    async def write_capability_register(self, reg, data, mask):
        await self.capabilities.write_register(reg, data, mask)

    def register_capability(self, cap, offset=None):
        cap.parent = self
        self.capabilities.register(cap, offset)
        if self.capabilities.list:
            self.capabilities_ptr = self.capabilities.list[0].offset*4
        else:
            self.capabilities_ptr = 0

    def deregister_capability(self, cap):
        self.capabilities.deregister(cap)

    async def read_extended_capability_register(self, reg):
        return await self.ext_capabilities.read_register(reg)

    async def write_extended_capability_register(self, reg, data, mask):
        await self.ext_capabilities.write_register(reg, data, mask)

    def register_extended_capability(self, cap, offset=None):
        cap.parent = self
        self.ext_capabilities.register(cap, offset)

    def deregister_extended_capability(self, cap):
        self.ext_capabilities.deregister(cap)

    def configure_bar(self, idx, size, ext=False, prefetch=False, io=False):
        mask = 2**((size-1).bit_length())-1

        if idx >= len(self.bar) or (ext and idx+1 >= len(self.bar)):
            raise Exception("BAR index out of range")

        if io:
            self.bar[idx] = 1
            self.bar_mask[idx] = 0xfffffffc & ~mask
        else:
            self.bar[idx] = 0
            self.bar_mask[idx] = 0xfffffff0 & ~mask

            if ext:
                self.bar[idx] |= 4
                self.bar[idx+1] = 0
                self.bar_mask[idx+1] = 0xffffffff & (~mask >> 32)

            if prefetch:
                self.bar[idx] |= 8

    def configure_io_bar(self, idx, size):
        self.configure_bar(idx, size, io=True)

    def match_bar(self, addr, io=False):
        bar = 0
        while bar < len(self.bar):
            bar_val = self.bar[bar]
            bar_mask = self.bar_mask[bar]

            orig_bar = bar
            bar += 1

            if bar_mask == 0:
                # unimplemented BAR
                continue

            if bar_val & 1:
                # IO BAR

                if io and (addr ^ bar_val) & bar_mask == 0:
                    return (orig_bar, addr & ~bar_mask)

            else:
                # Memory BAR

                if bar_val & 4:
                    # 64 bit BAR

                    if bar >= len(self.bar):
                        raise Exception("Final BAR marked as 64 bit, but no extension BAR available")

                    bar_val |= self.bar[bar] << 32
                    bar_mask |= self.bar_mask[bar] << 32

                    bar += 1

                if not io and (addr ^ bar_val) & bar_mask == 0:
                    return (orig_bar, addr & ~bar_mask)

        return None

    def match_io_bar(self, addr):
        return self.match_bar(addr, io=True)

    def match_tlp(self, tlp):
        if tlp.fmt_type in {TlpType.CFG_READ_0, TlpType.CFG_WRITE_0}:
            # Config type 0
            return self.device_num == tlp.completer_id.device and self.function_num == tlp.completer_id.function
        elif tlp.fmt_type in {TlpType.CFG_READ_1, TlpType.CFG_WRITE_1}:
            # Config type 1
            return False
        elif tlp.fmt_type in {TlpType.CPL, TlpType.CPL_DATA, TlpType.CPL_LOCKED, TlpType.CPL_LOCKED_DATA}:
            # Completion
            return self.pcie_id == tlp.requester_id
        elif tlp.fmt_type in {TlpType.IO_READ, TlpType.IO_WRITE}:
            # IO read/write
            return bool(self.match_bar(tlp.address, True))
        elif tlp.fmt_type in {TlpType.MEM_READ, TlpType.MEM_READ_64, TlpType.MEM_WRITE, TlpType.MEM_WRITE_64}:
            # Memory read/write
            return bool(self.match_bar(tlp.address))
        else:
            raise Exception("TODO")
        return False

    async def upstream_send(self, tlp):
        self.log.debug("Sending upstream TLP: %r", tlp)
        assert tlp.check()
        if self.parity_error_response_enable and tlp.ep:
            self.log.warning("Sending poisoned TLP, reporting master data parity error")
            self.master_data_parity_error = True
        if self.upstream_tx_handler is None:
            raise Exception("Transmit handler not set")
        await self.upstream_tx_handler(tlp)

    async def send(self, tlp):
        if tlp.is_completion() and tlp.status == CplStatus.CA:
            self.log.warning("Sending completion with CA status, reporting target abort")
            self.signaled_target_abort = True
        await self.upstream_send(tlp)

    async def upstream_recv(self, tlp):
        self.log.debug("Got downstream TLP: %r", tlp)
        assert tlp.check()
        if tlp.is_completion():
            if tlp.status == CplStatus.CA:
                self.log.warning("Received completion with CA status, reporting target abort")
                self.received_target_abort = True
            elif tlp.status == CplStatus.UR:
                self.log.warning("Received completion with UR status, reporting master abort")
                self.received_master_abort = True
        if self.parity_error_response_enable and tlp.ep:
            self.log.warning("Received poisoned TLP, reporting master data parity error")
            self.master_data_parity_error = True
        await self.handle_tlp(tlp)

    async def handle_tlp(self, tlp):
        if tlp.fmt_type in {TlpType.CPL, TlpType.CPL_DATA, TlpType.CPL_LOCKED, TlpType.CPL_LOCKED_DATA}:
            # completion
            self.rx_cpl_queues[tlp.tag].put_nowait(tlp)
            self.rx_cpl_sync[tlp.tag].set()
        elif tlp.fmt_type in self.rx_tlp_handler:
            # call registered handler
            tlp.release_fc()
            await self.rx_tlp_handler[tlp.fmt_type](tlp)
        else:
            # no handler registered for TLP type
            tlp.release_fc()
            raise Exception("Unhandled TLP")

    def register_rx_tlp_handler(self, fmt_type, func):
        self.rx_tlp_handler[fmt_type] = func

    async def recv_cpl(self, tag, timeout=0, timeout_unit='ns'):
        queue = self.rx_cpl_queues[tag]
        sync = self.rx_cpl_sync[tag]

        if not queue.empty():
            cpl = queue.get_nowait()
            cpl.release_fc()
            return cpl

        sync.clear()
        if timeout:
            await First(sync.wait(), Timer(timeout, timeout_unit))
        else:
            await sync.wait()

        if not queue.empty():
            cpl = queue.get_nowait()
            cpl.release_fc()
            return cpl

        return None

    async def alloc_tag(self):
        tag_count = min(256 if self.pcie_cap.extended_tag_field_enable else 32, self.tag_count)

        while True:
            tag = self.current_tag
            for k in range(tag_count):
                tag = (tag + 1) % tag_count
                if not self.tag_active[tag]:
                    self.tag_active[tag] = True
                    self.current_tag = tag
                    return tag

            self.tag_release.clear()
            await self.tag_release.wait()

    def release_tag(self, tag):
        assert self.tag_active[tag]
        self.tag_active[tag] = False
        self.tag_release.set()

    async def perform_posted_operation(self, req):
        await self.send(req)

    async def perform_nonposted_operation(self, req, timeout=0, timeout_unit='ns'):
        completions = []

        req.tag = await self.alloc_tag()

        await self.send(req)

        while True:
            cpl = await self.recv_cpl(req.tag, timeout, timeout_unit)

            if not cpl:
                break

            completions.append(cpl)

            if cpl.status != CplStatus.SC:
                # bad status
                break
            elif req.fmt_type in {TlpType.MEM_READ, TlpType.MEM_READ_64}:
                # completion for memory read request

                # request completed
                if cpl.byte_count <= cpl.length*4 - (cpl.lower_address & 0x3):
                    break

                # completion for read request has SC status but no data
                if cpl.fmt_type in {TlpType.CPL, TlpType.CPL_LOCKED}:
                    break

            else:
                # completion for other request
                break

        self.release_tag(req.tag)

        return completions

    async def handle_config_0_read_tlp(self, tlp):
        if tlp.completer_id.device == self.device_num and tlp.completer_id.function == self.function_num:
            self.log.info("Config type 0 read, reg 0x%03x", tlp.address >> 2)

            # capture address information
            if self.bus_num != tlp.completer_id.bus:
                self.log.info("Capture bus number %d", tlp.completer_id.bus)
                self.pcie_id = self.pcie_id._replace(bus=tlp.completer_id.bus)

            # perform operation
            data = await self.read_config_register(tlp.address >> 2)

            # prepare completion TLP
            cpl = Tlp.create_completion_data_for_tlp(tlp, self.pcie_id)
            cpl.set_data(struct.pack('<L', data))
            cpl.byte_count = 4

            self.log.debug("Completion: %r", cpl)
            await self.upstream_send(cpl)
        else:
            self.log.warning("Type 0 configuration read request device and function number mismatch: %r", tlp)

            # Unsupported request
            cpl = Tlp.create_ur_completion_for_tlp(tlp, self.pcie_id)
            self.log.debug("UR Completion: %r", cpl)
            await self.upstream_send(cpl)

    async def handle_config_0_write_tlp(self, tlp):
        if tlp.completer_id.device == self.device_num and tlp.completer_id.function == self.function_num:
            self.log.info("Config type 0 write, reg 0x%03x data 0x%08x",
                tlp.address >> 2, struct.unpack('<L', tlp.get_data())[0])

            # capture address information
            if self.bus_num != tlp.completer_id.bus:
                self.log.info("Capture bus number %d", tlp.completer_id.bus)
                self.pcie_id = self.pcie_id._replace(bus=tlp.completer_id.bus)

            data, = struct.unpack('<L', tlp.get_data())

            # perform operation
            await self.write_config_register(tlp.address >> 2, data, tlp.first_be)

            # prepare completion TLP
            cpl = Tlp.create_completion_for_tlp(tlp, self.pcie_id)

            self.log.debug("Completion: %r", cpl)
            await self.upstream_send(cpl)
        else:
            self.log.warning("Type 0 configuration write request device and function number mismatch: %r", tlp)

            # Unsupported request
            cpl = Tlp.create_ur_completion_for_tlp(tlp, self.pcie_id)
            self.log.debug("UR Completion: %r", cpl)
            await self.upstream_send(cpl)

    async def io_read(self, addr, length, timeout=0, timeout_unit='ns'):
        return await self.io_address_space.read(addr, length, timeout=timeout, timeout_unit=timeout_unit)

    async def io_read_words(self, addr, count, byteorder='little', ws=2, timeout=0, timeout_unit='ns'):
        data = await self.io_read(addr, count*ws, timeout, timeout_unit)
        words = []
        for k in range(count):
            words.append(int.from_bytes(data[ws*k:ws*(k+1)], byteorder))
        return words

    async def io_read_dwords(self, addr, count, byteorder='little', timeout=0, timeout_unit='ns'):
        return await self.io_read_words(addr, count, byteorder, 4, timeout, timeout_unit)

    async def io_read_qwords(self, addr, count, byteorder='little', timeout=0, timeout_unit='ns'):
        return await self.io_read_words(addr, count, byteorder, 8, timeout, timeout_unit)

    async def io_read_byte(self, addr, timeout=0, timeout_unit='ns'):
        return (await self.io_read(addr, 1, timeout, timeout_unit))[0]

    async def io_read_word(self, addr, byteorder='little', ws=2, timeout=0, timeout_unit='ns'):
        return (await self.io_read_words(addr, 1, byteorder, ws, timeout, timeout_unit))[0]

    async def io_read_dword(self, addr, byteorder='little', timeout=0, timeout_unit='ns'):
        return (await self.io_read_dwords(addr, 1, byteorder, timeout, timeout_unit))[0]

    async def io_read_qword(self, addr, byteorder='little', timeout=0, timeout_unit='ns'):
        return (await self.io_read_qwords(addr, 1, byteorder, timeout, timeout_unit))[0]

    async def io_write(self, addr, data, timeout=0, timeout_unit='ns'):
        await self.io_address_space.write(addr, data, timeout=timeout, timeout_unit=timeout_unit)

    async def io_write_words(self, addr, data, byteorder='little', ws=2, timeout=0, timeout_unit='ns'):
        words = data
        data = bytearray()
        for w in words:
            data.extend(w.to_bytes(ws, byteorder))
        await self.io_write(addr, data, timeout, timeout_unit)

    async def io_write_dwords(self, addr, data, byteorder='little', timeout=0, timeout_unit='ns'):
        await self.io_write_words(addr, data, byteorder, 4, timeout, timeout_unit)

    async def io_write_qwords(self, addr, data, byteorder='little', timeout=0, timeout_unit='ns'):
        await self.io_write_words(addr, data, byteorder, 8, timeout, timeout_unit)

    async def io_write_byte(self, addr, data, timeout=0, timeout_unit='ns'):
        await self.io_write(addr, [data], timeout, timeout_unit)

    async def io_write_word(self, addr, data, byteorder='little', ws=2, timeout=0, timeout_unit='ns'):
        await self.io_write_words(addr, [data], byteorder, ws, timeout, timeout_unit)

    async def io_write_dword(self, addr, data, byteorder='little', timeout=0, timeout_unit='ns'):
        await self.io_write_dwords(addr, [data], byteorder, timeout, timeout_unit)

    async def io_write_qword(self, addr, data, byteorder='little', timeout=0, timeout_unit='ns'):
        await self.io_write_qwords(addr, [data], byteorder, timeout, timeout_unit)

    async def mem_read(self, addr, length, timeout=0, timeout_unit='ns', attr=TlpAttr(0), tc=TlpTc.TC0):
        return await self.mem_address_space.read(addr, length, timeout=timeout, timeout_unit=timeout_unit, attr=attr, tc=tc)

    async def mem_read_words(self, addr, count, byteorder='little', ws=2, timeout=0, timeout_unit='ns', attr=TlpAttr(0), tc=TlpTc.TC0):
        data = await self.mem_read(addr, count*ws, timeout, timeout_unit, attr, tc)
        words = []
        for k in range(count):
            words.append(int.from_bytes(data[ws*k:ws*(k+1)], byteorder))
        return words

    async def mem_read_dwords(self, addr, count, byteorder='little', timeout=0, timeout_unit='ns', attr=TlpAttr(0), tc=TlpTc.TC0):
        return await self.mem_read_words(addr, count, byteorder, 4, timeout, timeout_unit, attr, tc)

    async def mem_read_qwords(self, addr, count, byteorder='little', timeout=0, timeout_unit='ns', attr=TlpAttr(0), tc=TlpTc.TC0):
        return await self.mem_read_words(addr, count, byteorder, 8, timeout, timeout_unit, attr, tc)

    async def mem_read_byte(self, addr, timeout=0, timeout_unit='ns', attr=TlpAttr(0), tc=TlpTc.TC0):
        return (await self.mem_read(addr, 1, timeout, timeout_unit, attr, tc))[0]

    async def mem_read_word(self, addr, byteorder='little', ws=2, timeout=0, timeout_unit='ns', attr=TlpAttr(0), tc=TlpTc.TC0):
        return (await self.mem_read_words(addr, 1, byteorder, ws, timeout, timeout_unit, attr, tc))[0]

    async def mem_read_dword(self, addr, byteorder='little', timeout=0, timeout_unit='ns', attr=TlpAttr(0), tc=TlpTc.TC0):
        return (await self.mem_read_dwords(addr, 1, byteorder, timeout, timeout_unit, attr, tc))[0]

    async def mem_read_qword(self, addr, byteorder='little', timeout=0, timeout_unit='ns', attr=TlpAttr(0), tc=TlpTc.TC0):
        return (await self.mem_read_qwords(addr, 1, byteorder, timeout, timeout_unit, attr, tc))[0]

    async def mem_write(self, addr, data, timeout=0, timeout_unit='ns', attr=TlpAttr(0), tc=TlpTc.TC0):
        await self.mem_address_space.write(addr, data, timeout=timeout, timeout_unit=timeout_unit, attr=attr, tc=tc)

    async def mem_write_words(self, addr, data, byteorder='little', ws=2, timeout=0, timeout_unit='ns', attr=TlpAttr(0), tc=TlpTc.TC0):
        words = data
        data = bytearray()
        for w in words:
            data.extend(w.to_bytes(ws, byteorder))
        await self.mem_write(addr, data, timeout, timeout_unit, attr, tc)

    async def mem_write_dwords(self, addr, data, byteorder='little', timeout=0, timeout_unit='ns', attr=TlpAttr(0), tc=TlpTc.TC0):
        await self.mem_write_words(addr, data, byteorder, 4, timeout, timeout_unit, attr, tc)

    async def mem_write_qwords(self, addr, data, byteorder='little', timeout=0, timeout_unit='ns', attr=TlpAttr(0), tc=TlpTc.TC0):
        await self.mem_write_words(addr, data, byteorder, 8, timeout, timeout_unit, attr, tc)

    async def mem_write_byte(self, addr, data, timeout=0, timeout_unit='ns', attr=TlpAttr(0), tc=TlpTc.TC0):
        await self.mem_write(addr, [data], timeout, timeout_unit, attr, tc)

    async def mem_write_word(self, addr, data, byteorder='little', ws=2, timeout=0, timeout_unit='ns', attr=TlpAttr(0), tc=TlpTc.TC0):
        await self.mem_write_words(addr, [data], byteorder, ws, timeout, timeout_unit, attr, tc)

    async def mem_write_dword(self, addr, data, byteorder='little', timeout=0, timeout_unit='ns', attr=TlpAttr(0), tc=TlpTc.TC0):
        await self.mem_write_dwords(addr, [data], byteorder, timeout, timeout_unit, attr, tc)

    async def mem_write_qword(self, addr, data, byteorder='little', timeout=0, timeout_unit='ns', attr=TlpAttr(0), tc=TlpTc.TC0):
        await self.mem_write_qwords(addr, [data], byteorder, timeout, timeout_unit, attr, tc)



================================================
FILE: cocotbext/pcie/core/msi.py
================================================
"""

Copyright (c) 2021 Alex Forencich

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

"""

import struct

import cocotb
from cocotb.triggers import Event

from cocotbext.axi import Region


class MsiVector:
    def __init__(self):
        self.addr = None
        self.data = None
        self.event = Event()
        self.cb = []


class MsiRegion(Region):
    def __init__(self, rc, size=16, *kwargs):
        super().__init__(size=size, *kwargs)
        self.rc = rc

        self.msi_msg_limit = 0
        self.msi_vectors = {}

    def alloc_vectors(self, num):
        vecs = []

        for k in range(num):
            vec = MsiVector()
            vec.addr = self.get_absolute_address(0)
            vec.data = self.msi_msg_limit
            vecs.append(vec)
            self.msi_vectors[vec.data] = vec
            self.msi_msg_limit += 1

        self.msi_msg_limit += self.msi_msg_limit % 32

        return vecs

    async def read(self, addr, length, **kwargs):
        return bytearray(1)*length

    async def write(self, addr, data, **kwargs):
        assert addr == 0
        assert len(data) == 4
        number, = struct.unpack('<L', data)
        self.rc.log.info("MSI interrupt: 0x%08x, 0x%04x", addr, number)
        assert number in self.msi_vectors
        vec = self.msi_vectors[number]
        vec.event.set()
        for cb in vec.cb:
            cocotb.start_soon(cb())



================================================
FILE: cocotbext/pcie/core/pci.py
================================================
"""

Copyright (c) 2022 Alex Forencich

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

"""

import struct

from cocotb.triggers import Timer

from .caps import PciCapId, PciExtCapId
from .utils import PcieId, align


class PciHostBridge:
    def __init__(self, rc):
        self.rc = rc

        self.bus_num = 0

        self.bus = PciBus(None, self, self.bus_num, rc=rc)

        self.pri_bus_num = 0
        self.sec_bus_num = 0
        self.sub_bus_num = 0xff

        self.io_base = 0
        self.io_limit = 0
        self.mem_base = 0
        self.mem_limit = 0
        self.prefetchable_mem_base = 0
        self.prefetchable_mem_limit = 0

        self.max_payload_size = 0
        self.max_payload_size_supported = 5
        self.max_read_request_size = 2

    def find_device(self, pcie_id):
        return self.bus.find_device(pcie_id)

    async def probe(self, timeout=1000, timeout_unit='ns'):
        await self.scan(timeout=timeout, timeout_unit=timeout_unit)
        await self.assign_resources()

    async def scan(self, timeout=1000, timeout_unit='ns'):
        last_bus = await self.bus.scan(timeout=timeout, timeout_unit=timeout_unit)
        self.bus.last_bus_num = last_bus

    async def assign_resources(self):
        await self.bus.assign_resources()

    def to_str(self):
        return self.bus.to_str()


class PciBus:
    def __init__(self, parent, bridge, bus_num, rc=None):
        self.rc = rc

        if parent:
            self.rc = parent.rc
        elif bridge:
            self.rc = bridge.rc

        # parent bus
        self.parent = parent

        # child buses
        self.children = []
        # devices on this bus
        self.devices = []

        # bridge device
        self.bridge = bridge

        if bridge:
            bridge.subordinate = self

        self.primary = 0
        self.bus_num = bus_num
        self.last_bus_num = 0xff

        if parent:
            self.primary = self.parent.bus_num

    def is_root(self):
        return not self.parent

    def find_device(self, pcie_id):
        for dev in self.devices:
            if dev.pcie_id == pcie_id:
                return dev
        for child in self.children:
            dev = child.find_device(pcie_id)
            if dev:
                return dev
        return None

    def only_one_child(self):
        if isinstance(self.bridge, PciHostBridge):
            return False
        if self.bridge.is_pcie() and self.bridge.is_downstream_port():
            return True
        return False

    async def wait_crs(self, dev_id, timeout=1000, timeout_unit='ns'):
        delay = 10
        val = 0xffff0001
        while val == 0xffff0001:
            if delay > 10000:
                self.rc.log.warning("pci %s: not ready after %d us; giving up", dev_id, delay)
                return False

            if delay > 1000:
                self.rc.log.info("pci %s: not ready after %d us; waiting", dev_id, delay)

            await Timer(delay, 'us')
            delay *= 2

            val = await self.rc.config_read_dword(dev_id, 0x000, 'little', timeout, timeout_unit)

        if delay > 1000:
            self.rc.log.info("pci %s: ready after %d us", dev_id, delay)

        return True

    async def scan(self, available_buses=0, timeout=1000, timeout_unit='ns'):
        first_bus = self.bus_num
        last_bus = first_bus

        # scan for devices
        for d in range(32):
            if self.bus_num == 0 and d == 0:
                continue

            dev_id = PcieId(self.bus_num, d, 0)

            self.rc.log.info("Enumerating bus %d device %d", self.bus_num, d)

            # read vendor ID and device ID
            val = await self.rc.config_read_dword(dev_id, 0x000, 'little', timeout, timeout_unit)

            if val in {0, 0xffffffff, 0xffff0000, 0x0000ffff}:
                continue

            if val == 0xffff0001:
                if not await self.wait_crs(dev_id, timeout, timeout_unit):
                    continue

            # valid vendor ID
            self.rc.log.info("Found device at %s", dev_id)

            for f in range(8):
                dev_id = PcieId(self.bus_num, d, f)

                # read vendor ID and device ID
                val = await self.rc.config_read_dword(dev_id, 0x000, 'little', timeout, timeout_unit)

                if val is None or val == 0xffffffff:
                    continue

                dev = PciDevice(self)
                dev.pcie_id = dev_id
                dev.vendor_id = val & 0xffff
                dev.device_id = (val >> 16) & 0xffff
                self.devices.append(dev)

                await dev.setup()

                if not dev.multifunction:
                    # only one function
                    break

            if self.only_one_child():
                break

        # recurse into bridges
        for dev in self.devices:
            if not dev.is_bridge():
                continue

            last_bus = await self.scan_bridge(dev, last_bus, timeout=timeout, timeout_unit=timeout_unit)

        return last_bus

    async def scan_bridge(self, dev, first_bus, available_buses=0, timeout=1000, timeout_unit='ns'):
        last_bus = first_bus

        self.rc.log.info("Scanning bridge %s", dev.pcie_id)

        await dev.enable_crs()

        next_bus = last_bus + 1

        child = PciBus(self, dev, next_bus)
        self.children.append(child)

        buses = await dev.config_read_dword(0x018)

        buses = (buses & 0xff000000) | (child.primary << 0) | (child.bus_num << 8) | (child.last_bus_num << 16)

        await dev.config_write_dword(0x018, buses)

        last_bus = await child.scan(timeout=timeout, timeout_unit=timeout_unit)

        child.last_bus_num = last_bus

        buses = (buses & 0xff000000) | (child.primary << 0) | (child.bus_num << 8) | (child.last_bus_num << 16)

        await dev.config_write_dword(0x018, buses)

        return last_bus

    async def assign_resources(self):
        for dev in self.devices:
            await dev.assign_resources()

            if dev.subordinate:
                dev.io_base = self.bridge.io_limit
                dev.io_limit = dev.io_base
                dev.mem_base = self.bridge.mem_limit
                dev.mem_limit = dev.mem_base
                dev.prefetchable_mem_base = self.bridge.prefetchable_mem_limit
                dev.prefetchable_mem_limit = dev.prefetchable_mem_base

                await dev.subordinate.assign_resources()

                # align limits against bridge registers
                dev.io_limit = align(dev.io_limit, 0xfff)
                dev.mem_limit = align(dev.mem_limit, 0xfffff)
                dev.prefetchable_mem_limit = align(dev.prefetchable_mem_limit, 0xfffff)

                self.bridge.io_limit = dev.io_limit
                self.bridge.mem_limit = dev.mem_limit
                self.bridge.prefetchable_mem_limit = dev.prefetchable_mem_limit

                dev.io_limit -= 1
                dev.mem_limit -= 1
                dev.prefetchable_mem_limit -= 1

                await dev.setup_bridge()

    def to_str(self, prefix=""):
        s = ""

        if self.last_bus_num > self.bus_num:
            s += f"[{self.bus_num:02x}-{self.last_bus_num:02x}]-"
            prefix += " "*8
        else:
            s += f"[{self.bus_num:02x}]-"
            prefix += " "*5

        for i in range(len(self.devices)):
            c = self.devices[i]

            if i > 0:
                s += prefix

            if len(self.devices) == 1:
                s += "-"
            elif len(self.devices)-1 == i:
                s += "\\"
            else:
                s += "+"

            s += f"-{c.device_num:02x}.{c.function_num:x}"

            if c.subordinate:
                if i < len(self.devices)-1:
                    s += "-"+c.subordinate.to_str(prefix+"|"+" "*6).strip()
                else:
                    s += "-"+c.subordinate.to_str(prefix+" "*7).strip()

            s += '\n'

        return s


class PciDevice:
    def __init__(self, bus, rc=None):
        self.rc = rc
        self._pcie_id = PcieId()

        if bus is not None:
            self.rc = bus.rc

        self.bus = bus
        self.subordinate = None

        self.hdr_type = 0
        self.multifunction = False
        self.class_code = 0
        self.revision_id = 0

        self.vendor_id = 0
        self.device_id = 0
        self.subsystem_vendor_id = 0
        self.subsystem_id = 0

        self.pri_bus_num = 0
        self.sec_bus_num = 0
        self.sub_bus_num = 0

        self.bar = [None]*6
        self.bar_raw = [None]*6
        self.bar_addr = [None]*6
        self.bar_size = [None]*6
        self.bar_window = [None]*6

        self.expansion_rom_raw = None
        self.expansion_rom_addr = None
        self.expansion_rom_size = None
        self.expansion_rom_window = None

        self.io_base = 0
        self.io_limit = 0
        self.mem_base = 0
        self.mem_limit = 0
        self.prefetchable_mem_base = 0
        self.prefetchable_mem_limit = 0

        self.capabilities = []
        self.ext_capabilities = []

        self.enable_cnt = 0
        self.is_busmaster = False

        self.pcie_capabilities_reg = 0
        self.pcie_devcap_reg = 0
        self.pcie_mpss = 0

        self.msix_enabled = False
        self.msi_enabled = False
        self.msi_vectors = []

    @property
    def pcie_id(self):
        return self._pcie_id

    @pcie_id.setter
    def pcie_id(self, val):
        self._pcie_id = PcieId(val)

    @property
    def bus_num(self):
        return self._pcie_id.bus

    @bus_num.setter
    def bus_num(self, value):
        self._pcie_id.bus = value

    @property
    def device_num(self):
        return self._pcie_id.device

    @device_num.setter
    def device_num(self, value):
        self._pcie_id.device = value

    @property
    def function_num(self):
        return self._pcie_id.function

    @function_num.setter
    def function_num(self, value):
        self._pcie_id.function = value

    def is_enabled(self):
        return self.enable_cnt > 0

    def is_bridge(self):
        return self.header_type in {0x01, 0x02}

    def is_pcie(self):
        return bool(self.get_capability_offset(PciCapId.EXP))

    def pcie_type(self):
        return (self.pcie_capabilities_reg >> 4) & 0xf

    def is_downstream_port(self):
        return self.pcie_type() in {0x4, 0x6, 0x8}

    def upstream_bridge(self):
        if self.bus.is_root():
            return None
        return self.bus.bridge

    def get_capability_offset(self, cap_id):
        if isinstance(cap_id, PciCapId):
            for c in self.capabilities:
                if c[0] == cap_id:
                    return c[1]
        elif isinstance(cap_id, PciExtCapId):
            for c in self.ext_capabilities:
                if c[0] == cap_id:
                    return c[1]
        return None

    async def config_read(self, addr, length, timeout=0, timeout_unit='ns'):
        return await self.rc.config_read(self.pcie_id, addr, length, timeout, timeout_unit)

    async def config_read_words(self, addr, count, byteorder='little', ws=2, timeout=0, timeout_unit='ns'):
        data = await self.config_read(addr, count*ws, timeout, timeout_unit)
        words = []
        for k in range(count):
            words.append(int.from_bytes(data[ws*k:ws*(k+1)], byteorder))
        return words

    async def config_read_dwords(self, addr, count, byteorder='little', timeout=0, timeout_unit='ns'):
        return await self.config_read_words(addr, count, byteorder, 4, timeout, timeout_unit)

    async def config_read_qwords(self, addr, count, byteorder='little', timeout=0, timeout_unit='ns'):
        return await self.config_read_words(addr, count, byteorder, 8, timeout, timeout_unit)

    async def config_read_byte(self, addr, timeout=0, timeout_unit='ns'):
        return (await self.config_read(addr, 1, timeout, timeout_unit))[0]

    async def config_read_word(self, addr, byteorder='little', ws=2, timeout=0, timeout_unit='ns'):
        return (await self.config_read_words(addr, 1, byteorder, ws, timeout, timeout_unit))[0]

    async def config_read_dword(self, addr, byteorder='little', timeout=0, timeout_unit='ns'):
        return (await self.config_read_dwords(addr, 1, byteorder, timeout, timeout_unit))[0]

    async def config_read_qword(self, addr, byteorder='little', timeout=0, timeout_unit='ns'):
        return (await self.config_read_qwords(addr, 1, byteorder, timeout, timeout_unit))[0]

    async def config_write(self, addr, data, timeout=0, timeout_unit='ns'):
        return await self.rc.config_write(self.pcie_id, addr, data, timeout, timeout_unit)

    async def config_write_words(self, addr, data, byteorder='little', ws=2, timeout=0, timeout_unit='ns'):
        words = data
        data = bytearray()
        for w in words:
            data.extend(w.to_bytes(ws, byteorder))
        await self.config_write(addr, data, timeout, timeout_unit)

    async def config_write_dwords(self, addr, data, byteorder='little', timeout=0, timeout_unit='ns'):
        await self.config_write_words(addr, data, byteorder, 4, timeout, timeout_unit)

    async def config_write_qwords(self, addr, data, byteorder='little', timeout=0, timeout_unit='ns'):
        await self.config_write_words(addr, data, byteorder, 8, timeout, timeout_unit)

    async def config_write_byte(self, addr, data, timeout=0, timeout_unit='ns'):
        await self.config_write(addr, [data], timeout, timeout_unit)

    async def config_write_word(self, addr, data, byteorder='little', ws=2, timeout=0, timeout_unit='ns'):
        await self.config_write_words(addr, [data], byteorder, ws, timeout, timeout_unit)

    async def config_write_dword(self, addr, data, byteorder='little', timeout=0, timeout_unit='ns'):
        await self.config_write_dwords(addr, [data], byteorder, timeout, timeout_unit)

    async def config_write_qword(self, addr, data, byteorder='little', timeout=0, timeout_unit='ns'):
        await self.config_write_qwords(addr, [data], byteorder, timeout, timeout_unit)

    async def capability_read(self, cap_id, addr, length, timeout=0, timeout_unit='ns'):
        offset = self.get_capability_offset(cap_id)

        if not offset:
            raise Exception("Capability not found")

        return await self.config_read(addr+offset, length, timeout, timeout_unit)

    async def capability_read_words(self, cap_id, addr, count, byteorder='little', ws=2, timeout=0, timeout_unit='ns'):
        data = await self.capability_read(cap_id, addr, count*ws, timeout, timeout_unit)
        words = []
        for k in range(count):
            words.append(int.from_bytes(data[ws*k:ws*(k+1)], byteorder))
        return words

    async def capability_read_dwords(self, cap_id, addr, count, byteorder='little', timeout=0, timeout_unit='ns'):
        return await self.capability_read_words(cap_id, addr, count, byteorder, 4, timeout, timeout_unit)

    async def capability_read_qwords(self, cap_id, addr, count, byteorder='little', timeout=0, timeout_unit='ns'):
        return await self.capability_read_words(cap_id, addr, count, byteorder, 8, timeout, timeout_unit)

    async def capability_read_byte(self, cap_id, addr, timeout=0, timeout_unit='ns'):
        return (await self.capability_read(cap_id, addr, 1, timeout, timeout_unit))[0]

    async def capability_read_word(self, cap_id, addr, byteorder='little', ws=2, timeout=0, timeout_unit='ns'):
        return (await self.capability_read_words(cap_id, addr, 1, byteorder, ws, timeout, timeout_unit))[0]

    async def capability_read_dword(self, cap_id, addr, byteorder='little', timeout=0, timeout_unit='ns'):
        return (await self.capability_read_dwords(cap_id, addr, 1, byteorder, timeout, timeout_unit))[0]

    async def capability_read_qword(self, cap_id, addr, byteorder='little', timeout=0, timeout_unit='ns'):
        return (await self.capability_read_qwords(cap_id, addr, 1, byteorder, timeout, timeout_unit))[0]

    async def capability_write(self, cap_id, addr, data, timeout=0, timeout_unit='ns'):
        offset = self.get_capability_offset(cap_id)

        if not offset:
            raise Exception("Capability not found")

        await self.config_write(addr+offset, data, timeout, timeout_unit)

    async def capability_write_words(self, cap_id, addr, data, byteorder='little', ws=2, timeout=0, timeout_unit='ns'):
        words = data
        data = bytearray()
        for w in words:
            data.extend(w.to_bytes(ws, byteorder))
        await self.capability_write(cap_id, addr, data, timeout, timeout_unit)

    async def capability_write_dwords(self, cap_id, addr, data, byteorder='little', timeout=0, timeout_unit='ns'):
        await self.capability_write_words(cap_id, addr, data, byteorder, 4, timeout, timeout_unit)

    async def capability_write_qwords(self, cap_id, addr, data, byteorder='little', timeout=0, timeout_unit='ns'):
        await self.capability_write_words(cap_id, addr, data, byteorder, 8, timeout, timeout_unit)

    async def capability_write_byte(self, cap_id, addr, data, timeout=0, timeout_unit='ns'):
        await self.capability_write(cap_id, addr, [data], timeout, timeout_unit)

    async def capability_write_word(self, cap_id, addr, data, byteorder='little', ws=2, timeout=0, timeout_unit='ns'):
        await self.capability_write_words(cap_id, addr, [data], byteorder, ws, timeout, timeout_unit)

    async def capability_write_dword(self, cap_id, addr, data, byteorder='little', timeout=0, timeout_unit='ns'):
        await self.capability_write_dwords(cap_id, addr, [data], byteorder, timeout, timeout_unit)

    async def capability_write_qword(self, cap_id, addr, data, byteorder='little', timeout=0, timeout_unit='ns'):
        await self.capability_write_qwords(cap_id, addr, [data], byteorder, timeout, timeout_unit)

    async def enable_bridge(self):
        bridge = self.upstream_bridge()
        if bridge:
            await bridge.enable_bridge()

        if self.is_enabled():
            if not self.is_busmaster:
                self.set_master()
            return

        await self.enable_device()
        await self.set_master()

    async def enable_device(self):
        self.enable_cnt += 1
        if self.enable_cnt > 1:
            return

        bridge = self.upstream_bridge()
        if bridge:
            await bridge.enable_bridge()

        bars = 0  # TODO

        await self.enable_resources(bars)

    async def enable_resources(self, mask):
        old_cmd = await self.config_read_word(0x04)
        cmd = old_cmd

        cmd |= (1 << 0)  # IO
        cmd |= (1 << 1)  # mem

        if cmd != old_cmd:
            self.rc.log.info("pci %s: enabling device (%04x -> %04x)", self.pcie_id, old_cmd, cmd)
            await self.config_write_word(0x04, cmd)

    async def disable_device(self):
        self.enable_cnt -= 1

        if self.enable_cnt > 0:
            return

        await self.clear_master()

    async def set_master(self, enable=True):
        old_cmd = await self.config_read_word(0x04)

        if enable:
            cmd = old_cmd | 1 << 2
        else:
            cmd = old_cmd & ~(1 << 2)

        if cmd != old_cmd:
            self.rc.log.info("pci %s: %s bus mastering", self.pcie_id, "enabling" if enable else "disabling")
            await self.config_write_word(0x04, cmd)
        self.is_busmaster = enable

    async def clear_master(self):
        await self.set_master(False)

    async def enable_crs(self):
        if not self.is_pcie():
            return

        root_cap = await self.capability_read_dword(PciCapId.EXP, 0x1E)

        if root_cap & 0x00000001:
            old_ctrl = await self.capability_read_word(PciCapId.EXP, 0x1C)

            ctrl = old_ctrl | 0x0010

            if ctrl != old_ctrl:
                await self.capability_write_word(PciCapId.EXP, 0x1C, ctrl)

    async def configure_msi(self):
        await self.rc.configure_msi(self)

    def msi_get_event(self, number=0):
        return self.rc.msi_get_event(self, number)

    def msi_register_callback(self, callback, number=0):
        self.rc.msi_register_callback(self, callback, number)

    async def setup(self):
        # read header type
        val = await self.config_read_byte(0x00e)

        self.header_type = val & 0x7f
        self.multifunction = bool(val & 0x80)

        val = await self.config_read_dword(0x008, 'little')

        self.revision_id = val & 0xff
        self.class_code = val >> 8

        self.rc.log.info("Found function at %s", self.pcie_id)
        self.rc.log.info("Header type: 0x%02x", self.header_type)
        self.rc.log.info("Vendor ID: 0x%04x", self.vendor_id)
        self.rc.log.info("Device ID: 0x%04x", self.device_id)
        self.rc.log.info("Revision ID: 0x%02x", self.revision_id)
        self.rc.log.info("Class code: 0x%06x", self.class_code)

        if self.header_type == 0x00:
            # normal function (type 0 header)
            val = await self.config_read_dword(0x02c)
            self.subsystem_vendor_id = val & 0xffff
            self.subsystem_id = (val >> 16) & 0xffff

            self.rc.log.info("Subsystem vendor ID: 0x%04x", self.subsystem_vendor_id)
            self.rc.log.info("Subsystem ID: 0x%04x", self.subsystem_id)

            await self.read_bars(6, 0x030)
            # await self.assign_bars(6, 0x030)

        elif self.header_type == 0x01:
            # bridge (type 1 header)
            self.rc.log.info("Found bridge at %s", self.pcie_id)

            await self.read_bars(2, 0x038)
            # await self.assign_bars(2, 0x038)

        elif self.header_type == 0x02:
            # cardbus bridge (type 2 header)
            self.rc.log.info("Found cardbus bridge at %s", self.pcie_id)

        else:
            # something else
            self.rc.log.error("pci %s: unknown header type 0x%02x", self.pcie_id, self.header_type)

        await self.walk_capabilities()

        if self.is_pcie():
            self.pcie_capabilities_reg = await self.capability_read_word(PciCapId.EXP, 0x2)
            self.pcie_devcap_reg = await self.capability_read_dword(PciCapId.EXP, 0x4)
            self.pcie_mpss = self.pcie_devcap_reg & 0x7

        await self.configure_device()
        await self.init_capabilities()

    async def walk_capabilities(self):
        self.rc.log.info("Walk capabilities of function %s", self.pcie_id)

        # walk capabilities
        ptr = await self.config_read_byte(0x34)
        ptr = ptr & 0xfc

        while ptr > 0:
            val = await self.config_read(ptr, 2)

            cap_id = val[0]
            next_ptr = val[1] & 0xfc

            self.rc.log.info("pci %s: Found capability ID 0x%02x at offset 0x%02x, next ptr 0x%02x",
                self.pcie_id, cap_id, ptr, next_ptr)

            self.capabilities.append((cap_id, ptr))
            ptr = next_ptr

        # walk extended capabilities
        ptr = 0x100

        while ptr > 0:
            val = await self.config_read_dword(ptr)
            if not val or val == 0xffffffff:
                break

            cap_id = val & 0xffff
            cap_ver = (val >> 16) & 0xf
            next_ptr = (val >> 20) & 0xffc

            self.rc.log.info("pci %s: Found extended capability ID 0x%04x version %d at offset 0x%03x, next ptr 0x%03x",
                self.pcie_id, cap_id, cap_ver, ptr, next_ptr)

            self.ext_capabilities.append((cap_id, ptr))
            ptr = next_ptr

    async def configure_device(self):
        await self.configure_mps()
        await self.configure_extended_tags()
        await self.configure_serr()

    async def configure_mps(self):
        if not self.is_pcie():
            return

        if self.pcie_type() == 0x9:
            # RC integrated endpoint
            await self.set_mps(self.pcie_mpss)
            return

        if self.pcie_type() == 0x4:
            # Root port
            await self.set_mps(self.bus.bridge.max_payload_size)
            return

        bridge = self.upstream_bridge()

        if not bridge or not bridge.is_pcie():
            return

        mps = await self.get_mps()
        parent_mps = await bridge.get_mps()

        if mps == parent_mps:
            return

        if self.pcie_mpss < parent_mps and bridge.pcie_type() == 0x4:
            # adjust root port config
            await bridge.set_mps(min(self.pcie_mpss, bridge.pcie_mpss))
            self.rc.log.info("pci %s: Upstream bridge's Max Payload Size set to %d (was %d, max %x)",
                self.pcie_id, 128 << self.pcie_mpss, 128 << parent_mps, 128 << bridge.pcie_mpss)
            parent_mps = await bridge.get_mps()

        await self.set_mps(min(parent_mps, self.pcie_mpss))

        self.rc.log.info("pci %s: Max Payload Size set to %d (was %d, max %d)",
            self.pcie_id, 128 << parent_mps, 128 << mps, 128 << self.pcie_mpss)

    async def get_readrq(self):
        devctl = await self.capability_read_dword(PciCapId.EXP, 0x8)

        return (devctl >> 12) & 0x7

    async def set_readrq(self, readrq):
        if readrq < 0 or readrq > 5:
            raise ValueError()

        old_devctl = await self.capability_read_dword(PciCapId.EXP, 0x8)

        devctl = old_devctl & ~(0x7000) | (readrq << 12)

        if devctl != old_devctl:
            await self.capability_write_dword(PciCapId.EXP, 0x8, devctl)

    async def get_mps(self):
        devctl = await self.capability_read_dword(PciCapId.EXP, 0x8)

        return (devctl >> 5) & 0x7

    async def set_mps(self, mps):
        if mps < 0 or mps > 5 or mps > self.pcie_mpss:
            raise ValueError()

        old_devctl = await self.capability_read_dword(PciCapId.EXP, 0x8)

        devctl = old_devctl & ~(0x00e0) | (mps << 5)

        if devctl != old_devctl:
            await self.capability_write_dword(PciCapId.EXP, 0x8, devctl)

    async def configure_extended_tags(self):
        if not self.is_pcie():
            return

        if not self.pcie_devcap_reg & (1 << 5):
            return

        devctl = await self.capability_read_dword(PciCapId.EXP, 0x8)

        if not devctl & (1 << 8):
            self.rc.log.info("pci %s: enabling Extended Tags", self.pcie_id)
            await self.capability_write_dword(PciCapId.EXP, 0x8, devctl | (1 << 8))

    async def configure_serr(self):
        if self.header_type != 0x01:
            return

        bridge_ctrl = await self.config_read_word(0x3e)
        if not bridge_ctrl & 0x02:
            await self.config_write_word(0x3e, bridge_ctrl | 0x02)

    async def init_capabilities(self):
        await self.msi_init()
        await self.msix_init()

    async def msi_init(self):
        if not self.get_capability_offset(PciCapId.MSI):
            return

        await self.msi_set_enable(False)

    async def msi_vec_count(self):
        if not self.get_capability_offset(PciCapId.MSI):
            return -1

        ctrl = await self.capability_read_word(PciCapId.MSI, 0x02)
        return 1 << ((ctrl >> 1) & 0x7)

    async def msi_set_enable(self, enable):
        old_ctrl = await self.capability_read_word(PciCapId.MSI, 0x02)
        if enable:
            ctrl = old_ctrl | 0x0001
        else:
            ctrl = old_ctrl & ~0x0001
        if ctrl != old_ctrl:
            await self.capability_write_word(PciCapId.MSI, 0x02, ctrl)
        self.msi_enabled = enable

    async def msi_capability_init(self, nvec):
        self.rc.log.info("pci %s: configuring MSI", self.pcie_id)

        await self.msi_set_enable(False)
        self.msi_enabled = True

        if not self.msi_vectors:
            self.msi_vectors = self.rc.msi_alloc_vectors(32)

        msg_ctrl = await self.capability_read_dword(PciCapId.MSI, 0)

        msi_64bit = (msg_ctrl >> 23) & 1
        msi_mmcap = (msg_ctrl >> 17) & 7

        msi_addr = self.msi_vectors[0].addr
        msi_data = self.msi_vectors[0].data

        # message address
        await self.capability_write_dword(PciCapId.MSI, 4, msi_addr & 0xfffffffc)

        if msi_64bit:
            # 64 bit message address
            # message upper address
            await self.capability_write_dword(PciCapId.MSI, 8, (msi_addr >> 32) & 0xffffffff)
            # message data
            await self.capability_write_dword(PciCapId.MSI, 12, msi_data)

        else:
            # 32 bit message address
            # message data
            await self.capability_write_dword(PciCapId.MSI, 8, msi_data)

        # enable and set enabled messages
        msg_ctrl |= 1 << 16
        msg_ctrl = (msg_ctrl & ~(7 << 20)) | (msi_mmcap << 20)
        await self.capability_write_dword(PciCapId.MSI, 0, msg_ctrl)

        self.rc.log.info("pci %s: MSI count: %d", self.pcie_id, len(self.msi_vectors))
        self.rc.log.info("pci %s: MSI address: 0x%08x", self.pcie_id, msi_addr)
        self.rc.log.info("pci %s: MSI base data: 0x%08x", self.pcie_id, msi_data)

        await self.msi_set_enable(True)
        return 0

    async def enable_msi_range(self, min_vecs, max_vecs):
        if not self.get_capability_offset(PciCapId.MSI):
            return -1

        if self.msix_enabled:
            self.rc.log.info("pci %s: can't enable MSI (MSI-X already enabled)", self.pcie_id)
            return -1

        if max_vecs < min_vecs:
            return -1

        if self.msi_enabled:
            return -1

        nvec = await self.msi_vec_count()
        if nvec < 0:
            return nvec
        if nvec < min_vecs:
            return -1

        if nvec > max_vecs:
            nvec = max_vecs

        rc = await self.msi_capability_init(nvec)
        if rc == 0:
            return nvec
        if rc < 0:
            return rc

        return -1

    async def disable_msi(self):
        if not self.msi_enabled:
            return

        await self.msi_set_enable(False)

    async def msix_init(self):
        if not self.get_capability_offset(PciCapId.MSIX):
            return

        await self.msix_set_enable(False)

    async def msix_vec_count(self):
        if not self.get_capability_offset(PciCapId.MSIX):
            return -1

        ctrl = await self.capability_read_word(PciCapId.MSIX, 0x02)
        return (ctrl & 0x7ff) + 1

    async def msix_set_enable(self, enable):
        old_ctrl = await self.capability_read_word(PciCapId.MSIX, 0x02)
        if enable:
            ctrl = old_ctrl | 0x8000
        else:
            ctrl = old_ctrl & ~0x8000
        if ctrl != old_ctrl:
            await self.capability_write_word(PciCapId.MSIX, 0x02, ctrl)
        self.msix_enabled = enable

    async def msix_capability_init(self, nvec):
        self.rc.log.info("pci %s: configuring MSI-X", self.pcie_id)

        await self.msix_set_enable(False)
        self.msix_enabled = True

        msg_ctrl = await self.capability_read_dword(PciCapId.MSIX, 0)

        table_size = ((msg_ctrl >> 16) & 0x7ff) + 1

        table_offset = await self.capability_read_dword(PciCapId.MSIX, 4)

        table_bir = table_offset & 0x7
        table_offset &= ~0x7

        pba_offset = await self.capability_read_dword(PciCapId.MSIX, 8)

        pba_bir = pba_offset & 0x7
        pba_offset &= ~0x7

        self.rc.log.info("pci %s: MSI-X table size: %d", self.pcie_id, table_size)
        self.rc.log.info("pci %s: MSI-X table BIR: %d", self.pcie_id, table_bir)
        self.rc.log.info("pci %s: MSI-X table offset: 0x%08x", self.pcie_id, table_offset)
        self.rc.log.info("pci %s: MSI-X PBA BIR: %d", self.pcie_id, pba_bir)
        self.rc.log.info("pci %s: MSI-X PBA offset: 0x%08x", self.pcie_id, pba_offset)

        if not self.msi_vectors:
            self.msi_vectors = self.rc.msi_alloc_vectors(table_size)

        # configure vectors
        for k in range(table_size):
            addr = self.msi_vectors[k].addr
            data = self.msi_vectors[k].data
            self.rc.log.info("pci %s: Configure vector %d", self.pcie_id, k)
            await self.bar_window[table_bir].write_dword(table_offset + k*16 + 0, addr & 0xfffffffc)
            await self.bar_window[table_bir].write_dword(table_offset + k*16 + 4, (addr >> 32) & 0xffffffff)
            await self.bar_window[table_bir].write_dword(table_offset + k*16 + 8, data & 0xffffffff)
            await self.bar_window[table_bir].write_dword(table_offset + k*16 + 12, 0x00000000)

        # dummy read
        await self.bar_window[table_bir].read_dword(table_offset)

        # enable MSI-X
        msg_ctrl |= 1 << 31
        await self.capability_write_dword(PciCapId.MSIX, 0, msg_ctrl)

        await self.msix_set_enable(True)
        return 0

    async def enable_msix_range(self, min_vecs, max_vecs, flags):
        if not self.get_capability_offset(PciCapId.MSIX):
            return -1

        if self.msi_enabled:
            self.rc.log.info("pci %s: can't enable MSI-X (MSI already enabled)", self.pcie_id)
            return -1

        if max_vecs < min_vecs:
            return -1

        if self.msix_enabled:
            return -1

        nvec = await self.msix_vec_count()
        if nvec < 0:
            return nvec
        if nvec < min_vecs:
            return -1

        if nvec > max_vecs:
            nvec = max_vecs

        rc = await self.msix_capability_init(nvec)
        if rc == 0:
            return nvec
        if rc < 0:
            return rc

        return -1

    async def disable_msix(self):
        if not self.msix_enabled:
            return

        await self.msix_set_enable(False)

    async def alloc_irq_vectors(self, min_vecs, max_vecs, flags=0):
        nvecs = -1
        if 1:
            nvecs = await self.enable_msix_range(min_vecs, max_vecs, flags)
            if nvecs > 0:
                return nvecs

        if 1:
            nvecs = await self.enable_msi_range(min_vecs, max_vecs)
            if nvecs > 0:
                return nvecs

        return nvecs

    async def free_irq_vectors(self):
        await self.disable_msi()
        await self.disable_msix()

    def request_irq(self, nr, handler):
        self.msi_vectors[nr].cb.append(handler)

    async def assign_resources(self):
        if self.header_type == 0x00:
            # normal function (type 0 header)
            await self.assign_bars(6, 0x030)

        elif self.header_type == 0x01:
            # bridge (type 1 header)
            await self.assign_bars(2, 0x038)

        elif self.header_type == 0x02:
            # cardbus bridge (type 2 header)
            pass

    async def read_bars(self, bar_cnt, rom):
        # disable IO and memory decoding while probing BARs
        old_cmd = await self.config_read_word(0x04)
        cmd = old_cmd & ~((1 << 0) | (1 << 1))
        if cmd != old_cmd:
            await self.config_write_word(0x04, cmd)

        bar = 0
        while bar < bar_cnt:
            # read BAR
            orig_bar = await self.config_read_dword(0x010+bar*4)
            await self.config_write_dword(0x010+bar*4, 0xffffffff)
            val = await self.config_read_dword(0x010+bar*4)
            await self.config_write_dword(0x010+bar*4, orig_bar)

            if val == 0:
                # unimplemented BAR
                self.bar_raw[bar] = 0
                self.bar_size[bar] = 0
                bar += 1
                continue

            self.rc.log.info("Enumerate function %s BAR%d", self.pcie_id, bar)

            if val & 0x1:
                # IO BAR
                mask = (~val & 0xffffffff) | 0x3
                size = mask + 1
                self.rc.log.info("pci %s: IO BAR%d raw: 0x%08x, mask: 0x%08x, size: %d",
                    self.pcie_id, bar, val, mask, size)

                self.bar_raw[bar] = orig_bar
                self.bar_size[bar] = size

                bar += 1

            elif val & 0x4:
                # 64 bit memory BAR
                if bar >= bar_cnt-1:
                    raise Exception("Invalid BAR configuration")

                # read adjacent BAR
                orig_bar2 = await self.config_read_dword(0x010+bar*4)
                await self.config_write_dword(0x010+(bar+1)*4, 0xffffffff)
                val2 = await self.config_read_dword(0x010+(bar+1)*4)
                await self.config_write_dword(0x010+(bar+1)*4, orig_bar2)
                val |= val2 << 32
                mask = (~val & 0xffffffffffffffff) | 0xf
                size = mask + 1
                self.rc.log.info("pci %s: Mem BAR%d (64-bit) raw: 0x%016x, mask: 0x%016x, size: %d",
                    self.pcie_id, bar, val, mask, size)

                self.bar_raw[bar] = orig_bar | (orig_bar2 << 32)
                self.bar_size[bar] = size

                bar += 2

            else:
                # 32 bit memory BAR
                mask = (~val & 0xffffffff) | 0xf
                size = mask + 1
                self.rc.log.info("pci %s: Mem BAR%d (32-bit) raw: 0x%08x, mask: 0x%08x, size: %d",
                    self.pcie_id, bar, val, mask, size)

                self.bar_raw[bar] = orig_bar
                self.bar_size[bar] = size

                bar += 1

        if rom:
            # read register
            orig_bar = await self.config_read_dword(rom)
            await self.config_write_dword(rom, 0xfffff800)
            val = await self.config_read_dword(rom)
            await self.config_write_dword(rom, orig_bar)

            if val:
                self.rc.log.info("Configure function %s expansion ROM", self.pcie_id)

                mask = (~val & 0xffffffff) | 0x7ff
                size = mask + 1
                self.rc.log.info("pci %s: expansion ROM raw: 0x%08x, mask: 0x%08x, size: %d",
                    self.pcie_id, val, mask, size)

                self.expansion_rom_raw = orig_bar
                self.expansion_rom_size = size
            else:
                # not implemented
                self.expansion_rom_raw = 0
                self.expansion_rom_size = 0

    async def assign_bars(self, bar_cnt, rom):
        bar = 0
        while bar < bar_cnt:
            bar_raw = self.bar_raw[bar]
            bar_size = self.bar_size[bar]

            if bar_size == 0:
                # unimplemented BAR
                bar += 1
                continue

            self.rc.log.info("Configure function %s BAR%d", self.pcie_id, bar)

            if bar_raw & 0x1:
                # IO BAR
                self.bus.bridge.io_limit = align(self.bus.bridge.io_limit, bar_size-1)

                addr = self.bus.bridge.io_limit
                self.bus.bridge.io_limit += bar_size

                bar_raw = bar_raw & 0x3 | addr

                self.bar[bar] = bar_raw
                self.bar_raw[bar] = bar_raw
                self.bar_addr[bar] = addr
                self.bar_window[bar] = self.rc.io_address_space.create_window(addr, bar_size)

                self.rc.log.info("pci %s: IO BAR%d allocation: 0x%08x, raw: 0x%08x, size: %d",
                    self.pcie_id, bar, addr, bar_raw, bar_size)

                # write BAR
                await self.config_write_dword(0x010+bar*4, bar_raw)

                bar += 1

            elif bar_raw & 0x4:
                # 64 bit memory BAR
                if bar >= bar_cnt-1:
                    raise Exception("Invalid BAR configuration")

                if bar_raw & 0x8:
                    # prefetchable
                    # align and allocate
                    self.bus.bridge.prefetchable_mem_limit = align(self.bus.bridge.prefetchable_mem_limit, bar_size-1)
                    addr = self.bus.bridge.prefetchable_mem_limit
                    self.bus.bridge.prefetchable_mem_limit += bar_size

                else:
                    # not-prefetchable
                    self.rc.log.info("pci %s: Mem BAR%d (64-bit) marked non-prefetchable, "
                        "allocating from 32-bit non-prefetchable address space", self.pcie_id, bar)
                    # align and allocate
                    self.bus.bridge.mem_limit = align(self.bus.bridge.mem_limit, bar_size-1)
                    addr = self.bus.bridge.mem_limit
                    self.bus.bridge.mem_limit += bar_size

                bar_raw = bar_raw & 0xf | addr

                self.bar[bar] = bar_raw
                self.bar_raw[bar] = bar_raw & 0xffffffff
                self.bar_raw[bar+1] = (bar_raw >> 32) & 0xffffffff
                self.bar_addr[bar] = addr
                self.bar_window[bar] = self.rc.mem_address_space.create_window(addr, bar_size)

                self.rc.log.info("pci %s: Mem BAR%d (64-bit) allocation: 0x%016x, raw: 0x%016x, size: %d",
                    self.pcie_id, bar, addr, bar_raw, bar_size)

                # write BAR
                await self.config_write_dword(0x010+bar*4, bar_raw & 0xffffffff)
                await self.config_write_dword(0x010+(bar+1)*4, (bar_raw >> 32) & 0xffffffff)

                bar += 2

            else:
                # 32 bit memory BAR
                if bar_raw & 0x8:
                    # prefetchable
                    self.rc.log.info("pci %s: Mem BAR%d (32-bit) marked prefetchable, "
                        "but allocating as non-prefetchable", self.pcie_id, bar)

                # align and allocate
                self.bus.bridge.mem_limit = align(self.bus.bridge.mem_limit, bar_size-1)
                addr = self.bus.bridge.mem_limit
                self.bus.bridge.mem_limit += bar_size

                bar_raw = bar_raw & 0xf | addr

                self.bar[bar] = bar_raw
                self.bar_raw[bar] = bar_raw
                self.bar_addr[bar] = addr
                self.bar_window[bar] = self.rc.mem_address_space.create_window(addr, bar_size)

                self.rc.log.info("pci %s: Mem BAR%d (32-bit) allocation: 0x%08x, raw: 0x%08x, size: %d",
                    self.pcie_id, bar, addr, bar_raw, bar_size)

                # write BAR
                await self.config_write_dword(0x010+bar*4, bar_raw)

                bar += 1

        # configure expansion ROM
        if self.expansion_rom_size:
            bar_size = self.expansion_rom_size
            bar_raw = self.expansion_rom_raw

            self.rc.log.info("Configure function %s expansion ROM", self.pcie_id)

            # align and allocate
            self.bus.bridge.mem_limit = align(self.bus.bridge.mem_limit, bar_size-1)
            addr = self.bus.bridge.mem_limit
            self.bus.bridge.mem_limit += bar_size

            bar_raw = bar_raw & 0x7ff | addr

            self.expansion_rom_raw = bar_raw
            self.expansion_rom_addr = addr
            self.expansion_rom_window = self.rc.mem_address_space.create_window(addr, bar_size)

            self.rc.log.info("pci %s: expansion ROM allocation: 0x%08x, raw: 0x%08x, size: %d",
                self.pcie_id, addr, bar_raw, bar_size)

            # write register
            await self.config_write_dword(rom, bar_raw)

    async def setup_bridge(self):
        self.rc.log.info("Set IO base: 0x%08x, limit: 0x%08x", self.io_base, self.io_limit)

        await self.config_write(0x01C, struct.pack('BB',
            (self.io_base >> 8) & 0xf0, (self.io_limit >> 8) & 0xf0))
        await self.config_write(0x030, struct.pack('<HH', self.io_base >> 16, self.io_limit >> 16))

        self.rc.log.info("Set mem base: 0x%08x, limit: 0x%08x", self.mem_base, self.mem_limit)

        await self.config_write(0x020, struct.pack('<HH',
            (self.mem_base >> 16) & 0xfff0, (self.mem_limit >> 16) & 0xfff0))

        self.rc.log.info("Set prefetchable mem base: 0x%016x, limit: 0x%016x",
            self.prefetchable_mem_base, self.prefetchable_mem_limit)

        await self.config_write(0x024, struct.pack('<HH',
            (self.prefetchable_mem_base >> 16) & 0xfff0, (self.prefetchable_mem_limit >> 16) & 0xfff0))
        await self.config_write(0x028, struct.pack('<L', self.prefetchable_mem_base >> 32))
        await self.config_write(0x02c, struct.pack('<L', self.prefetchable_mem_limit >> 32))



================================================
FILE: cocotbext/pcie/core/port.py
================================================
"""

Copyright (c) 2020 Alex Forencich

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

"""

from functools import partial
import logging

import cocotb
from cocotb.queue import Queue
from cocotb.triggers import Event, First, Timer, NullTrigger
from cocotb.utils import get_sim_time, get_sim_steps

from .dllp import Dllp, DllpType, FcType
from .tlp import Tlp

PCIE_GEN_RATE = {
    1: 2.5e9*8/10,
    2: 5e9*8/10,
    3: 8e9*128/130,
    4: 16e9*128/130,
    5: 32e9*128/130,
}

PCIE_GEN_SYMB_TIME = {
    1: 8/PCIE_GEN_RATE[1],
    2: 8/PCIE_GEN_RATE[2],
    3: 8/PCIE_GEN_RATE[3],
    4: 8/PCIE_GEN_RATE[4],
    5: 8/PCIE_GEN_RATE[5],
}


def get_update_factor(max_payload_size, link_width):
    if max_payload_size <= 256:
        if link_width <= 4:
            return 1.4
        elif link_width == 8:
            return 2.5
        else:
            return 3.0
    else:
        if link_width <= 8:
            return 1.0
        else:
            return 2.0


def get_max_update_latency(max_payload_size, link_width, link_speed):
    uf = get_update_factor(max_payload_size, link_width)
    if link_speed == 1:
        delay = 19
    elif link_speed == 2:
        delay = 70
    else:
        delay = 115
    return (((max_payload_size+28)*uf) / link_width) + delay



class FcStateData:
    def __init__(self, init=0, *args, **kwargs):
        self.__dict__.setdefault('_base_field_size', 16)

        self.tx_field_size = self._base_field_size
        self.tx_field_range = 2**self.tx_field_size
        self.tx_field_mask = self.tx_field_range-1

        self.rx_field_size = self._base_field_size
        self.rx_field_range = 2**self.rx_field_size
        self.rx_field_mask = self.rx_field_range-1

        init = max(init, 0)

        # Initial allocation of credits from receiver
        self.tx_initial_allocation = 0
        # Count of total number of FC units consumed at transmitter
        self.tx_credits_consumed = 0
        # Most recent number of FC units advertised by receiver
        self.tx_credit_limit = 0
        # Initial allocation of credits at receiver
        self.rx_initial_allocation = init
        # Total number of units granted to transmitter
        self.rx_credits_allocated = init
        # Total number of FC units consumed at receiver
        self.rx_credits_received = 0

        if init >= 2**(self._base_field_size-1):
            raise ValueError("Initial credit allocation out of range")

        super().__init__(*args, **kwargs)

    def reset(self):
        self.tx_initial_allocation = 0
        self.tx_credits_consumed = 0
        self.tx_credit_limit = 0
        self.rx_credits_allocated = self.rx_initial_allocation
        self.rx_credits_received = 0

    @property
    def tx_credits_available(self):
        if self.tx_is_infinite():
            return self.tx_field_mask
        else:
            return (self.tx_credit_limit - self.tx_credits_consumed) & self.tx_field_mask

    @property
    def rx_credits_available(self):
        if self.rx_is_infinite():
            return self.rx_field_mask
        else:
            return (self.rx_credits_allocated - self.rx_credits_received) & self.rx_field_mask

    def tx_is_infinite(self):
        return self.tx_initial_allocation == 0

    def rx_is_infinite(self):
        return self.rx_initial_allocation == 0

    def tx_consume_fc(self, fc):
        if not self.tx_is_infinite():
            self.tx_credits_consumed = (self.tx_credits_consumed + fc) & self.tx_field_mask
            # assert self.tx_credits_available < self.tx_field_range // 2

    def rx_consume_fc(self, fc):
        if not self.rx_is_infinite():
            self.rx_credits_received = (self.rx_credits_received + fc) & self.rx_field_mask
            # assert self.rx_credits_available < self.rx_field_range // 2

    def rx_release_fc(self, fc):
        if not self.rx_is_infinite():
            self.rx_credits_allocated = (self.rx_credits_allocated + fc) & self.rx_field_mask


class FcStateHeader(FcStateData):
    def __init__(self, *args, **kwargs):
        self._base_field_size = 12
        super().__init__(*args, **kwargs)


class FcChannelState:
    def __init__(self, init=[0]*6, start_fc_update_timer=None):
        self.ph = FcStateHeader(init[0])
        self.pd = FcStateData(init[1])
        self.nph = FcStateHeader(init[2])
        self.npd = FcStateData(init[3])
        self.cplh = FcStateHeader(init[4])
        self.cpld = FcStateData(init[5])

        self.active = False
        self.fi1 = False
        self.fi1p = False
        self.fi1np = False
        self.fi1cpl = False
        self.fi2 = False
        self.initialized = Event()

        self.fc_p_update = Event()
        self.fc_np_update = Event()
        self.fc_cpl_update = Event()

        self.start_fc_update_timer = start_fc_update_timer

        self.next_fc_p_tx = 0
        self.next_fc_np_tx = 0
        self.next_fc_cpl_tx = 0

        self.rx_release_fc_dict = {}

    def reset(self):
        self.ph.reset()
        self.pd.reset()
        self.nph.reset()
        self.npd.reset()
        self.cplh.reset()
        self.cpld.reset()

        self.active = False
        self.fi1 = False
        self.fi1p = False
        self.fi1np = False
        self.fi1cpl = False
        self.fi2 = False
        self.initialized.clear()

        self.next_fc_p_tx = 0
        self.next_fc_np_tx = 0
        self.next_fc_cpl_tx = 0

        self.rx_release_fc_dict = {}

    def tx_has_credit(self, credit_type, dc=0):
        if credit_type == FcType.P:
            return self.ph.tx_credits_available > 0 and self.pd.tx_credits_available >= dc
        elif credit_type == FcType.NP:
            return self.nph.tx_credits_available > 0 and self.npd.tx_credits_available >= dc
        elif credit_type == FcType.CPL:
            return self.cplh.tx_credits_available > 0 and self.cpld.tx_credits_available >= dc

    def tx_tlp_has_credit(self, tlp):
        return self.tx_has_credit(tlp.get_fc_type(), tlp.get_data_credits())

    def tx_consume_fc(self, credit_type, dc=0):
        if credit_type == FcType.P:
            self.ph.tx_consume_fc(1)
            self.pd.tx_consume_fc(dc)
        elif credit_type == FcType.NP:
            self.nph.tx_consume_fc(1)
            self.npd.tx_consume_fc(dc)
        elif credit_type == FcType.CPL:
            self.cplh.tx_consume_fc(1)
            self.cpld.tx_consume_fc(dc)

    def tx_consume_tlp_fc(self, tlp):
        self.tx_consume_fc(tlp.get_fc_type(), tlp.get_data_credits())

    async def tx_tlp_fc_gate(self, tlp):
        credit_type = tlp.get_fc_type()
        dc = tlp.get_data_credits()
        await self.initialized.wait()
        while not self.tx_has_credit(credit_type, dc):
            if credit_type == FcType.P:
                self.fc_p_update.clear()
                await self.fc_p_update.wait()
            elif credit_type == FcType.NP:
                self.fc_np_update.clear()
                await self.fc_np_update.wait()
            elif credit_type == FcType.CPL:
                self.fc_cpl_update.clear()
                await self.fc_cpl_update.wait()
        self.tx_consume_fc(credit_type, dc)

    def rx_consume_fc(self, credit_type, dc=0):
        if credit_type == FcType.P:
            self.ph.rx_consume_fc(1)
            self.pd.rx_consume_fc(dc)
        elif credit_type == FcType.NP:
            self.nph.rx_consume_fc(1)
            self.npd.rx_consume_fc(dc)
        elif credit_type == FcType.CPL:
            self.cplh.rx_consume_fc(1)
            self.cpld.rx_consume_fc(dc)

    def rx_consume_tlp_fc(self, tlp):
        self.rx_consume_fc(tlp.get_fc_type(), tlp.get_data_credits())

    def rx_release_fc(self, credit_type, dc=0):
        if credit_type == FcType.P:
            self.next_fc_p_tx = 0
            self.ph.rx_release_fc(1)
            self.pd.rx_release_fc(dc)
        elif credit_type == FcType.NP:
            self.next_fc_np_tx = 0
            self.nph.rx_release_fc(1)
            self.npd.rx_release_fc(dc)
        elif credit_type == FcType.CPL:
            self.next_fc_cpl_tx = 0
            self.cplh.rx_release_fc(1)
            self.cpld.rx_release_fc(dc)
        self.start_fc_update_timer()

    def rx_release_tlp_fc(self, tlp):
        self.rx_release_fc(tlp.get_fc_type(), tlp.get_data_credits())

    def rx_release_fc_token(self, token):
        if token in self.rx_release_fc_dict:
            credit_type, dc = self.rx_release_fc_dict.pop(token)
            self.rx_release_fc(credit_type, dc)

    def rx_set_tlp_release_fc_cb(self, tlp):
        credit_type = tlp.get_fc_type()
        dc = tlp.get_data_credits()
        token = object()
        self.rx_release_fc_dict[token] = (credit_type, dc)
        tlp.release_fc_cb = partial(self.rx_release_fc_token, token)

    def rx_process_tlp_fc(self, tlp):
        self.rx_consume_tlp_fc(tlp)
        self.rx_set_tlp_release_fc_cb(tlp)

    def handle_fc_dllp(self, dllp):
        # Handle flow control DLLPs for this VC
        if not self.active:
            return

        if not self.fi1:
            # FC_INIT1
            if dllp.type in {DllpType.INIT_FC1_P, DllpType.INIT_FC1_NP, DllpType.INIT_FC1_CPL,
                    DllpType.INIT_FC2_P, DllpType.INIT_FC2_NP, DllpType.INIT_FC2_CPL}:
                # capture initial credit limit values from InitFC1 and InitFC2 DLLPs
                if dllp.type in {DllpType.INIT_FC1_P, DllpType.INIT_FC2_P}:
                    self.ph.tx_initial_allocation = dllp.hdr_fc
                    self.ph.tx_credit_limit = dllp.hdr_fc
                    self.pd.tx_initial_allocation = dllp.data_fc
                    self.pd.tx_credit_limit = dllp.data_fc
                    self.fi1p = True
                elif dllp.type in {DllpType.INIT_FC1_NP, DllpType.INIT_FC2_NP}:
                    self.nph.tx_initial_allocation = dllp.hdr_fc
                    self.nph.tx_credit_limit = dllp.hdr_fc
                    self.npd.tx_initial_allocation = dllp.data_fc
                    self.npd.tx_credit_limit = dllp.data_fc
                    self.fi1np = True
                elif dllp.type in {DllpType.INIT_FC1_CPL, DllpType.INIT_FC2_CPL}:
                    self.cplh.tx_initial_allocation = dllp.hdr_fc
                    self.cplh.tx_credit_limit = dllp.hdr_fc
                    self.cpld.tx_initial_allocation = dllp.data_fc
                    self.cpld.tx_credit_limit = dllp.data_fc
                    self.fi1cpl = True
                # exit FC_INIT1 once all credit types have been initialized
                self.fi1 = self.fi1p and self.fi1np and self.fi1cpl
        elif not self.fi2:
            # FC_INIT2
            if dllp.type in {DllpType.INIT_FC2_P, DllpType.INIT_FC2_NP, DllpType.INIT_FC2_CPL,
                    DllpType.UPDATE_FC_P, DllpType.UPDATE_FC_NP, DllpType.UPDATE_FC_CPL}:
                # exit FC_INIT2 on receipt of any InitFC2 or UpdateFC DLLP; ignore values
                self.fi2 = True
                self.initialized.set()
        else:
            # normal operation
            # capture new credit limits from UpdateFC DLLPs
            if dllp.type == DllpType.UPDATE_FC_P:
                if self.ph.tx_is_infinite():
                    assert dllp.hdr_fc == 0
                if self.pd.tx_is_infinite():
                    assert dllp.data_fc == 0
                self.ph.tx_credit_limit = dllp.hdr_fc
                self.pd.tx_credit_limit = dllp.data_fc
                self.fc_p_update.set()
            elif dllp.type == DllpType.UPDATE_FC_NP:
                if self.nph.tx_is_infinite():
                    assert dllp.hdr_fc == 0
                if self.npd.tx_is_infinite():
                    assert dllp.data_fc == 0
                self.nph.tx_credit_limit = dllp.hdr_fc
                self.npd.tx_credit_limit = dllp.data_fc
                self.fc_np_update.set()
            elif dllp.type == DllpType.UPDATE_FC_CPL:
                if self.cplh.tx_is_infinite():
                    assert dllp.hdr_fc == 0
                if self.cpld.tx_is_infinite():
                    assert dllp.data_fc == 0
                self.cplh.tx_credit_limit = dllp.hdr_fc
                self.cpld.tx_credit_limit = dllp.data_fc
                self.fc_cpl_update.set()


class Port:
    """Base port"""
    def __init__(self, fc_init=[[0]*6]*8, *args, **kwargs):
        self.log = logging.getLogger(f"cocotb.pcie.{type(self).__name__}.{id(self)}")
        self.log.name = f"cocotb.pcie.{type(self).__name__}"

        self.parent = None
        self.rx_handler = None

        self.max_link_speed = None
        self.max_link_width = None

        self.tx_queue = Queue(1)
        self.tx_queue_sync = Event()

        self.rx_queue = Queue()

        self.cur_link_speed = None
        self.cur_link_width = None

        self.time_scale = get_sim_steps(1, 'sec')

        # ACK/NAK protocol
        # TX
        self.next_transmit_seq = 0x000
        self.ackd_seq = 0xfff
        self.retry_buffer = Queue()

        # RX
        self.next_recv_seq = 0x000
        self.nak_scheduled = False
        self.ack_nak_latency_timer_steps = 0

        self.max_payload_size = 128
        self.max_latency_timer_steps = 0

        self.send_ack = Event()

        self._ack_latency_timer_cr = None

        # Flow control
        self.send_fc = Event()

        self.fc_state = [FcChannelState(fc_init[k], self.start_fc_update_timer) for k in range(8)]

        self.fc_initialized = False
        self.fc_init_vc = 0
        self.fc_init_type = FcType.P

        self.fc_idle_timer_steps = get_sim_steps(10, 'us')
        self.fc_update_steps = get_sim_steps(30, 'us')

        self._fc_update_timer_cr = None

        super().__init__(*args, **kwargs)

        # VC0 is always active
        self.fc_state[0].active = True

        cocotb.start_soon(self._run_transmit())
        cocotb.start_soon(self._run_receive())
        cocotb.start_soon(self._run_fc_update_idle_timer())

    def classify_tlp_vc(self, tlp):
        return 0

    async def send(self, pkt):
        pkt.release_fc()
        await self.fc_state[self.classify_tlp_vc(pkt)].tx_tlp_fc_gate(pkt)
        await self.tx_queue.put(pkt)
        self.tx_queue_sync.set()

    async def _run_transmit(self):
        await NullTrigger()
        while True:
            while self.tx_queue.empty() and not self.send_ack.is_set() and not self.send_fc.is_set() and self.fc_initialized:
                self.tx_queue_sync.clear()
                await First(self.tx_queue_sync.wait(), self.send_ack.wait(), self.send_fc.wait())

            pkt = None

            if self.send_ack.is_set():
                # Send ACK or NAK DLLP
                # Runs when
                #  - ACK timer expires
                #  - ACK/NAK transmit requested
                self.send_ack.clear()
                if self.nak_scheduled:
                    pkt = Dllp.create_nak((self.next_recv_seq-1) & 0xfff)
                else:
                    pkt = Dllp.create_ack((self.next_recv_seq-1) & 0xfff)
            elif self.send_fc.is_set() or (not self.fc_initialized and self.tx_queue.empty()):
                # Send FC DLLP
                # Runs when
                #  - FC timer expires
                #  - FC update DLLP transmit requested
                #  - FC init is not done AND no TLPs are queued for transmit
                if self.send_fc.is_set():
                    # Send FC update DLLP
                    for fc_ch in self.fc_state:
                        if not fc_ch.active or not fc_ch.fi2:
                            continue

                        sim_time = get_sim_time()
                        if fc_ch.next_fc_p_tx <= sim_time:
                            pkt = Dllp()
                            pkt.vc = self.fc_init_vc
                            pkt.type = DllpType.UPDATE_FC_P
                            pkt.hdr_fc = fc_ch.ph.rx_credits_allocated
                            pkt.data_fc = fc_ch.pd.rx_credits_allocated
                            fc_ch.next_fc_p_tx = sim_time + self.fc_update_steps
                            break
                        if fc_ch.next_fc_np_tx <= sim_time:
                            pkt = Dllp()
                            pkt.vc = self.fc_init_vc
                            pkt.type = DllpType.UPDATE_FC_NP
                            pkt.hdr_fc = fc_ch.nph.rx_credits_allocated
                            pkt.data_fc = fc_ch.npd.rx_credits_allocated
                            fc_ch.next_fc_np_tx = sim_time + self.fc_update_steps
                            break
                        if fc_ch.next_fc_cpl_tx <= sim_time:
                            pkt = Dllp()
                            pkt.vc = self.fc_init_vc
                            pkt.type = DllpType.UPDATE_FC_CPL
                            pkt.hdr_fc = fc_ch.cplh.rx_credits_allocated
                            pkt.data_fc = fc_ch.cpld.rx_credits_allocated
                            fc_ch.next_fc_cpl_tx = sim_time + self.fc_update_steps
                            break

                if not self.fc_initialized and not pkt:
                    # Send FC init DLLP
                    fc_ch = self.fc_state[self.fc_init_vc]
                    pkt = Dllp()
                    pkt.vc = self.fc_init_vc
                    if self.fc_init_type == FcType.P:
                        pkt.type = DllpType.INIT_FC1_P if not fc_ch.fi1 else DllpType.INIT_FC2_P
                        pkt.hdr_fc = fc_ch.ph.rx_credits_allocated
                        pkt.data_fc = fc_ch.pd.rx_credits_allocated
                        self.fc_init_type = FcType.NP
                    elif self.fc_init_type == FcType.NP:
                        pkt.type = DllpType.INIT_FC1_NP if not fc_ch.fi1 else DllpType.INIT_FC2_NP
                        pkt.hdr_fc = fc_ch.nph.rx_credits_allocated
                        pkt.data_fc = fc_ch.npd.rx_credits_allocated
                        self.fc_init_type = FcType.CPL
                    elif self.fc_init_type == FcType.CPL:
                        pkt.type = DllpType.INIT_FC1_CPL if not fc_ch.fi1 else DllpType.INIT_FC2_CPL
                        pkt.hdr_fc = fc_ch.cplh.rx_credits_allocated
                        pkt.data_fc = fc_ch.cpld.rx_credits_allocated
                        self.fc_init_type = FcType.P
                        # find next active VC that hasn't finished FC init
                        for k in range(8):
                            vc = (self.fc_init_vc+1+k) % 8
                            if self.fc_state[vc].active and not self.fc_state[vc].fi2:
                                self.fc_init_vc = vc
                                break

                    # check all active VC and report FC not initialized if any are not complete
                    self.fc_initialized = True
                    for vc in range(8):
                        if self.fc_state[vc].active and not self.fc_state[vc].fi2:
                            self.fc_initialized = False

                if not pkt:
                    # no more DLLPs to send, clear event
                    self.send_fc.clear()

            if pkt is not None:
                self.log.debug("Send DLLP %s", pkt)
            elif not self.tx_queue.empty():
                pkt = self.tx_queue.get_nowait()
                pkt.seq = self.next_transmit_seq
                self.log.debug("Send TLP %s", pkt)
                self.next_transmit_seq = (self.next_transmit_seq + 1) & 0xfff
                self.retry_buffer.put_nowait(pkt)

            if pkt:
                await self.handle_tx(pkt)

    async def handle_tx(self, pkt):
        raise NotImplementedError()

    async def ext_recv(self, pkt):
        if isinstance(pkt, Dllp):
            # DLLP
            self.log.debug("Receive DLLP %s", pkt)
            self.handle_dllp(pkt)
        else:
            # TLP
            self.log.debug("Receive TLP %s", pkt)
            if pkt.seq == self.next_recv_seq:
                # expected seq
                self.next_recv_seq = (self.next_recv_seq + 1) & 0xfff
                self.nak_scheduled = False
                self.start_ack_latency_timer()
                pkt = Tlp(pkt)
                self.fc_state[self.classify_tlp_vc(pkt)].rx_process_tlp_fc(pkt)
                self.rx_queue.put_nowait(pkt)
            elif (self.next_recv_seq - pkt.seq) & 0xfff < 2048:
                self.log.warning("Received duplicate TLP, discarding (seq %d, expecting %d)", pkt.seq, self.next_recv_seq)
                self.stop_ack_latency_timer()
                self.send_ack.set()
            else:
                self.log.warning("Received out-of-sequence TLP, sending NAK (seq %d, expecting %d)", pkt.seq, self.next_recv_seq)
                if not self.nak_scheduled:
                    self.nak_scheduled = True
                    self.stop_ack_latency_timer()
                    self.send_ack.set()

    async def _run_receive(self):
        while True:
            tlp = await self.rx_queue.get()
            if self.rx_handler is None:
                raise Exception("Receive handler not set")
            await self.rx_handler(tlp)

    def handle_dllp(self, dllp):
        if dllp.type == DllpType.NOP:
            # discard NOP
            pass
        elif dllp.type in {DllpType.ACK, DllpType.NAK}:
            # ACK or NAK
            if (((self.next_transmit_seq-1) & 0xfff) - dllp.seq) & 0xfff > 2048:
                self.log.warning("Received ACK/NAK DLLP for future TLP, discarding (seq %d, next TX %d, ACK %d)",
                    dllp.seq, self.next_transmit_seq, self.ackd_seq)
            elif (dllp.seq - self.ackd_seq) & 0xfff > 2048:
                self.log.warning("Received ACK/NAK DLLP for previously-ACKed TLP, discarding (seq %d, next TX %d, ACK %d)",
                    dllp.seq, self.next_transmit_seq, self.ackd_seq)
            else:
                while dllp.seq != self.ackd_seq:
                    # purge TLPs from retry buffer
                    self.retry_buffer.get_nowait()
                    self.ackd_seq = (self.ackd_seq + 1) & 0xfff
                    self.log.debug("ACK TLP seq %d", self.ackd_seq)
                if dllp.type == DllpType.NAK:
                    # retransmit
                    self.log.warning("Got NAK DLLP, start TLP replay")
                    raise Exception("TODO")
        elif dllp.type in {DllpType.INIT_FC1_P, DllpType.INIT_FC1_NP, DllpType.INIT_FC1_CPL,
                DllpType.INIT_FC2_P, DllpType.INIT_FC2_NP, DllpType.INIT_FC2_CPL,
                DllpType.UPDATE_FC_P, DllpType.UPDATE_FC_NP, DllpType.UPDATE_FC_CPL}:
            # Flow control
            self.fc_state[dllp.vc].handle_fc_dllp(dllp)
        else:
            raise Exception("TODO")

    def start_ack_latency_timer(self):
        if self._ack_latency_timer_cr is not None:
            if not self._ack_latency_timer_cr.done():
                # already running
                return
        self._ack_latency_timer_cr = cocotb.start_soon(self._run_ack_latency_timer())

    def stop_ack_latency_timer(self):
        if self._ack_latency_timer_cr is not None:
            self._ack_latency_timer_cr.kill()
            self._ack_latency_timer_cr = None

    async def _run_ack_latency_timer(self):
        await Timer(max(self.max_latency_timer_steps, 1), 'step')
        if not self.nak_scheduled:
            self.send_ack.set()

    def start_fc_update_timer(self):
        if self._fc_update_timer_cr is not None:
            if not self._fc_update_timer_cr.done():
                # already running
                return
        self._fc_update_timer_cr = cocotb.start_soon(self._run_fc_update_timer())

    def stop_fc_update_timer(self):
        if self._fc_update_timer_cr is not None:
            self._fc_update_timer_cr.kill()
            self._fc_update_timer_cr = None

    async def _run_fc_update_timer(self):
        await Timer(max(self.max_latency_timer_steps, 1), 'step')
        self.send_fc.set()

    async def _run_fc_update_idle_timer(self):
        while True:
            await Timer(max(self.fc_idle_timer_steps, 1), 'step')
            self.send_fc.set()


class SimPort(Port):
    """Port to interconnect simulated PCIe devices"""
    def __init__(self, fc_init=[[0]*6]*8, *args, **kwargs):
        super().__init__(*args, fc_init, **kwargs)

        self.other = None

        self.port_delay = 5e-9

        self.symbol_period = 0
        self.link_delay_steps = 0

    def connect(self, other):
        if isinstance(other, SimPort):
            self._connect(other)
        else:
            other.connect(self)

    def _connect(self, port):
        if self.other is not None:
            raise Exception("Already connected")
        port._connect_int(self)
        self._connect_int(port)

    def _connect_int(self, port):
        if self.other is not None:
            raise Exception("Already connected")

        self.other = port

        if self.max_link_speed:
            if port.max_link_speed:
                self.cur_link_speed = min(self.max_link_speed, port.max_link_speed)
            else:
                self.cur_link_speed = self.max_link_speed
        else:
            self.cur_link_speed = port.max_link_speed

        if self.max_link_width:
            if port.max_link_width:
                self.cur_link_width = min(self.max_link_width, port.max_link_width)
            else:
                self.cur_link_width = self.max_link_width
        else:
            self.cur_link_width = port.max_link_width

        if self.cur_link_width is not None and self.cur_link_speed is not None:
            self.symbol_period = 8 / (PCIE_GEN_RATE[self.cur_link_speed] * self.cur_link_width)
            self.max_latency_timer_steps = int(get_max_update_latency(self.max_payload_size, self.cur_link_width, self.cur_link_speed) * 8 / PCIE_GEN_RATE[self.cur_link_speed] * self.time_scale)
            self.link_delay_steps = int((self.port_delay + port.port_delay) * self.time_scale)
        else:
            self.symbol_period = 0
            self.max_latency_timer_steps = 0
            self.link_delay_steps = 0

    async def handle_tx(self, pkt):
        await Timer(max(int(pkt.get_wire_size() * self.symbol_period * self.time_scale), 1), 'step')
        cocotb.start_soon(self._transmit(pkt))

    async def _transmit(self, pkt):
        if self.other is None:
            raise Exception("Port not connected")
        await Timer(max(self.link_delay_steps, 1), 'step')
        await self.other.ext_recv(pkt)



================================================
FILE: cocotbext/pcie/core/rc.py
================================================
"""

Copyright (c) 2020 Alex Forencich

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

"""

import logging

from cocotb.queue import Queue
from cocotb.triggers import Event, Timer, First

from cocotbext.axi import AddressSpace

from .version import __version__
from .bridge import HostBridge, RootPort
from .msi import MsiRegion
from .region import MemoryTlpRegion, IoTlpRegion
from .switch import Switch
from .tlp import Tlp, TlpType, TlpAttr, TlpTc, CplStatus
from .utils import PcieId
from .pci import PciDevice, PciHostBridge


class RootComplex(Switch):
    def __init__(self, mem_address_space=None, io_address_space=None, *args, **kwargs):

        self.default_upstream_bridge = HostBridge
        self.default_downstream_bridge = RootPort

        super().__init__(*args, **kwargs)

        self.log = logging.getLogger(f"cocotb.pcie.{type(self).__name__}.{id(self)}")
        self.log.name = f"cocotb.pcie.{type(self).__name__}"

        self.log.info("PCIe root complex model")
        self.log.info("cocotbext-pcie version %s", __version__)
        self.log.info("Copyright (c) 2020 Alex Forencich")
        self.log.info("https://github.com/alexforencich/cocotbext-pcie")

        self.min_dev = 1

        self.current_tag = 0
        self.tag_count = 32
        self.tag_active = [False]*256
        self.tag_release = Event()

        self.downstream_tag_recv_queues = {}

        self.rx_cpl_queues = [Queue() for k in range(256)]
        self.rx_cpl_sync = [Event() for k in range(256)]

        self.rx_tlp_handler = {}

        self.upstream_bridge.upstream_tx_handler = self.downstream_recv

        self.host_bridge = PciHostBridge(rc=self)

        self.io_base = 0x8000_0000
        self.io_limit = self.io_base
        self.mem_base = 0xc000_0000
        self.mem_limit = self.mem_base
        self.prefetchable_mem_base = 0x8000_0000_0000_0000
        self.prefetchable_mem_limit = self.prefetchable_mem_base

        self.upstream_bridge.io_base = self.io_base
        self.upstream_bridge.io_limit = self.io_limit
        self.upstream_bridge.mem_base = self.mem_base
        self.upstream_bridge.mem_limit = self.mem_limit
        self.upstream_bridge.prefetchable_mem_base = self.prefetchable_mem_base
        self.upstream_bridge.prefetchable_mem_limit = self.prefetchable_mem_limit

        self._max_payload_size = 0
        self._max_payload_size_supported = 5
        self._max_read_request_size = 2
        self._read_completion_boundary = False
        self.bus_master_enable = True

        self.split_on_all_rcb = False

        self.mem_address_space = mem_address_space or AddressSpace(2**64)
        self.io_address_space = io_address_space or AddressSpace(2**32)

        self.mem_region = MemoryTlpRegion(self)
        self.io_region = IoTlpRegion(self)

        self.mem_address_space.register_region(self.mem_region,
                self.mem_base, self.mem_base & -self.mem_base, offset=None)
        self.mem_address_space.register_region(self.mem_region,
                self.prefetchable_mem_base, self.prefetchable_mem_base & -self.prefetchable_mem_base, offset=None)
        self.io_address_space.register_region(self.io_region,
                self.io_base, self.io_base & -self.io_base, offset=None)

        self.mem_pool = self.mem_address_space.create_pool(0x0000_0000, 0x8000_0000)
        self.io_pool = self.io_address_space.create_pool(0x0000_0000, 0x8000_0000)

        self.region_base = 0
        self.region_limit = self.region_base

        self.io_region_base = 0
        self.io_region_limit = self.io_region_base

        self.regions = []
        self.io_regions = []

        self.msi_region = MsiRegion(self)

        self.mem_address_space.register_region(self.msi_region, 0x8000_0000)

        self.msi_addr = None
        self.msi_msg_limit = 0
        self.msi_events = {}
        self.msi_callbacks = {}

        self.register_rx_tlp_handler(TlpType.IO_READ, self.handle_io_read_tlp)
        self.register_rx_tlp_handler(TlpType.IO_WRITE, self.handle_io_write_tlp)
        self.register_rx_tlp_handler(TlpType.MEM_READ, self.handle_mem_read_tlp)
        self.register_rx_tlp_handler(TlpType.MEM_READ_64, self.handle_mem_read_tlp)
        self.register_rx_tlp_handler(TlpType.MEM_WRITE, self.handle_mem_write_tlp)
        self.register_rx_tlp_handler(TlpType.MEM_WRITE_64, self.handle_mem_write_tlp)

    @property
    def max_payload_size(self):
        return self._max_payload_size

    @max_payload_size.setter
    def max_payload_size(self, val):
        self._max_payload_size = val
        self.upstream_bridge.pcie_cap.max_payload_size = val

    @property
    def max_payload_size_supported(self):
        return self._max_payload_size_supported

    @max_payload_size_supported.setter
    def max_payload_size_supported(self, val):
        self._max_payload_size_supported = val
        self.upstream_bridge.pcie_cap.max_payload_size_supported = val

    @property
    def max_read_request_size(self):
        return self._max_read_request_size

    @max_read_request_size.setter
    def max_read_request_size(self, val):
        self._max_read_request_size = val
        self.upstream_bridge.pcie_cap.max_read_request_size = val

    @property
    def read_completion_boundary(self):
        return self._read_completion_boundary

    @read_completion_boundary.setter
    def read_completion_boundary(self, val):
        self._read_completion_boundary = val
        self.upstream_bridge.pcie_cap.read_completion_boundary = val

    def alloc_region(self, size):
        region = self.mem_pool.alloc_region(size)
        return region.get_absolute_address(0), region.mem

    def alloc_io_region(self, size):
        region = self.io_pool.alloc_region(size)
        return region.get_absolute_address(0), region.mem

    async def read_region(self, addr, length):
        return await self.mem_region.read(addr, length)

    async def write_region(self, addr, data):
        await self.mem_region.write(addr, data)

    async def read_io_region(self, addr, length):
        return await self.io_region.read(addr, length)

    async def write_io_region(self, addr, data):
        await self.io_region.write(addr, data)

    async def downstream_send(self, tlp):
        self.log.debug("Sending TLP: %r", tlp)
        assert tlp.check()
        await self.upstream_bridge.upstream_recv(tlp)

    async def send(self, tlp):
        await self.downstream_send(tlp)

    async def downstream_recv(self, tlp):
        self.log.debug("Got TLP: %r", tlp)
        assert tlp.check()
        await self.handle_tlp(tlp)

    async def handle_tlp(self, tlp):
        if tlp.fmt_type in {TlpType.CPL, TlpType.CPL_DATA, TlpType.CPL_LOCKED, TlpType.CPL_LOCKED_DATA}:
            self.rx_cpl_queues[tlp.tag].put_nowait(tlp)
            self.rx_cpl_sync[tlp.tag].set()
        elif tlp.fmt_type in self.rx_tlp_handler:
            tlp.release_fc()
            await self.rx_tlp_handler[tlp.fmt_type](tlp)
        else:
            tlp.release_fc()
            raise Exception("Unhandled TLP")

    def register_rx_tlp_handler(self, fmt_type, func):
        self.rx_tlp_handler[fmt_type] = func

    async def recv_cpl(self, tag, timeout=0, timeout_unit='ns'):
        queue = self.rx_cpl_queues[tag]
        sync = self.rx_cpl_sync[tag]

        if not queue.empty():
            cpl = queue.get_nowait()
            cpl.release_fc()
            return cpl

        sync.clear()
        if timeout:
            await First(sync.wait(), Timer(timeout, timeout_unit))
        else:
            await sync.wait()

        if not queue.empty():
            cpl = queue.get_nowait()
            cpl.release_fc()
            return cpl

        return None

    async def alloc_tag(self):
        tag_count = min(256, self.tag_count)

        while True:
            tag = self.current_tag
            for k in range(tag_count):
                tag = (tag + 1) % tag_count
                if not self.tag_active[tag]:
                    self.tag_active[tag] = True
                    self.current_tag = tag
                    return tag

            self.tag_release.clear()
            await self.tag_release.wait()

    def release_tag(self, tag):
        assert self.tag_active[tag]
        self.tag_active[tag] = False
        self.tag_release.set()

    async def perform_posted_operation(self, req):
        await self.send(req)

    async def perform_nonposted_operation(self, req, timeout=0, timeout_unit='ns'):
        completions = []

        req.tag = await self.alloc_tag()

        await self.send(req)

        while True:
            cpl = await self.recv_cpl(req.tag, timeout, timeout_unit)

            if not cpl:
                break

            completions.append(cpl)

            if cpl.status != CplStatus.SC:
                # bad status
                break
            elif req.fmt_type in {TlpType.MEM_READ, TlpType.MEM_READ_64}:
                # completion for memory read request

                # request completed
                if cpl.byte_count <= cpl.length*4 - (cpl.lower_address & 0x3):
                    break

                # completion for read request has SC status but no data
                if cpl.fmt_type in {TlpType.CPL, TlpType.CPL_LOCKED}:
                    break

            else:
                # completion for other request
                break

        self.release_tag(req.tag)

        return completions

    async def handle_io_read_tlp(self, tlp):
        self.log.info("IO read, address 0x%08x, BE 0x%x, tag %d",
                tlp.address, tlp.first_be, tlp.tag)

        if not self.io_address_space.find_regions(tlp.address, tlp.length*4):
            self.log.warning("IO request did not match any regions: %r", tlp)

            # Unsupported request
            cpl = Tlp.create_ur_completion_for_tlp(tlp, PcieId(0, 0, 0))
            self.log.debug("UR Completion: %r", cpl)
            await self.send(cpl)
            return

        assert tlp.length == 1

        # prepare completion TLP
        cpl = Tlp.create_completion_data_for_tlp(tlp, PcieId(0, 0, 0))

        addr = tlp.address
        offset = 0
        start_offset = None
        mask = tlp.first_be

        # generate operation list
        read_ops = []

        data = bytearray(4)

        for k in range(4):
            if mask & (1 << k):
                if start_offset is None:
                    start_offset = offset
            else:
                if start_offset is not None and offset != start_offset:
                    read_ops.append((start_offset, addr+start_offset, offset-start_offset))
                start_offset = None

            offset += 1

        if start_offset is not None and offset != start_offset:
            read_ops.append((start_offset, addr+start_offset, offset-start_offset))

        # perform reads
        try:
            for offset, addr, length in read_ops:
                data[offset:offset+length] = await self.io_address_space.read(addr, length)
        except Exception:
            self.log.warning("IO read operation failed: %r", tlp)

            # Completer abort
            cpl = Tlp.create_ca_completion_for_tlp(tlp, PcieId(0, 0, 0))
            self.log.debug("CA Completion: %r", cpl)
            await self.send(cpl)
            return

        cpl.set_data(data)
        cpl.byte_count = 4
        cpl.length = 1

        self.log.debug("Completion: %r", cpl)
        await self.send(cpl)

    async def handle_io_write_tlp(self, tlp):
        self.log.info("IO write, address 0x%08x, BE 0x%x, tag %d, data 0x%08x",
                tlp.address, tlp.first_be, tlp.tag, int.from_bytes(tlp.get_data(), 'little'))

        if not self.io_address_space.find_regions(tlp.address, tlp.length*4):
            self.log.warning("IO request did not match any regions: %r", tlp)

            # Unsupported request
            cpl = Tlp.create_ur_completion_for_tlp(tlp, PcieId(0, 0, 0))
            self.log.debug("UR Completion: %r", cpl)
            await self.send(cpl)
            return

        assert tlp.length == 1

        # prepare completion TLP
        cpl = Tlp.create_completion_for_tlp(tlp, PcieId(0, 0, 0))

        addr = tlp.address
        offset = 0
        start_offset = None
        mask = tlp.first_be

        # generate operation list
        write_ops = []

        data = tlp.get_data()

        for k in range(4):
            if mask & (1 << k):
                if start_offset is None:
                    start_offset = offset
            else:
                if start_offset is not None and offset != start_offset:
                    write_ops.append((addr+start_offset, data[start_offset:offset]))
                start_offset = None

            offset += 1

        if start_offset is not None and offset != start_offset:
            write_ops.append((addr+start_offset, data[start_offset:offset]))

        # perform writes
        try:
            for addr, data in write_ops:
                await self.io_address_space.write(addr, data)
        except Exception:
            self.log.warning("IO write operation failed: %r", tlp)

            # Completer abort
            cpl = Tlp.create_ca_completion_for_tlp(tlp, PcieId(0, 0, 0))
            self.log.debug("CA Completion: %r", cpl)
            await self.send(cpl)
            return

        cpl.byte_count = 4

        self.log.debug("Completion: %r", cpl)
        await self.send(cpl)

    async def handle_mem_read_tlp(self, tlp):
        self.log.info("Memory read, address 0x%08x, length %d, BE 0x%x/0x%x, tag %d",
                tlp.address, tlp.length, tlp.first_be, tlp.last_be, tlp.tag)

        if not self.mem_address_space.find_regions(tlp.address, tlp.length*4):
            self.log.warning("Memory request did not match any regions: %r", tlp)

            # Unsupported request
            cpl = Tlp.create_ur_completion_for_tlp(tlp, PcieId(0, 0, 0))
            self.log.debug("UR Completion: %r", cpl)
            await self.send(cpl)
            return

        # perform operation
        addr = tlp.address

        # check for 4k boundary crossing
        if tlp.length*4 > 0x1000 - (addr & 0xfff):
            self.log.warning("Request crossed 4k boundary, discarding request")
            return

        # perform read
        try:
            data = await self.mem_address_space.read(addr, tlp.length*4)
        except Exception:
            self.log.warning("Memory read operation failed: %r", tlp)

            # Completer abort
            cpl = Tlp.create_ca_completion_for_tlp(tlp, PcieId(0, 0, 0))
            self.log.debug("CA Completion: %r", cpl)
            await self.send(cpl)
            return

        # prepare completion TLP(s)
        m = 0
        n = 0
        addr = tlp.address+tlp.get_first_be_offset()
        dw_length = tlp.length
        byte_length = tlp.get_be_byte_count()
        max_payload_dw = 32 << self.max_payload_size
        rcb = 64
        if self.read_completion_boundary:
            rcb = 128
        rcb_mask = (rcb-1) & 0xfc

        while m < dw_length:
            cpl = Tlp.create_completion_data_for_tlp(tlp, PcieId(0, 0, 0))

            cpl_dw_length = dw_length - m
            cpl.byte_count = byte_length - n
            if self.split_on_all_rcb:
                # split on every RCB
                cpl_dw_length = min(cpl_dw_length, (rcb - (addr & rcb_mask)) >> 2);
            else:
                # produce largest possible TLPs
                if cpl_dw_length > max_payload_dw:
                    cpl_dw_length = max_payload_dw - ((addr & rcb_mask) >> 2)

            cpl.lower_address = addr & 0x7f

            cpl.set_data(data[m*4:(m+cpl_dw_length)*4])

            self.log.debug("Completion: %r", cpl)
            await self.send(cpl)

            m += cpl_dw_length
            n += cpl_dw_length*4 - (addr & 3)
            addr += cpl_dw_length*4 - (addr & 3)

    async def handle_mem_write_tlp(self, tlp):
        self.log.info("Memory write, address 0x%08x, length %d, BE 0x%x/0x%x",
                tlp.address, tlp.length, tlp.first_be, tlp.last_be)

        if not self.mem_address_space.find_regions(tlp.address, tlp.length*4):
            self.log.warning("Memory request did not match any regions: %r", tlp)
            return

        # perform operation
        addr = tlp.address
        offset = 0
        start_offset = None
        mask = tlp.first_be

        # check for 4k boundary crossing
        if tlp.length*4 > 0x1000 - (addr & 0xfff):
            self.log.warning("Request crossed 4k boundary, discarding request")
            return

        # generate operation list
        write_ops = []

        data = tlp.get_data()

        # first dword
        for k in range(4):
            if mask & (1 << k):
                if start_offset is None:
                    start_offset = offset
            else:
                if start_offset is not None and offset != start_offset:
                    write_ops.append((addr+start_offset, data[start_offset:offset]))
                start_offset = None

            offset += 1

        if tlp.length > 2:
            # middle dwords
            if start_offset is None:
                start_offset = offset
            offset += (tlp.length-2)*4

        if tlp.length > 1:
            # last dword
            mask = tlp.last_be

            for k in range(4):
                if mask & (1 << k):
                    if start_offset is None:
                        start_offset = offset
                else:
                    if start_offset is not None and offset != start_offset:
                        write_ops.append((addr+start_offset, data[start_offset:offset]))
                    start_offset = None

                offset += 1

        if start_offset is not None and offset != start_offset:
            write_ops.append((addr+start_offset, data[start_offset:offset]))

        # perform writes
        try:
            for addr, data in write_ops:
                await self.mem_address_space.write(addr, data)
        except Exception:
            self.log.warning("Memory write operation failed: %r", tlp)
            return

        # memory writes are posted, so don't send a completion

    async def config_read(self, dev, addr, length, timeout=0, timeout_unit='ns'):
        n = 0
        data = bytearray()

        while n < length:
            req = Tlp()
            req.fmt_type = TlpType.CFG_READ_1
            req.requester_id = PcieId(0, 0, 0)
            req.completer_id = dev

            first_pad = addr % 4
            byte_length = min(length-n, 4-first_pad)
            req.set_addr_be(addr, byte_length)

            cpl_list = await self.perform_nonposted_operation(req, timeout, timeout_unit)

            if not cpl_list:
                # timed out
                d = b'\xff\xff\xff\xff'
            elif cpl_list[0].status == CplStatus.CRS and req.address == 0 and cpl_list[0].ingress_port:
                # completion retry status
                if cpl_list[0].ingress_port.pcie_cap.crs_software_visibility_enable:
                    d = b'\x01\x00\xff\xff'
                else:
                    d = b'\xff\xff\xff\xff'
            elif cpl_list[0].status != CplStatus.SC:
                # unsupported request or completer abort status
                d = b'\xff\xff\xff\xff'
            else:
                # success
                assert cpl_list[0].length == 1
                d = cpl_list[0].get_data()

            data.extend(d[first_pad:])

            n += byte_length
            addr += byte_length

        return data[:length]

    async def config_read_words(self, dev, addr, count, byteorder='little', ws=2, timeout=0, timeout_unit='ns'):
        data = await self.config_read(dev, addr, count*ws, timeout, timeout_unit)
        words = []
        for k in range(count):
            words.append(int.from_bytes(data[ws*k:ws*(k+1)], byteorder))
        return words

    async def config_read_dwords(self, dev, addr, count, byteorder='little', timeout=0, timeout_unit='ns'):
        return await self.config_read_words(dev, addr, count, byteorder, 4, timeout, timeout_unit)

    async def config_read_qwords(self, dev, addr, count, byteorder='little', timeout=0, timeout_unit='ns'):
        return await self.config_read_words(dev, addr, count, byteorder, 8, timeout, timeout_unit)

    async def config_read_byte(self, dev, addr, timeout=0, timeout_unit='ns'):
        return (await self.config_read(dev, addr, 1, timeout, timeout_unit))[0]

    async def config_read_word(self, dev, addr, byteorder='little', ws=2, timeout=0, timeout_unit='ns'):
        return (await self.config_read_words(dev, addr, 1, byteorder, ws, timeout, timeout_unit))[0]

    async def config_read_dword(self, dev, addr, byteorder='little', timeout=0, timeout_unit='ns'):
        return (await self.config_read_dwords(dev, addr, 1, byteorder, timeout, timeout_unit))[0]

    async def config_read_qword(self, dev, addr, byteorder='little', timeout=0, timeout_unit='ns'):
        return (await self.config_read_qwords(dev, addr, 1, byteorder, timeout, timeout_unit))[0]

    async def config_write(self, dev, addr, data, timeout=0, timeout_unit='ns'):
        n = 0

        while n < len(data):
            req = Tlp()
            req.fmt_type = TlpType.CFG_WRITE_1
            req.requester_id = PcieId(0, 0, 0)
            req.completer_id = dev

            first_pad = addr % 4
            byte_length = min(len(data)-n, 4-first_pad)
            req.set_addr_be_data(addr, data[n:n+byte_length])

            cpl_list = await self.perform_nonposted_operation(req, timeout, timeout_unit)

            n += byte_length
            addr += byte_length

    async def config_write_words(self, dev, addr, data, byteorder='little', ws=2, timeout=0, timeout_unit='ns'):
        words = data
        data = bytearray()
        for w in words:
            data.extend(w.to_bytes(ws, byteorder))
        await self.config_write(dev, addr, data, timeout, timeout_unit)

    async def config_write_dwords(self, dev, addr, data, byteorder='little', timeout=0, timeout_unit='ns'):
        await self.config_write_words(dev, addr, data, byteorder, 4, timeout, timeout_unit)

    async def config_write_qwords(self, dev, addr, data, byteorder='little', timeout=0, timeout_unit='ns'):
        await self.config_write_words(dev, addr, data, byteorder, 8, timeout, timeout_unit)

    async def config_write_byte(self, dev, addr, data, timeout=0, timeout_unit='ns'):
        await self.config_write(dev, addr, [data], timeout, timeout_unit)

    async def config_write_word(self, dev, addr, data, byteorder='little', ws=2, timeout=0, timeout_unit='ns'):
        await self.config_write_words(dev, addr, [data], byteorder, ws, timeout, timeout_unit)

    async def config_write_dword(self, dev, addr, data, byteorder='little', timeout=0, timeout_unit='ns'):
        await self.config_write_dwords(dev, addr, [data], byteorder, timeout, timeout_unit)

    async def config_write_qword(self, dev, addr, data, byteorder='little', timeout=0, timeout_unit='ns'):
        await self.config_write_qwords(dev, addr, [data], byteorder, timeout, timeout_unit)

    async def capability_read(self, dev, cap_id, addr, length, timeout=0, timeout_unit='ns'):
        ti = self.host_bridge.find_child_dev(dev)

        if not ti:
            raise Exception("Device not found")

        offset = ti.get_capability_offset(cap_id)

        if not offset:
            raise Exception("Capability not found")

        return await self.config_read(dev, addr+offset, length, timeout, timeout_unit)

    async def capability_read_words(self, dev, cap_id, addr, count, byteorder='little', ws=2, timeout=0, timeout_unit='ns'):
        data = await self.capability_read(dev, cap_id, addr, count*ws, timeout, timeout_unit)
        words = []
        for k in range(count):
            words.append(int.from_bytes(data[ws*k:ws*(k+1)], byteorder))
        return words

    async def capability_read_dwords(self, dev, cap_id, addr, count, byteorder='little', timeout=0, timeout_unit='ns'):
        return await self.capability_read_words(dev, cap_id, addr, count, byteorder, 4, timeout, timeout_unit)

    async def capability_read_qwords(self, dev, cap_id, addr, count, byteorder='little', timeout=0, timeout_unit='ns'):
        return await self.capability_read_words(dev, cap_id, addr, count, byteorder, 8, timeout, timeout_unit)

    async def capability_read_byte(self, dev, cap_id, addr, timeout=0, timeout_unit='ns'):
        return (await self.capability_read(dev, cap_id, addr, 1, timeout, timeout_unit))[0]

    async def capability_read_word(self, dev, cap_id, addr, byteorder='little', ws=2, timeout=0, timeout_unit='ns'):
        return (await self.capability_read_words(dev, cap_id, addr, 1, byteorder, ws, timeout, timeout_unit))[0]

    async def capability_read_dword(self, dev, cap_id, addr, byteorder='little', timeout=0, timeout_unit='ns'):
        return (await self.capability_read_dwords(dev, cap_id, addr, 1, byteorder, timeout, timeout_unit))[0]

    async def capability_read_qword(self, dev, cap_id, addr, byteorder='little', timeout=0, timeout_unit='ns'):
        return (await self.capability_read_qwords(dev, cap_id, addr, 1, byteorder, timeout, timeout_unit))[0]

    async def capability_write(self, dev, cap_id, addr, data, timeout=0, timeout_unit='ns'):
        ti = self.host_bridge.find_child_dev(dev)

        if not ti:
            raise Exception("Device not found")

        offset = ti.get_capability_offset(cap_id)

        if not offset:
            raise Exception("Capability not found")

        await self.config_write(dev, addr+offset, data, timeout, timeout_unit)

    async def capability_write_words(self, dev, cap_id, addr, data, byteorder='little', ws=2, timeout=0, timeout_unit='ns'):
        words = data
        data = bytearray()
        for w in words:
            data.extend(w.to_bytes(ws, byteorder))
        await self.capability_write(dev, cap_id, addr, data, timeout, timeout_unit)

    async def capability_write_dwords(self, dev, cap_id, addr, data, byteorder='little', timeout=0, timeout_unit='ns'):
        await self.capability_write_words(dev, cap_id, addr, data, byteorder, 4, timeout, timeout_unit)

    async def capability_write_qwords(self, dev, cap_id, addr, data, byteorder='little', timeout=0, timeout_unit='ns'):
        await self.capability_write_words(dev, cap_id, addr, data, byteorder, 8, timeout, timeout_unit)

    async def capability_write_byte(self, dev, cap_id, addr, data, timeout=0, timeout_unit='ns'):
        await self.capability_write(dev, cap_id, addr, [data], timeout, timeout_unit)

    async def capability_write_word(self, dev, cap_id, addr, data, byteorder='little', ws=2, timeout=0, timeout_unit='ns'):
        await self.capability_write_words(dev, cap_id, addr, [data], byteorder, ws, timeout, timeout_unit)

    async def capability_write_dword(self, dev, cap_id, addr, data, byteorder='little', timeout=0, timeout_unit='ns'):
        await self.capability_write_dwords(dev, cap_id, addr, [data], byteorder, timeout, timeout_unit)

    async def capability_write_qword(self, dev, cap_id, addr, data, byteorder='little', timeout=0, timeout_unit='ns'):
        await self.capability_write_qwords(dev, cap_id, addr, [data], byteorder, timeout, timeout_unit)

    async def io_read(self, addr, length, timeout=0, timeout_unit='ns'):
        return await self.io_address_space.read(addr, length, timeout=timeout, timeout_unit=timeout_unit)

    async def io_read_words(self, addr, count, byteorder='little', ws=2, timeout=0, timeout_unit='ns'):
        data = await self.io_read(addr, count*ws, timeout, timeout_unit)
        words = []
        for k in range(count):
            words.append(int.from_bytes(data[ws*k:ws*(k+1)], byteorder))
        return words

    async def io_read_dwords(self, addr, count, byteorder='little', timeout=0, timeout_unit='ns'):
        return await self.io_read_words(addr, count, byteorder, 4, timeout, timeout_unit)

    async def io_read_qwords(self, addr, count, byteorder='little', timeout=0, timeout_unit='ns'):
        return await self.io_read_words(addr, count, byteorder, 8, timeout, timeout_unit)

    async def io_read_byte(self, addr, timeout=0, timeout_unit='ns'):
        return (await self.io_read(addr, 1, timeout, timeout_unit))[0]

    async def io_read_word(self, addr, byteorder='little', ws=2, timeout=0, timeout_unit='ns'):
        return (await self.io_read_words(addr, 1, byteorder, ws, timeout, timeout_unit))[0]

    async def io_read_dword(self, addr, byteorder='little', timeout=0, timeout_unit='ns'):
        return (await self.io_read_dwords(addr, 1, byteorder, timeout, timeout_unit))[0]

    async def io_read_qword(self, addr, byteorder='little', timeout=0, timeout_unit='ns'):
        return (await self.io_read_qwords(addr, 1, byteorder, timeout, timeout_unit))[0]

    async def io_write(self, addr, data, timeout=0, timeout_unit='ns'):
        await self.io_address_space.write(addr, data, timeout=timeout, timeout_unit=timeout_unit)

    async def io_write_words(self, addr, data, byteorder='little', ws=2, timeout=0, timeout_unit='ns'):
        words = data
        data = bytearray()
        for w in words:
            data.extend(w.to_bytes(ws, byteorder))
        await self.io_write(addr, data, timeout, timeout_unit)

    async def io_write_dwords(self, addr, data, byteorder='little', timeout=0, timeout_unit='ns'):
        await self.io_write_words(addr, data, byteorder, 4, timeout, timeout_unit)

    async def io_write_qwords(self, addr, data, byteorder='little', timeout=0, timeout_unit='ns'):
        await self.io_write_words(addr, data, byteorder, 8, timeout, timeout_unit)

    async def io_write_byte(self, addr, data, timeout=0, timeout_unit='ns'):
        await self.io_write(addr, [data], timeout, timeout_unit)

    async def io_write_word(self, addr, data, byteorder='little', ws=2, timeout=0, timeout_unit='ns'):
        await self.io_write_words(addr, [data], byteorder, ws, timeout, timeout_unit)

    async def io_write_dword(self, addr, data, byteorder='little', timeout=0, timeout_unit='ns'):
        await self.io_write_dwords(addr, [data], byteorder, timeout, timeout_unit)

    async def io_write_qword(self, addr, data, byteorder='little', timeout=0, timeout_unit='ns'):
        await self.io_write_qwords(addr, [data], byteorder, timeout, timeout_unit)

    async def mem_read(self, addr, length, timeout=0, timeout_unit='ns', attr=TlpAttr(0), tc=TlpTc.TC0):
        return await self.mem_address_space.read(addr, length, timeout=timeout, timeout_unit=timeout_unit, attr=attr, tc=tc)

    async def mem_read_words(self, addr, count, byteorder='little', ws=2, timeout=0, timeout_unit='ns', attr=TlpAttr(0), tc=TlpTc.TC0):
        data = await self.mem_read(addr, count*ws, timeout, timeout_unit, attr, tc)
        words = []
        for k in range(count):
            words.append(int.from_bytes(data[ws*k:ws*(k+1)], byteorder))
        return words

    async def mem_read_dwords(self, addr, count, byteorder='little', timeout=0, timeout_unit='ns', attr=TlpAttr(0), tc=TlpTc.TC0):
        return await self.mem_read_words(addr, count, byteorder, 4, timeout, timeout_unit, attr, tc)

    async def mem_read_qwords(self, addr, count, byteorder='little', timeout=0, timeout_unit='ns', attr=TlpAttr(0), tc=TlpTc.TC0):
        return await self.mem_read_words(addr, count, byteorder, 8, timeout, timeout_unit, attr, tc)

    async def mem_read_byte(self, addr, timeout=0, timeout_unit='ns', attr=TlpAttr(0), tc=TlpTc.TC0):
        return (await self.mem_read(addr, 1, timeout, timeout_unit, attr, tc))[0]

    async def mem_read_word(self, addr, byteorder='little', ws=2, timeout=0, timeout_unit='ns', attr=TlpAttr(0), tc=TlpTc.TC0):
        return (await self.mem_read_words(addr, 1, byteorder, ws, timeout, timeout_unit, attr, tc))[0]

    async def mem_read_dword(self, addr, byteorder='little', timeout=0, timeout_unit='ns', attr=TlpAttr(0), tc=TlpTc.TC0):
        return (await self.mem_read_dwords(addr, 1, byteorder, timeout, timeout_unit, attr, tc))[0]

    async def mem_read_qword(self, addr, byteorder='little', timeout=0, timeout_unit='ns', attr=TlpAttr(0), tc=TlpTc.TC0):
        return (await self.mem_read_qwords(addr, 1, byteorder, timeout, timeout_unit, attr, tc))[0]

    async def mem_write(self, addr, data, timeout=0, timeout_unit='ns', attr=TlpAttr(0), tc=TlpTc.TC0):
        await self.mem_address_space.write(addr, data, timeout=timeout, timeout_unit=timeout_unit, attr=attr, tc=tc)

    async def mem_write_words(self, addr, data, byteorder='little', ws=2, timeout=0, timeout_unit='ns', attr=TlpAttr(0), tc=TlpTc.TC0):
        words = data
        data = bytearray()
        for w in words:
            data.extend(w.to_bytes(ws, byteorder))
        await self.mem_write(addr, data, timeout, timeout_unit, attr, tc)

    async def mem_write_dwords(self, addr, data, byteorder='little', timeout=0, timeout_unit='ns', attr=TlpAttr(0), tc=TlpTc.TC0):
        await self.mem_write_words(addr, data, byteorder, 4, timeout, timeout_unit, attr, tc)

    async def mem_write_qwords(self, addr, data, byteorder='little', timeout=0, timeout_unit='ns', attr=TlpAttr(0), tc=TlpTc.TC0):
        await self.mem_write_words(addr, data, byteorder, 8, timeout, timeout_unit, attr, tc)

    async def mem_write_byte(self, addr, data, timeout=0, timeout_unit='ns', attr=TlpAttr(0), tc=TlpTc.TC0):
        await self.mem_write(addr, [data], timeout, timeout_unit, attr, tc)

    async def mem_write_word(self, addr, data, byteorder='little', ws=2, timeout=0, timeout_unit='ns', attr=TlpAttr(0), tc=TlpTc.TC0):
        await self.mem_write_words(addr, [data], byteorder, ws, timeout, timeout_unit, attr, tc)

    async def mem_write_dword(self, addr, data, byteorder='little', timeout=0, timeout_unit='ns', attr=TlpAttr(0), tc=TlpTc.TC0):
        await self.mem_write_dwords(addr, [data], byteorder, timeout, timeout_unit, attr, tc)

    async def mem_write_qword(self, addr, data, byteorder='little', timeout=0, timeout_unit='ns', attr=TlpAttr(0), tc=TlpTc.TC0):
        await self.mem_write_qwords(addr, [data], byteorder, timeout, timeout_unit, attr, tc)

    def msi_alloc_vectors(self, num):
        return self.msi_region.alloc_vectors(num)

    def find_device(self, pcie_id):
        return self.host_bridge.find_device(pcie_id)

    async def enumerate(self, timeout=1000, timeout_unit='ns'):
        self.log.info("Enumerating bus")

        self.host_bridge.max_payload_size = self.max_payload_size
        self.host_bridge.max_payload_size_supported = self.max_payload_size_supported
        self.host_bridge.max_read_request_size = self.max_read_request_size

        self.host_bridge.io_base = self.io_base
        self.host_bridge.io_limit = self.io_base
        self.host_bridge.mem_base = self.mem_base
        self.host_bridge.mem_limit = self.mem_base
        self.host_bridge.prefetchable_mem_base = self.prefetchable_mem_base
        self.host_bridge.prefetchable_mem_limit = self.prefetchable_mem_base

        await self.host_bridge.probe(timeout=timeout, timeout_unit=timeout_unit)

        self.io_base = self.host_bridge.io_base
        self.io_limit = self.host_bridge.io_limit
        self.mem_base = self.host_bridge.mem_base
        self.mem_limit = self.host_bridge.mem_limit
        self.prefetchable_mem_base = self.host_bridge.prefetchable_mem_base
        self.prefetchable_mem_limit = self.host_bridge.prefetchable_mem_limit

        self.upstream_bridge.io_base = self.io_base
        self.upstream_bridge.io_limit = self.io_limit
        self.upstream_bridge.mem_base = self.mem_base
        self.upstream_bridge.mem_limit = self.mem_limit
        self.upstream_bridge.prefetchable_mem_base = self.prefetchable_mem_base
        self.upstream_bridge.prefetchable_mem_limit = self.prefetchable_mem_limit

        self.log.info("Enumeration complete")
        self.log.info("Device tree: \n%s", self.host_bridge.to_str().strip())



================================================
FILE: cocotbext/pcie/core/region.py
================================================
"""

Copyright (c) 2021 Alex Forencich

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

"""

import cocotb
from cocotbext.axi import Region

from .tlp import Tlp, TlpType, TlpAttr, TlpTc, CplStatus


class MemoryTlpRegion(Region):
    def __init__(self, func, size=2**64, *kwargs):
        super().__init__(size=size, *kwargs)
        self.func = func

        if hasattr(self.func, 'pcie_cap'):
            self.cfg = self.func.pcie_cap
        else:
            self.cfg = self.func

    async def read(self, addr, length, timeout=0, timeout_unit='ns', attr=TlpAttr(0), tc=TlpTc.TC0):
        n = 0
        data = bytearray()

        zero_len = length <= 0
        if zero_len:
            length = 1

        if not self.func.bus_master_enable:
            raise Exception("Bus mastering not enabled")

        op_list = []

        while n < length:
            req = Tlp()
            if addr > 0xffffffff:
                req.fmt_type = TlpType.MEM_READ_64
            else:
                req.fmt_type = TlpType.MEM_READ
            req.requester_id = self.func.pcie_id
            req.attr = attr
            req.tc = tc

            first_pad = addr % 4
            # remaining length
            byte_length = length-n
            # limit to max read request size
            if byte_length > (128 << self.cfg.max_read_request_size) - first_pad:
                # split on 128-byte read completion boundary
                byte_length = min(byte_length, (128 << self.cfg.max_read_request_size) - (addr & 0x7f))
            # 4k align
            byte_length = min(byte_length, 0x1000 - (addr & 0xfff))
            req.set_addr_be(addr, byte_length)

            if zero_len:
                req.first_be = 0

            op_list.append((byte_length, cocotb.start_soon(self.func.perform_nonposted_operation(req, timeout, timeout_unit))))

            n += byte_length
            addr += byte_length

        for byte_length, op in op_list:
            cpl_list = await op.join()

            m = 0

            while m < byte_length:
                if not cpl_list:
                    raise Exception("Timeout")

                cpl = cpl_list.pop(0)

                if cpl.status != CplStatus.SC:
                    raise Exception("Unsuccessful completion")

                assert cpl.byte_count+3+(cpl.lower_address & 3) >= cpl.length*4
                assert cpl.byte_count == max(byte_length - m, 1)

                d = cpl.get_data()

                offset = cpl.lower_address & 3
                data.extend(d[offset:offset+cpl.byte_count])

                m += len(d)-offset

        if zero_len:
            return b''

        return bytes(data[:length])

    async def write(self, addr, data, timeout=0, timeout_unit='ns', attr=TlpAttr(0), tc=TlpTc.TC0):
        n = 0

        zero_len = len(data) == 0
        if zero_len:
            data = b'\x00'

        if not self.func.bus_master_enable:
            raise Exception("Bus mastering not enabled")

        while n < len(data):
            req = Tlp()
            if addr > 0xffffffff:
                req.fmt_type = TlpType.MEM_WRITE_64
            else:
                req.fmt_type = TlpType.MEM_WRITE
            req.requester_id = self.func.pcie_id
            req.attr = attr
            req.tc = tc

            first_pad = addr % 4
            byte_length = len(data)-n
            byte_length = min(byte_length, (128 << self.cfg.max_payload_size)-first_pad)  # max payload size
            byte_length = min(byte_length, 0x1000 - (addr & 0xfff))  # 4k align
            req.set_addr_be_data(addr, data[n:n+byte_length])

            if zero_len:
                req.first_be = 0

            await self.func.perform_posted_operation(req)

            n += byte_length
            addr += byte_length


class IoTlpRegion(Region):
    def __init__(self, func, size=2**32, *kwargs):
        super().__init__(size=size, *kwargs)
        self.func = func

    async def read(self, addr, length, timeout=0, timeout_unit='ns'):
        n = 0
        data = bytearray()

        zero_len = length <= 0
        if zero_len:
            length = 1

        if not self.func.bus_master_enable:
            raise Exception("Bus mastering not enabled")

        op_list = []

        while n < length:
            req = Tlp()
            req.fmt_type = TlpType.IO_READ
            req.requester_id = self.func.pcie_id

            first_pad = addr % 4
            byte_length = min(length-n, 4-first_pad)
            req.set_addr_be(addr, byte_length)

            if zero_len:
                req.first_be = 0

            op_list.append((first_pad, cocotb.start_soon(self.func.perform_nonposted_operation(req, timeout, timeout_unit))))

            n += byte_length
            addr += byte_length

        for first_pad, op in op_list:
            cpl_list = await op.join()

            if not cpl_list:
                raise Exception("Timeout")
            cpl = cpl_list[0]
            if cpl.status != CplStatus.SC:
                raise Exception("Unsuccessful completion")

            assert cpl.length == 1
            d = cpl.get_data()

            data.extend(d[first_pad:])

        if zero_len:
            return b''

        return bytes(data[:length])

    async def write(self, addr, data, timeout=0, timeout_unit='ns'):
        n = 0

        zero_len = len(data) == 0
        if zero_len:
            data = b'\x00'

        if not self.func.bus_master_enable:
            raise Exception("Bus mastering not enabled")

        op_list = []

        while n < len(data):
            req = Tlp()
            req.fmt_type = TlpType.IO_WRITE
            req.requester_id = self.func.pcie_id

            first_pad = addr % 4
            byte_length = min(len(data)-n, 4-first_pad)
            req.set_addr_be_data(addr, data[n:n+byte_length])

            if zero_len:
                req.first_be = 0

            op_list.append(cocotb.start_soon(self.func.perform_nonposted_operation(req, timeout, timeout_unit)))

            n += byte_length
            addr += byte_length

        for op in op_list:
            cpl_list = await op.join()

            if not cpl_list:
                raise Exception("Timeout")
            if cpl_list[0].status != CplStatus.SC:
                raise Exception("Unsuccessful completion")



================================================
FILE: cocotbext/pcie/core/switch.py
================================================
"""

Copyright (c) 2020 Alex Forencich

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

"""

import logging

import cocotb
from cocotb.queue import Queue
from cocotb.triggers import Event

from .bridge import SwitchUpstreamPort, SwitchDownstreamPort
from .tlp import Tlp, TlpType
from .utils import PcieId


class SwitchPort:
    def __init__(self, bridge):
        self.bridge = bridge
        self.upstream = False

        self.ingress_queue = Queue(1)

        self.tx_queues = []
        self.rx_queues = []
        self.rx_event = Event()

        self.tx_handler = None

    @classmethod
    def upstream(cls, bridge):
        port = cls(bridge)
        port.upstream = True
        bridge.downstream_tx_handler = port.ingress_queue.put
        port.tx_handler = bridge.downstream_recv
        return port

    @classmethod
    def downstream(cls, bridge):
        port = cls(bridge)
        port.upstream = False
        bridge.upstream_tx_handler = port.ingress_queue.put
        port.tx_handler = bridge.upstream_recv
        return port


class Switch:
    """Switch object, container for switch bridges and associated interconnect"""
    def __init__(self, *args, **kwargs):
        self.__dict__.setdefault('default_upstream_bridge', SwitchUpstreamPort)
        self.__dict__.setdefault('default_downstream_bridge', SwitchDownstreamPort)

        super().__init__(*args, **kwargs)

        self.log = logging.getLogger(f"cocotb.pcie.{type(self).__name__}.{id(self)}")
        self.log.name = f"cocotb.pcie.{type(self).__name__}"

        self.switch_ports = []

        self.upstream_bridge = self.default_upstream_bridge()
        self.upstream_port = SwitchPort.upstream(self.upstream_bridge)
        self.add_switch_port(self.upstream_port)

        self.min_dev = 1
        self.endpoints = []

    @property
    def pcie_id(self):
        return self.upstream_bridge._pcie_id

    @property
    def bus_num(self):
        return self.pcie_id.bus

    @property
    def device_num(self):
        return self.pcie_id.device

    @property
    def function_num(self):
        return self.pcie_id.function

    def next_free_device_number(self):
        self.endpoints.sort(key=lambda x: (x.device_num, x.function_num))
        d = self.min_dev
        if not self.endpoints:
            return d
        for ep in self.endpoints:
            if ep.device_num > d:
                return d
            d = ep.device_num + 1
        if d < 32:
            return d
        return None

    def append_endpoint(self, ep):
        self.add_switch_port(SwitchPort.downstream(ep))
        self.endpoints.append(ep)
        self.endpoints.sort(key=lambda x: (x.device_num, x.function_num))
        return ep

    def add_endpoint(self, ep):
        ep.pcie_id = PcieId(0, self.next_free_device_number(), 0)
        return self.append_endpoint(ep)

    def make_port(self, bridge=None, port=None):
        if bridge is None:
            bridge = self.default_downstream_bridge()

            # transfer configuration from upstream bridge
            bridge.pcie_cap.max_payload_size_supported = self.upstream_bridge.pcie_cap.max_payload_size_supported
            bridge.pcie_cap.extended_tag_supported = self.upstream_bridge.pcie_cap.extended_tag_supported

        if port is not None:
            bridge.set_downstream_port(port)
        bridge.pri_bus_num = 0
        bridge.sec_bus_num = 0
        bridge.sub_bus_num = 0
        return self.add_endpoint(bridge)

    def set_upstream_bridge(self, bridge):
        self.upstream_bridge = bridge
        bridge.downstream_tx_handler = self.upstream_port.ingress_queue.put
        self.upstream_port.tx_handler = bridge.downstream_recv

    def set_upstream_port(self, port):
        self.upstream_bridge.set_upstream_port(port)

    def add_switch_port(self, port):
        self.switch_ports.append(port)
        cocotb.start_soon(self._run_routing(port))
        cocotb.start_soon(self._run_arbitration(port))

        for k in range(len(self.switch_ports)-1):
            tx_queue = Queue()
            rx_queue = Queue()
            port.tx_queues.append((self.switch_ports[k], tx_queue))
            port.rx_queues.append(rx_queue)
            self.switch_ports[k].rx_queues.append(tx_queue)
            self.switch_ports[k].tx_queues.append((port, rx_queue))

    def connect(self, port):
        self.upstream_bridge.upstream_port.connect(port)

    async def _run_routing(self, port):
        while True:
            tlp = await port.ingress_queue.get()

            tlp.ingress_port = port.bridge

            ok = False

            for other, tx_queue in port.tx_queues:
                if other.bridge.match_tlp(tlp):
                    # TLP directed to bridge
                    await tx_queue.put(tlp)
                    other.rx_event.set()
                    ok = True
                    break
                elif other.upstream:
                    if not other.bridge.match_tlp_secondary(tlp):
                        # TLP routed through upstream bridge
                        await tx_queue.put(tlp)
                        other.rx_event.set()
                        ok = True
                        break
                else:
                    if other.bridge.match_tlp_secondary(tlp):
                        # TLP routed through downstream bridge
                        await tx_queue.put(tlp)
                        other.rx_event.set()
                        ok = True
                        break

            if ok:
                continue

            tlp.release_fc()

            if tlp.fmt_type in {TlpType.CFG_READ_0, TlpType.CFG_WRITE_0}:
                # Config type 0
                self.log.warning("Failed to route config type 0 TLP: %r", tlp)
            elif tlp.fmt_type in {TlpType.CFG_READ_1, TlpType.CFG_WRITE_1}:
                # Config type 1
                self.log.warning("Failed to route config type 1 TLP: %r", tlp)
            elif tlp.fmt_type in {TlpType.CPL, TlpType.CPL_DATA, TlpType.CPL_LOCKED, TlpType.CPL_LOCKED_DATA}:
                # Completion
                self.log.warning("Unexpected completion: failed to route completion: %r", tlp)
                continue  # no UR response for completion
            elif tlp.fmt_type in {TlpType.IO_READ, TlpType.IO_WRITE}:
                # IO read/write
                self.log.warning("No address match: IO request could not be routed: %r", tlp)
            elif tlp.fmt_type in {TlpType.MEM_READ, TlpType.MEM_READ_64}:
                # Memory read/write
                self.log.warning("No address match: memory read request could not be routed: %r", tlp)
            elif tlp.fmt_type in {TlpType.MEM_WRITE, TlpType.MEM_WRITE_64}:
                # Memory read/write
                self.log.warning("No address match: memory write request could not be routed: %r", tlp)
                continue  # no UR response for write request
            else:
                raise Exception("TODO")

            # Unsupported request
            cpl = Tlp.create_ur_completion_for_tlp(tlp, port.bridge.pcie_id)
            self.log.debug("UR Completion: %r", cpl)
            await port.tx_handler(cpl)

    async def _run_arbitration(self, port):
        while True:
            await port.rx_event.wait()
            port.rx_event.clear()

            while True:
                ok = False

                for rx_queue in port.rx_queues:
                    if rx_queue.empty():
                        continue
                    tlp = await rx_queue.get()
                    await port.tx_handler(tlp)
                    ok = True

                if not ok:
                    break



================================================
FILE: cocotbext/pcie/core/tlp.py
================================================
"""

Copyright (c) 2020 Alex Forencich

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

"""

import enum
import struct

from .dllp import FcType
from .utils import PcieId


# TLP formats
class TlpFmt(enum.IntEnum):
    THREE_DW       = 0x0
    FOUR_DW        = 0x1
    THREE_DW_DATA  = 0x2
    FOUR_DW_DATA   = 0x3
    TLP_PREFIX     = 0x4


# TLP types
class TlpType(enum.Enum):
    MEM_READ           = (TlpFmt.THREE_DW,      0x00)
    MEM_READ_64        = (TlpFmt.FOUR_DW,       0x00)
    MEM_READ_LOCKED    = (TlpFmt.THREE_DW,      0x01)
    MEM_READ_LOCKED_64 = (TlpFmt.FOUR_DW,       0x01)
    MEM_WRITE          = (TlpFmt.THREE_DW_DATA, 0x00)
    MEM_WRITE_64       = (TlpFmt.FOUR_DW_DATA,  0x00)
    IO_READ            = (TlpFmt.THREE_DW,      0x02)
    IO_WRITE           = (TlpFmt.THREE_DW_DATA, 0x02)
    CFG_READ_0         = (TlpFmt.THREE_DW,      0x04)
    CFG_WRITE_0        = (TlpFmt.THREE_DW_DATA, 0x04)
    CFG_READ_1         = (TlpFmt.THREE_DW,      0x05)
    CFG_WRITE_1        = (TlpFmt.THREE_DW_DATA, 0x05)
    MSG_TO_RC          = (TlpFmt.FOUR_DW,       0x10)
    MSG_ADDR           = (TlpFmt.FOUR_DW,       0x11)
    MSG_ID             = (TlpFmt.FOUR_DW,       0x12)
    MSG_BCAST          = (TlpFmt.FOUR_DW,       0x13)
    MSG_LOCAL          = (TlpFmt.FOUR_DW,       0x14)
    MSG_GATHER         = (TlpFmt.FOUR_DW,       0x15)
    MSG_DATA_TO_RC     = (TlpFmt.FOUR_DW_DATA,  0x10)
    MSG_DATA_ADDR      = (TlpFmt.FOUR_DW_DATA,  0x11)
    MSG_DATA_ID        = (TlpFmt.FOUR_DW_DATA,  0x12)
    MSG_DATA_BCAST     = (TlpFmt.FOUR_DW_DATA,  0x13)
    MSG_DATA_LOCAL     = (TlpFmt.FOUR_DW_DATA,  0x14)
    MSG_DATA_GATHER    = (TlpFmt.FOUR_DW_DATA,  0x15)
    CPL                = (TlpFmt.THREE_DW,      0x0A)
    CPL_DATA           = (TlpFmt.THREE_DW_DATA, 0x0A)
    CPL_LOCKED         = (TlpFmt.THREE_DW,      0x0B)
    CPL_LOCKED_DATA    = (TlpFmt.THREE_DW_DATA, 0x0B)
    FETCH_ADD          = (TlpFmt.THREE_DW_DATA, 0x0C)
    FETCH_ADD_64       = (TlpFmt.FOUR_DW_DATA,  0x0C)
    SWAP               = (TlpFmt.THREE_DW_DATA, 0x0D)
    SWAP_64            = (TlpFmt.FOUR_DW_DATA,  0x0D)
    CAS                = (TlpFmt.THREE_DW_DATA, 0x0E)
    CAS_64             = (TlpFmt.FOUR_DW_DATA,  0x0E)
    PREFIX_MRIOV       = (TlpFmt.TLP_PREFIX,    0x00)
    PREFIX_VENDOR_L0   = (TlpFmt.TLP_PREFIX,    0x0E)
    PREFIX_VENDOR_L1   = (TlpFmt.TLP_PREFIX,    0x0F)
    PREFIX_EXT_TPH     = (TlpFmt.TLP_PREFIX,    0x10)
    PREFIX_VENDOR_E0   = (TlpFmt.TLP_PREFIX,    0x1E)
    PREFIX_VENDOR_E1   = (TlpFmt.TLP_PREFIX,    0x1F)


# Message types
class MsgType(enum.IntEnum):
    UNLOCK         = 0x00
    INVALIDATE_REQ = 0x01
    INVALIDATE_CPL = 0x02
    PAGE_REQ       = 0x04
    PRG_RESP       = 0x05
    LTR            = 0x10
    OBFF           = 0x12
    PM_AS_NAK      = 0x14
    PM_PME         = 0x18
    PME_TO         = 0x19
    PME_TO_ACK     = 0x1A
    ASSERT_INTA    = 0x20
    ASSERT_INTB    = 0x21
    ASSERT_INTC    = 0x22
    ASSERT_INTD    = 0x23
    DEASSERT_INTA  = 0x24
    DEASSERT_INTB  = 0x25
    DEASSERT_INTC  = 0x26
    DEASSERT_INTD  = 0x27
    ERR_COR        = 0x30
    ERR_NONFATAL   = 0x31
    ERR_FATAL      = 0x33
    SET_SPL        = 0x50
    PTM_REQ        = 0x52
    PTM_RESP       = 0x53
    VENDOR_0       = 0x7e
    VENDOR_1       = 0x7f


# AT field
class TlpAt(enum.IntEnum):
    DEFAULT       = 0x0
    TRANSLATE_REQ = 0x1
    TRANSLATED    = 0x2


# Attr field
class TlpAttr(enum.IntFlag):
    NS  = 0x1  # no snoop
    RO  = 0x2  # relaxed ordering
    IDO = 0x4  # ID-based ordering


# TC field
class TlpTc(enum.IntEnum):
    TC0 = 0x0
    TC1 = 0x1
    TC2 = 0x2
    TC3 = 0x3
    TC4 = 0x4
    TC5 = 0x5
    TC6 = 0x6
    TC7 = 0x7


# Completion status
class CplStatus(enum.IntEnum):
    SC  = 0x0  # successful completion
    UR  = 0x1  # unsupported request
    CRS = 0x2  # configuration request retry status
    CA  = 0x4  # completer abort


tlp_type_fc_type_mapping = {
    TlpType.MEM_READ:            FcType.NP,
    TlpType.MEM_READ_64:         FcType.NP,
    TlpType.MEM_READ_LOCKED:     FcType.NP,
    TlpType.MEM_READ_LOCKED_64:  FcType.NP,
    TlpType.MEM_WRITE:           FcType.P,
    TlpType.MEM_WRITE_64:        FcType.P,
    TlpType.IO_READ:             FcType.NP,
    TlpType.IO_WRITE:            FcType.NP,
    TlpType.CFG_READ_0:          FcType.NP,
    TlpType.CFG_WRITE_0:         FcType.NP,
    TlpType.CFG_READ_1:          FcType.NP,
    TlpType.CFG_WRITE_1:         FcType.NP,
    TlpType.MSG_TO_RC:           FcType.P,
    TlpType.MSG_ADDR:            FcType.P,
    TlpType.MSG_ID:              FcType.P,
    TlpType.MSG_BCAST:           FcType.P,
    TlpType.MSG_LOCAL:           FcType.P,
    TlpType.MSG_GATHER:          FcType.P,
    TlpType.MSG_DATA_TO_RC:      FcType.P,
    TlpType.MSG_DATA_ADDR:       FcType.P,
    TlpType.MSG_DATA_ID:         FcType.P,
    TlpType.MSG_DATA_BCAST:      FcType.P,
    TlpType.MSG_DATA_LOCAL:      FcType.P,
    TlpType.MSG_DATA_GATHER:     FcType.P,
    TlpType.CPL:                 FcType.CPL,
    TlpType.CPL_DATA:            FcType.CPL,
    TlpType.CPL_LOCKED:          FcType.CPL,
    TlpType.CPL_LOCKED_DATA:     FcType.CPL,
    TlpType.FETCH_ADD:           FcType.NP,
    TlpType.FETCH_ADD_64:        FcType.NP,
    TlpType.SWAP:                FcType.NP,
    TlpType.SWAP_64:             FcType.NP,
    TlpType.CAS:                 FcType.NP,
    TlpType.CAS_64:              FcType.NP,
}


class Tlp:
    def __init__(self, tlp=None):
        self.fmt = 0
        self.type = 0
        self.tc = TlpTc.TC0
        self.ln = False
        self.th = False
        self.td = False
        self.ep = False
        self.attr = TlpAttr(0)
        self.at = TlpAt.DEFAULT
        self.length = 0
        self.completer_id = PcieId(0, 0, 0)
        self.status = CplStatus.SC
        self.bcm = False
        self.byte_count = 0
        self.requester_id = PcieId(0, 0, 0)
        self.tag = 0
        self.first_be = 0
        self.last_be = 0
        self.lower_address = 0
        self.address = 0
        self.ph = 0
        self.data = bytearray()
        self.seq = 0

        self.release_fc_cb = None
        self.ingress_port = None

        if isinstance(tlp, Tlp):
            self.fmt = tlp.fmt
            self.type = tlp.type
            self.tc = tlp.tc
            self.ln = tlp.ln
            self.td = tlp.td
            self.ep = tlp.ep
            self.attr = tlp.attr
            self.at = tlp.at
            self.length = tlp.length
            self.completer_id = tlp.completer_id
            self.status = tlp.status
            self.bcm = tlp.bcm
            self.byte_count = tlp.byte_count
            self.requester_id = tlp.requester_id
            self.tag = tlp.tag
            self.first_be = tlp.first_be
            self.last_be = tlp.last_be
            self.lower_address = tlp.lower_address
            self.address = tlp.address
            self.ph = tlp.ph
            self.data = bytearray(tlp.data)
            self.seq = tlp.seq

    @property
    def fmt_type(self):
        return TlpType((self.fmt, self.type))

    @fmt_type.setter
    def fmt_type(self, val):
        if isinstance(val, TlpType):
            self.fmt, self.type = val.value
        else:
            self.fmt, self.type = val

    @property
    def completer_id(self):
        return self._completer_id

    @completer_id.setter
    def completer_id(self, val):
        self._completer_id = PcieId(val)

    @property
    def requester_id(self):
        return self._requester_id

    @requester_id.setter
    def requester_id(self, val):
        self._requester_id = PcieId(val)

    # alias for backwards compatibility
    @property
    def dest_id(self):
        return self._completer_id

    @dest_id.setter
    def dest_id(self, val):
        self._completer_id = PcieId(val)

    def check(self):
        """Validate TLP"""
        ret = True
        if self.fmt == TlpFmt.THREE_DW_DATA or self.fmt == TlpFmt.FOUR_DW_DATA:
            if self.length*4 != len(self.data):
                print(f"TLP validation failed, length field does not match data: {self!r}")
                ret = False
            if 0 > self.length > 1024:
                print(f"TLP validation failed, length out of range: {self!r}")
                ret = False
        if self.fmt_type in {TlpType.MEM_READ, TlpType.MEM_READ_64, TlpType.MEM_READ_LOCKED,
                TlpType.MEM_READ_LOCKED_64, TlpType.MEM_WRITE, TlpType.MEM_WRITE_64}:
            if self.length*4 > 0x1000 - (self.address & 0xfff):
                print(f"TLP validation failed, request crosses 4K boundary: {self!r}")
                ret = False
        if self.fmt_type == {TlpType.CFG_READ_0, TlpType.CFG_WRITE_0, TlpType.CFG_READ_1,
                TlpType.CFG_WRITE_1, TlpType.IO_READ, TlpType.IO_WRITE}:
            if self.length != 1:
                print(f"TLP validation failed, invalid length for IO or configuration request: {self!r}")
                ret = False
            if self.last_be != 0:
                print(f"TLP validation failed, invalid last BE for IO or configuration request: {self!r}")
                ret = False
        if self.fmt_type in {TlpType.CPL_DATA, TlpType.CPL_LOCKED_DATA}:
            if (self.byte_count + (self.lower_address & 3) + 3) < self.length*4:
                print(f"TLP validation failed, completion byte count too small: {self!r}")
                ret = False
        if self.fmt_type in {TlpType.CPL, TlpType.CPL_LOCKED, TlpType.MSG_TO_RC, TlpType.MSG_ADDR,
                TlpType.MSG_ID, TlpType.MSG_BCAST, TlpType.MSG_LOCAL, TlpType.MSG_GATHER}:
            if self.length != 0:
                print(f"TLP validation failed, length field is reserved: {self!r}")
                ret = False
        return ret

    @classmethod
    def create_completion_for_tlp(cls, tlp, completer_id, has_data=False, status=CplStatus.SC):
        """Prepare completion for TLP"""
        cpl = cls()
        if has_data:
            cpl.fmt_type = TlpType.CPL_DATA
        else:
            cpl.fmt_type = TlpType.CPL
        cpl.requester_id = tlp.requester_id
        cpl.completer_id = completer_id
        cpl.status = status
        cpl.attr = tlp.attr
        cpl.tag = tlp.tag
        cpl.tc = tlp.tc
        return cpl

    @classmethod
    def create_completion_data_for_tlp(cls, tlp, completer_id):
        """Prepare completion with data for TLP"""
        return cls.create_completion_for_tlp(tlp, completer_id, True)

    @classmethod
    def create_ur_completion_for_tlp(cls, tlp, completer_id):
        """Prepare unsupported request (UR) completion for TLP"""
        return cls.create_completion_for_tlp(tlp, completer_id, False, CplStatus.UR)

    @classmethod
    def create_crs_completion_for_tlp(cls, tlp, completer_id):
        """Prepare configuration request retry status (CRS) completion for TLP"""
        return cls.create_completion_for_tlp(tlp, completer_id, False, CplStatus.CRS)

    @classmethod
    def create_ca_completion_for_tlp(cls, tlp, completer_id):
        """Prepare completer abort (CA) completion for TLP"""
        return cls.create_completion_for_tlp(tlp, completer_id, False, CplStatus.CA)

    def set_addr_be(self, addr, length):
        """Compute byte enables, DWORD address, and DWORD length from byte address and length"""
        self.address = addr & ~3
        first_pad = addr % 4
        last_pad = 3 - (addr+length-1) % 4
        self.length = (length+first_pad+last_pad+3) // 4
        self.first_be = (0xf << first_pad) & 0xf
        self.last_be = (0xf >> last_pad)
        if self.length == 0:
            self.length = 1
            self.first_be = 0
            self.last_be = 0
        elif self.length == 1:
            self.first_be &= self.last_be
            self.last_be = 0

        return (first_pad, last_pad)

    def set_data(self, data):
        """Set DWORD data from byte data"""
        self.data = bytearray(data)
        self.length = len(self.data) // 4

    def set_addr_be_data(self, addr, data):
        """Set byte enables, DWORD address, DWORD length, and DWORD data from byte address and byte data"""
        self.address = addr & ~3
        first_pad, last_pad = self.set_addr_be(addr, len(data))
        self.data = bytearray(first_pad)
        self.data.extend(data)
        self.data.extend(bytearray(last_pad))

        if len(self.data) == 0:
            self.data = b'\x00\x00\x00\x00'

    def get_data(self):
        return self.data

    def get_first_be_offset(self):
        """Offset to first transferred byte from first byte enable"""
        if self.first_be & 0x7 == 0:
            return 3
        elif self.first_be & 0x3 == 0:
            return 2
        elif self.first_be & 0x1 == 0:
            return 1
        else:
            return 0

    def get_last_be_offset(self):
        """Offset after last transferred byte from last byte enable"""
        if self.length == 1:
            be = self.first_be
        else:
            be = self.last_be
        if be & 0xf == 0x1:
            return 3
        elif be & 0xe == 0x2:
            return 2
        elif be & 0xc == 0x4:
            return 1
        else:
            return 0

    def get_be_byte_count(self):
        """Compute byte length from DWORD length and byte enables"""
        return self.length*4 - self.get_first_be_offset() - self.get_last_be_offset()

    def get_lower_address(self):
        """Compute lower address field from address and first byte enable"""
        return self.address & 0x7c + self.get_first_be_offset()

    def has_data(self):
        """Return true if TLP has payload data"""
        return self.fmt in {TlpFmt.THREE_DW_DATA, TlpFmt.FOUR_DW_DATA}

    def get_header_size(self):
        """Return size of TLP in bytes"""
        if self.fmt in {TlpFmt.FOUR_DW, TlpFmt.FOUR_DW_DATA}:
            return 16
        else:
            return 12

    def get_header_size_dw(self):
        """Return size of TLP in dwords"""
        if self.fmt in {TlpFmt.FOUR_DW, TlpFmt.FOUR_DW_DATA}:
            return 4
        else:
            return 3

    def get_payload_size(self):
        """Return size of TLP payload in bytes"""
        return len(self.data)

    def get_payload_size_dw(self):
        """Return size of TLP payload in dwords"""
        return len(self.data) // 4

    def get_size(self):
        """Return size of TLP in bytes"""
        return self.get_header_size()+self.get_payload_size()

    def get_size_dw(self):
        """Return size of TLP in dwords"""
        return self.get_header_size_dw()+self.get_payload_size_dw()

    def get_wire_size(self):
        """Return size of TLP in bytes, including overhead"""
        return self.get_size()+8

    def get_data_credits(self):
        """Return size of TLP in data credits (1 credit per 4 DW)"""
        return (self.get_payload_size_dw()+3)//4

    def get_fc_type(self):
        return tlp_type_fc_type_mapping[self.fmt_type]

    def is_posted(self):
        return tlp_type_fc_type_mapping[self.fmt_type] == FcType.P

    def is_nonposted(self):
        return tlp_type_fc_type_mapping[self.fmt_type] == FcType.NP

    def is_completion(self):
        return tlp_type_fc_type_mapping[self.fmt_type] == FcType.CPL

    def release_fc(self):
        if self.release_fc_cb is not None:
            self.release_fc_cb()

    def pack_header(self):
        """Pack TLP header as bytes"""
        pkt = bytearray()

        dw = self.length & 0x3ff
        dw |= (self.at & 0x3) << 10
        dw |= (self.attr & 0x3) << 12
        dw |= bool(self.ep) << 14
        dw |= bool(self.td) << 15
        dw |= bool(self.th) << 16
        dw |= bool(self.ln) << 17
        dw |= (self.attr & 0x4) << 16
        dw |= (self.tag & 0x100) << 11
        dw |= (self.tc & 0x7) << 20
        dw |= (self.tag & 0x200) << 14
        dw |= (self.type & 0x1f) << 24
        dw |= (self.fmt & 0x7) << 29
        pkt.extend(struct.pack('>L', dw))

        if self.fmt_type in {TlpType.CFG_READ_0, TlpType.CFG_WRITE_0, TlpType.CFG_READ_1, TlpType.CFG_WRITE_1,
                TlpType.MEM_READ, TlpType.MEM_READ_64, TlpType.MEM_READ_LOCKED, TlpType.MEM_READ_LOCKED_64,
                TlpType.MEM_WRITE, TlpType.MEM_WRITE_64, TlpType.IO_READ, TlpType.IO_WRITE, TlpType.FETCH_ADD,
                TlpType.FETCH_ADD_64, TlpType.SWAP, TlpType.SWAP_64, TlpType.CAS, TlpType.CAS_64}:
            dw = self.first_be & 0xf
            dw |= (self.last_be & 0xf) << 4
            dw |= (self.tag & 0x0ff) << 8
            dw |= int(self.requester_id) << 16
            pkt.extend(struct.pack('>L', dw))

            if self.fmt_type in {TlpType.CFG_READ_0, TlpType.CFG_WRITE_0, TlpType.CFG_READ_1, TlpType.CFG_WRITE_1}:
                dw = self.address & 0xffc
                dw |= int(self.completer_id) << 16
                pkt.extend(struct.pack('>L', dw))
            else:
                if self.fmt in {TlpFmt.FOUR_DW, TlpFmt.FOUR_DW_DATA}:
                    val = self.address & 0xfffffffffffffffc
                    val |= self.ph & 0x3
                    pkt.extend(struct.pack('>Q', val))
                else:
                    dw = self.address & 0xfffffffc
                    dw |= self.ph & 0x3
                    pkt.extend(struct.pack('>L', dw))
        elif self.fmt_type in {TlpType.CPL, TlpType.CPL_DATA, TlpType.CPL_LOCKED, TlpType.CPL_LOCKED_DATA}:
            dw = self.byte_count & 0xfff
            dw |= bool(self.bcm) << 12
            dw |= (self.status & 0x7) << 13
            dw |= int(self.completer_id) << 16
            pkt.extend(struct.pack('>L', dw))
            dw = self.lower_address & 0x7f
            dw |= (self.tag & 0x0ff) << 8
            dw |= int(self.requester_id) << 16
            pkt.extend(struct.pack('>L', dw))
        else:
            raise Exception("Unknown TLP type")

        return pkt

    def pack(self):
        """Pack TLP as bytes"""
        pkt = self.pack_header()

        if self.has_data():
            pkt.extend(self.data)

        return pkt

    @classmethod
    def unpack_header(cls, pkt):
        """Unpack TLP header from bytes"""
        tlp = cls()

        dw, = struct.unpack_from('>L', pkt, 0)
        tlp.length = dw & 0x3ff
        tlp.at = TlpAt((dw >> 10) & 0x3)
        tlp.attr = (dw >> 12) & 0x3
        tlp.ep = bool(dw & 1 << 14)
        tlp.td = bool(dw & 1 << 15)
        tlp.th = bool(dw & 1 << 16)
        tlp.ln = bool(dw & 1 << 17)
        tlp.attr = TlpAttr(tlp.attr | (dw >> 16) & 0x4)
        tlp.tag = (dw >> 11) & 0x100
        tlp.tc = TlpTc((dw >> 20) & 0x7)
        tlp.tag |= (dw >> 14) & 0x200
        tlp.type = (dw >> 24) & 0x1f
        tlp.fmt = (dw >> 29) & 0x7

        if tlp.fmt_type not in {TlpType.CPL, TlpType.CPL_LOCKED, TlpType.MSG_TO_RC, TlpType.MSG_ADDR,
                TlpType.MSG_ID, TlpType.MSG_BCAST, TlpType.MSG_LOCAL, TlpType.MSG_GATHER} and tlp.length == 0:
            tlp.length = 1024

        if tlp.fmt_type in {TlpType.CFG_READ_0, TlpType.CFG_WRITE_0, TlpType.CFG_READ_1, TlpType.CFG_WRITE_1,
                TlpType.MEM_READ, TlpType.MEM_READ_64, TlpType.MEM_READ_LOCKED, TlpType.MEM_READ_LOCKED_64,
                TlpType.MEM_WRITE, TlpType.MEM_WRITE_64, TlpType.IO_READ, TlpType.IO_WRITE, TlpType.FETCH_ADD,
                TlpType.FETCH_ADD_64, TlpType.SWAP, TlpType.SWAP_64, TlpType.CAS, TlpType.CAS_64}:
            dw, = struct.unpack_from('>L', pkt, 4)
            tlp.first_be = dw & 0xf
            tlp.last_be = (dw >> 4) & 0xf
            tlp.tag |= (dw >> 8) & 0x0ff
            tlp.requester_id = PcieId.from_int(dw >> 16)

            if tlp.fmt_type in {TlpType.CFG_READ_0,  TlpType.CFG_WRITE_0, TlpType.CFG_READ_1,  TlpType.CFG_WRITE_1}:
                dw, = struct.unpack_from('>L', pkt, 8)
                tlp.address = dw & 0xffc
                tlp.completer_id = PcieId.from_int(dw >> 16)
            elif tlp.fmt in {TlpFmt.FOUR_DW, TlpFmt.FOUR_DW_DATA}:
                val, = struct.unpack_from('>Q', pkt, 8)
                tlp.address = val & 0xfffffffffffffffc
                tlp.ph = val & 0x3
            else:
                dw, = struct.unpack_from('>L', pkt, 8)
                tlp.address = dw & 0xfffffffc
                tlp.ph = dw & 0x3
        elif tlp.fmt_type in {TlpType.CPL, TlpType.CPL_DATA, TlpType.CPL_LOCKED, TlpType.CPL_LOCKED_DATA}:
            dw, = struct.unpack_from('>L', pkt, 4)
            tlp.byte_count = dw & 0xfff
            tlp.bcm = bool(dw & 1 << 12)
            tlp.status = CplStatus((dw >> 13) & 0x7)
            tlp.completer_id = PcieId.from_int(dw >> 16)
            dw, = struct.unpack_from('>L', pkt, 8)
            tlp.lower_address = dw & 0x7f
            tlp.tag |= (dw >> 8) & 0x0ff
            tlp.requester_id = PcieId.from_int(dw >> 16)

            if tlp.byte_count == 0:
                tlp.byte_count = 4096
        else:
            raise Exception("Unknown TLP type")

        return tlp

    @classmethod
    def unpack(cls, pkt):
        """Unpack TLP from bytes"""
        tlp = cls.unpack_header(pkt)

        tlp.data = pkt[tlp.get_header_size():]

        return tlp

    def __eq__(self, other):
        if isinstance(other, Tlp):
            return (
                self.data == other.data and
                self.fmt == other.fmt and
                self.type == other.type and
                self.tc == other.tc and
                self.ln == other.ln and
                self.td == other.td and
                self.ep == other.ep and
                self.attr == other.attr and
                self.at == other.at and
                self.length == other.length and
                self.completer_id == other.completer_id and
                self.status == other.status and
                self.bcm == other.bcm and
                self.byte_count == other.byte_count and
                self.requester_id == other.requester_id and
                self.tag == other.tag and
                self.first_be == other.first_be and
                self.last_be == other.last_be and
                self.lower_address == other.lower_address and
                self.address == other.address and
                self.ph == other.ph and
                self.seq == other.seq
            )
        return False

    def __repr__(self):
        return (
            f"{type(self).__name__}(data={self.data}, "
            f"fmt_type={self.fmt_type}, "
            f"tc={self.tc!s}, "
            f"ln={self.ln}, "
            f"th={self.th}, "
            f"td={self.td}, "
            f"ep={self.ep}, "
            f"attr={self.attr!s}, "
            f"at={self.at!s}, "
            f"length={self.length}, "
            f"completer_id={self.completer_id!r}, "
            f"status={self.status!s}, "
            f"bcm={self.bcm}, "
            f"byte_count={self.byte_count}, "
            f"requester_id={self.requester_id!r}, "
            f"tag={self.tag}, "
            f"first_be={self.first_be:#x}, "
            f"last_be={self.last_be:#x}, "
            f"lower_address={self.lower_address:#x}, "
            f"address={self.address:#x}, "
            f"ph={self.ph}, "
            f"seq={self.seq})"
        )

    def __bytes__(self):
        return self.pack()



================================================
FILE: cocotbext/pcie/core/utils.py
================================================
"""

Copyright (c) 2020 Alex Forencich

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

"""

from collections import namedtuple


def align(val, mask):
    if val & mask:
        return val + mask + 1 - (val & mask)
    else:
        return val


def byte_mask_update(old, mask, new, bitmask=-1):
    new = (new & bitmask) | (old & ~bitmask)
    m1 = 1
    m2 = 0xff
    while mask >= m1:
        if mask & m1:
            old = (old & ~m2) | (new & m2)
        m1 <<= 1
        m2 <<= 8
    return old


class PcieId(namedtuple("PcieId", ["bus", "device", "function"])):
    def __new__(cls, bus=0, device=0, function=0):
        if not isinstance(bus, int):
            bus, device, function = bus

        if bus < 0 or bus > 255:
            raise ValueError("Bus number out of range")
        if device < 0 or device > 31:
            raise ValueError("Device number out of range")
        if function < 0 or function > 7:
            raise ValueError("Function number out of range")

        return super().__new__(cls, bus, device, function)

    @classmethod
    def from_int(cls, val):
        return cls((val >> 8) & 0xff, (val >> 3) & 0x1f, val & 0x7)

    def _replace(self, **kwargs):
        return type(self)(**dict(self._asdict(), **kwargs))

    def __int__(self):
        return ((self.bus & 0xff) << 8) | ((self.device & 0x1f) << 3) | (self.function & 0x7)

    def __str__(self):
        return f"{self.bus:02x}:{self.device:02x}.{self.function:x}"

    def __repr__(self):
        return f"{type(self).__name__}({self.bus}, {self.device}, {self.function})"



================================================
FILE: cocotbext/pcie/core/version.py
================================================
__version__ = "0.2.15"



================================================
FILE: cocotbext/pcie/core/caps/__init__.py
================================================
"""

Copyright (c) 2021 Alex Forencich

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

"""

from .common import PciCapId, PciExtCapId
from .common import PciCap, PciExtCap, PciCapList, PciExtCapList

from .pcie import PcieCapability, PcieExtendedCapability
from .msi import MsiCapability, MsixCapability
from .pm import PmCapability
from .aer import AerExtendedCapability



================================================
FILE: cocotbext/pcie/core/caps/aer.py
================================================
"""

Copyright (c) 2021 Alex Forencich

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

"""

from .common import PciExtCapId, PciExtCap


class AerExtendedCapability(PciExtCap):
    """Advanced Error Reporting extended capability"""
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.cap_id = PciExtCapId.AER
        self.cap_ver = 2
        self.length = 11

        # Advanced Error Reporting capability registers
        # Uncorrectable error status
        self.data_link_protocol_error_status = False
        self.surprise_down_error_status = False
        self.poisoned_tlp_received_status = False
        self.flow_control_protocol_error_status = False
        self.completion_timeout_status = False
        self.completer_abort_status = False
        self.unexpected_completion_status = False
        self.receiver_overflow_status = False
        self.malformed_tlp_status = False
        self.ecrc_error_status = False
        self.unsupported_request_error_status = False
        self.acs_violation_status = False
        self.uncorrectable_internal_error_status = False
        self.mc_blocked_tlp_status = False
        self.atomicop_egress_blocked_status = False
        self.tlp_prefix_blocked_error_status = False
        self.poisoned_tlp_egress_blocked_status = False
        # Uncorrectable error mask
        self.data_link_protocol_error_mask = False
        self.surprise_down_error_mask = False
        self.poisoned_tlp_received_mask = False
        self.flow_control_protocol_error_mask = False
        self.completion_timeout_mask = False
        self.completer_abort_mask = False
        self.unexpected_completion_mask = False
        self.receiver_overflow_mask = False
        self.malformed_tlp_mask = False
        self.ecrc_error_mask = False
        self.unsupported_request_error_mask = False
        self.acs_violation_mask = False
        self.uncorrectable_internal_error_mask = True
        self.mc_blocked_tlp_mask = False
        self.atomicop_egress_blocked_mask = False
        self.tlp_prefix_blocked_error_mask = False
        self.poisoned_tlp_egress_blocked_mask = True
        # Uncorrectable error severity
        self.data_link_protocol_error_severity = True
        self.surprise_down_error_severity = True
        self.poisoned_tlp_received_severity = False
        self.flow_control_protocol_error_severity = True
        self.completion_timeout_severity = False
        self.completer_abort_severity = False
        self.unexpected_completion_severity = False
        self.receiver_overflow_severity = True
        self.malformed_tlp_severity = True
        self.ecrc_error_severity = False
        self.unsupported_request_error_severity = False
        self.acs_violation_severity = False
        self.uncorrectable_internal_error_severity = True
        self.mc_blocked_tlp_severity = False
        self.atomicop_egress_blocked_severity = False
        self.tlp_prefix_blocked_error_severity = False
        self.poisoned_tlp_egress_blocked_severity = False
        # Correctable error status
        self.receiver_error_status = False
        self.bad_tlp_status = False
        self.bad_dllp_status = False
        self.replay_num_rollover_status = False
        self.replay_timer_timeout_status = False
        self.advisory_nonfatal_error_status = False
        self.corrected_internal_error_status = False
        self.header_log_overflow_status = False
        # Correctable error mask
        self.receiver_error_mask = False
        self.bad_tlp_mask = False
        self.bad_dllp_mask = False
        self.replay_num_rollover_mask = False
        self.replay_timer_timeout_mask = False
        self.advisory_nonfatal_error_mask = True
        self.corrected_internal_error_mask = True
        self.header_log_overflow_mask = True
        # Advanced error capabilities and control
        self.first_error_pointer = 0
        self.ecrc_generation_capable = False
        self.ecrc_generation_enable = False
        self.ecrc_check_capable = False
        self.ecrc_check_enable = False
        self.multiple_header_recording_capable = False
        self.multiple_header_recording_enable = False
        self.tlp_prefix_log_present = False
        self.completion_timeout_prefix_header_log_capable = False
        # Header log
        self.header_log = [0]*4
        # Root error command
        self.fatal_error_reporting_enable = False
        self.nonfatal_error_reporting_enable = False
        self.correctable_error_reporting_enable = False
        # Root error status
        self.err_cor_received = False
        self.multiple_err_cor_received = False
        self.err_fatal_nonfatal_received = False
        self.multiple_err_fatal_nonfatal_received = False
        self.first_uncorrectable_fatal = False
        self.nonfatal_error_messages_received = False
        self.fatal_error_messages_received = False
        self.advanced_error_interrupt_message_number = 0
        # Error source identification
        self.err_cor_source_identification = 0
        self.err_fatal_nonfatal_source_identification = 0
        # TLP prefix log
        self.tlp_prefix_log = [0]*4

    """
    Advanced Error Reporting extended capability

    31                                                                  0
    +-------------------------+-------+---------------------------------+
    |     Next Cap Offset     |  Ver  |         AER Ext Cap ID          |   0   0x00
    +-------------------------+-------+---------------------------------+
    |                    Uncorrectable error status                     |   1   0x04
    +-------------------------------------------------------------------+
    |                     Uncorrectable error mask                      |   2   0x08
    +-------------------------------------------------------------------+
    |                   Uncorrectable error severity                    |   3   0x0C
    +-------------------------------------------------------------------+
    |                     Correctable error status                      |   4   0x10
    +-------------------------------------------------------------------+
    |                      Correctable error mask                       |   5   0x14
    +-------------------------------------------------------------------+
    |              Advanced error capabilities and control              |   6   0x18
    +-------------------------------------------------------------------+
    |                                                                   |   7   0x1C
    |                            Header log                             |   8   0x20
    |                                                                   |   9   0x24
    |                                                                   |  10   0x28
    +-------------------------------------------------------------------+
    |                        Root error command                         |  11   0x2C
    +-------------------------------------------------------------------+
    |                         Root error status                         |  12   0x30
    +-------------------------------------------------------------------+
    |                    Error source identification                    |  13   0x34
    +-------------------------------------------------------------------+
    |                                                                   |  14   0x38
    |                          TLP prefix log                           |  15   0x3C
    |                                                                   |  16   0x40
    |                                                                   |  17   0x44
    +-------------------------------------------------------------------+
    """
    async def _read_register(self, reg):
        if reg == 1:
            # Uncorrectable error status
            val = bool(self.data_link_protocol_error_status) << 4
            val |= bool(self.surprise_down_error_status) << 5
            val |= bool(self.poisoned_tlp_received_status) << 12
            val |= bool(self.flow_control_protocol_error_status) << 13
            val |= bool(self.completion_timeout_status) << 14
            val |= bool(self.completer_abort_status) << 15
            val |= bool(self.unexpected_completion_status) << 16
            val |= bool(self.receiver_overflow_status) << 17
            val |= bool(self.malformed_tlp_status) << 18
            val |= bool(self.ecrc_error_status) << 19
            val |= bool(self.unsupported_request_error_status) << 20
            val |= bool(self.acs_violation_status) << 21
            val |= bool(self.uncorrectable_internal_error_status) << 22
            val |= bool(self.mc_blocked_tlp_status) << 23
            val |= bool(self.atomicop_egress_blocked_status) << 24
            val |= bool(self.tlp_prefix_blocked_error_status) << 25
            val |= bool(self.poisoned_tlp_egress_blocked_status) << 26
            return val
        elif reg == 2:
            # Uncorrectable error mask
            val = bool(self.data_link_protocol_error_mask) << 4
            val |= bool(self.surprise_down_error_mask) << 5
            val |= bool(self.poisoned_tlp_received_mask) << 12
            val |= bool(self.flow_control_protocol_error_mask) << 13
            val |= bool(self.completion_timeout_mask) << 14
            val |= bool(self.completer_abort_mask) << 15
            val |= bool(self.unexpected_completion_mask) << 16
            val |= bool(self.receiver_overflow_mask) << 17
            val |= bool(self.malformed_tlp_mask) << 18
            val |= bool(self.ecrc_error_mask) << 19
            val |= bool(self.unsupported_request_error_mask) << 20
            val |= bool(self.acs_violation_mask) << 21
            val |= bool(self.uncorrectable_internal_error_mask) << 22
            val |= bool(self.mc_blocked_tlp_mask) << 23
            val |= bool(self.atomicop_egress_blocked_mask) << 24
            val |= bool(self.tlp_prefix_blocked_error_mask) << 25
            val |= bool(self.poisoned_tlp_egress_blocked_mask) << 26
            return val
        elif reg == 3:
            # Uncorrectable error severity
            val = bool(self.data_link_protocol_error_severity) << 4
            val |= bool(self.surprise_down_error_severity) << 5
            val |= bool(self.poisoned_tlp_received_severity) << 12
            val |= bool(self.flow_control_protocol_error_severity) << 13
            val |= bool(self.completion_timeout_severity) << 14
            val |= bool(self.completer_abort_severity) << 15
            val |= bool(self.unexpected_completion_severity) << 16
            val |= bool(self.receiver_overflow_severity) << 17
            val |= bool(self.malformed_tlp_severity) << 18
            val |= bool(self.ecrc_error_severity) << 19
            val |= bool(self.unsupported_request_error_severity) << 20
            val |= bool(self.acs_violation_severity) << 21
            val |= bool(self.uncorrectable_internal_error_severity) << 22
            val |= bool(self.mc_blocked_tlp_severity) << 23
            val |= bool(self.atomicop_egress_blocked_severity) << 24
            val |= bool(self.tlp_prefix_blocked_error_severity) << 25
            val |= bool(self.poisoned_tlp_egress_blocked_severity) << 26
            return val
        elif reg == 4:
            # Correctable error status
            val = bool(self.receiver_error_status)
            val |= bool(self.bad_tlp_status) << 6
            val |= bool(self.bad_dllp_status) << 7
            val |= bool(self.replay_num_rollover_status) << 8
            val |= bool(self.replay_timer_timeout_status) << 12
            val |= bool(self.advisory_nonfatal_error_status) << 13
            val |= bool(self.corrected_internal_error_status) << 14
            val |= bool(self.header_log_overflow_status) << 15
            return val
        elif reg == 5:
            # Correctable error mask
            val = bool(self.receiver_error_mask) << 0
            val |= bool(self.bad_tlp_mask) << 6
            val |= bool(self.bad_dllp_mask) << 7
            val |= bool(self.replay_num_rollover_mask) << 8
            val |= bool(self.replay_timer_timeout_mask) << 12
            val |= bool(self.advisory_nonfatal_error_mask) << 13
            val |= bool(self.corrected_internal_error_mask) << 14
            val |= bool(self.header_log_overflow_mask) << 15
            return val
        elif reg == 6:
            # Advanced error capabilities and control
            val = self.first_error_pointer & 0xf
            val |= bool(self.ecrc_generation_capable) << 5
            val |= bool(self.ecrc_generation_enable) << 6
            val |= bool(self.ecrc_check_capable) << 7
            val |= bool(self.ecrc_check_enable) << 8
            val |= bool(self.multiple_header_recording_capable) << 9
            val |= bool(self.multiple_header_recording_enable) << 10
            val |= bool(self.tlp_prefix_log_present) << 11
            val |= bool(self.completion_timeout_prefix_header_log_capable) << 12
            return val
        elif 7 <= reg <= 10:
            # Header log
            return self.header_log[reg-7] & 0xffffffff
        elif reg == 11:
            # Root error command
            val = bool(self.fatal_error_reporting_enable)
            val |= bool(self.nonfatal_error_reporting_enable) << 1
            val |= bool(self.correctable_error_reporting_enable) << 2
            return val
        elif reg == 12:
            # Root error status
            val = bool(self.err_cor_received) << 0
            val |= bool(self.multiple_err_cor_received) << 1
            val |= bool(self.err_fatal_nonfatal_received) << 2
            val |= bool(self.multiple_err_fatal_nonfatal_received) << 3
            val |= bool(self.first_uncorrectable_fatal) << 4
            val |= bool(self.nonfatal_error_messages_received) << 5
            val |= bool(self.fatal_error_messages_received) << 6
            val |= (self.advanced_error_interrupt_message_number & 0x1f) << 27
            return val
        elif reg == 13:
            # Error source identification
            val = self.err_cor_source_identification & 0xffff
            val |= (self.err_fatal_nonfatal_source_identification & 0xffff) << 16
            return val
        elif 14 <= reg <= 17:
            # TLP prefix log
            return self.tlp_prefix_log[reg-14] & 0xffffffff
        else:
            return 0

    async def _write_register(self, reg, data, mask):
        if reg == 1:
            # Uncorrectable error status
            if mask & 0x1:
                if data & 1 << 4:
                    self.data_link_protocol_error_status = False
                if data & 1 << 5:
                    self.surprise_down_error_status = False
            if mask & 0x2:
                if data & 1 << 12:
                    self.poisoned_tlp_received_status = False
                if data & 1 << 13:
                    self.flow_control_protocol_error_status = False
                if data & 1 << 14:
                    self.completion_timeout_status = False
                if data & 1 << 15:
                    self.completer_abort_status = False
            if mask & 0x4:
                if data & 1 << 16:
                    self.unexpected_completion_status = False
                if data & 1 << 17:
                    self.receiver_overflow_status = False
                if data & 1 << 18:
                    self.malformed_tlp_status = False
                if data & 1 << 19:
                    self.ecrc_error_status = False
                if data & 1 << 20:
                    self.unsupported_request_error_status = False
                if data & 1 << 21:
                    self.acs_violation_status = False
                if data & 1 << 22:
                    self.uncorrectable_internal_error_status = False
                if data & 1 << 23:
                    self.mc_blocked_tlp_status = False
            if mask & 0x8:
                if data & 1 << 24:
                    self.atomicop_egress_blocked_status = False
                if data & 1 << 25:
                    self.tlp_prefix_blocked_error_status = False
                if data & 1 << 26:
                    self.poisoned_tlp_egress_blocked_status = False
        elif reg == 2:
            # Uncorrectable error mask
            if mask & 0x1:
                self.data_link_protocol_error_mask = bool(data & 1 << 4)
                self.surprise_down_error_mask = bool(data & 1 << 5)
            if mask & 0x2:
                self.poisoned_tlp_received_mask = bool(data & 1 << 12)
                self.flow_control_protocol_error_mask = bool(data & 1 << 13)
                self.completion_timeout_mask = bool(data & 1 << 14)
                self.completer_abort_mask = bool(data & 1 << 15)
            if mask & 0x4:
                self.unexpected_completion_mask = bool(data & 1 << 16)
                self.receiver_overflow_mask = bool(data & 1 << 17)
                self.malformed_tlp_mask = bool(data & 1 << 18)
                self.ecrc_error_mask = bool(data & 1 << 19)
                self.unsupported_request_error_mask = bool(data & 1 << 20)
                self.acs_violation_mask = bool(data & 1 << 21)
                self.uncorrectable_internal_error_mask = bool(data & 1 << 22)
                self.mc_blocked_tlp_mask = bool(data & 1 << 23)
            if mask & 0x8:
                self.atomicop_egress_blocked_mask = bool(data & 1 << 24)
                self.tlp_prefix_blocked_error_mask = bool(data & 1 << 25)
                self.poisoned_tlp_egress_blocked_mask = bool(data & 1 << 26)
        elif reg == 3:
            # Uncorrectable error severity
            if mask & 0x1:
                self.data_link_protocol_error_severity = bool(data & 1 << 4)
                self.surprise_down_error_severity = bool(data & 1 << 5)
            if mask & 0x2:
                self.poisoned_tlp_received_severity = bool(data & 1 << 12)
                self.flow_control_protocol_error_severity = bool(data & 1 << 13)
                self.completion_timeout_severity = bool(data & 1 << 14)
                self.completer_abort_severity = bool(data & 1 << 15)
            if mask & 0x4:
                self.unexpected_completion_severity = bool(data & 1 << 16)
                self.receiver_overflow_severity = bool(data & 1 << 17)
                self.malformed_tlp_severity = bool(data & 1 << 18)
                self.ecrc_error_severity = bool(data & 1 << 19)
                self.unsupported_request_error_severity = bool(data & 1 << 20)
                self.acs_violation_severity = bool(data & 1 << 21)
                self.uncorrectable_internal_error_severity = bool(data & 1 << 22)
                self.mc_blocked_tlp_severity = bool(data & 1 << 23)
            if mask & 0x8:
                self.atomicop_egress_blocked_severity = bool(data & 1 << 24)
                self.tlp_prefix_blocked_error_severity = bool(data & 1 << 25)
                self.poisoned_tlp_egress_blocked_severity = bool(data & 1 << 26)
        elif reg == 4:
            # Correctable error status
            if mask & 0x1:
                if data & 1 << 0:
                    self.receiver_error_status = False
                if data & 1 << 6:
                    self.bad_tlp_status = False
                if data & 1 << 7:
                    self.bad_dllp_status = False
            if mask & 0x2:
                if data & 1 << 8:
                    self.replay_num_rollover_status = False
                if data & 1 << 12:
                    self.replay_timer_timeout_status = False
                if data & 1 << 13:
                    self.advisory_nonfatal_error_status = False
                if data & 1 << 14:
                    self.corrected_internal_error_status = False
                if data & 1 << 15:
                    self.header_log_overflow_status = False
        elif reg == 5:
            # Correctable error mask
            if mask & 0x1:
                self.receiver_error_mask = bool(data & 1 << 0)
                self.bad_tlp_mask = bool(data & 1 << 6)
                self.bad_dllp_mask = bool(data & 1 << 7)
            if mask & 0x2:
                self.replay_num_rollover_mask = bool(data & 1 << 8)
                self.replay_timer_timeout_mask = bool(data & 1 << 12)
                self.advisory_nonfatal_error_mask = bool(data & 1 << 13)
                self.corrected_internal_error_mask = bool(data & 1 << 14)
                self.header_log_overflow_mask = bool(data & 1 << 15)
        elif reg == 6:
            # Advanced error capabilities and control
            if mask & 0x1:
                self.ecrc_generation_enable = bool(data & 1 << 6)
            if mask & 0x2:
                self.ecrc_check_enable = bool(data & 1 << 8)
                self.multiple_header_recording_enable = bool(data & 1 << 10)
        elif reg == 11:
            # Root error command
            if mask & 0x1:
                self.fatal_error_reporting_enable = bool(data & 1 << 0)
                self.nonfatal_error_reporting_enable = bool(data & 1 << 1)
                self.correctable_error_reporting_enable = bool(data & 1 << 2)
            pass
        elif reg == 12:
            # Root error status
            if mask & 0x1:
                if data & 1 << 0:
                    self.err_cor_received = False
                if data & 1 << 1:
                    self.multiple_err_cor_received = False
                if data & 1 << 2:
                    self.err_fatal_nonfatal_received = False
                if data & 1 << 3:
                    self.multiple_err_fatal_nonfatal_received = False
                if data & 1 << 4:
                    self.first_uncorrectable_fatal = False
                if data & 1 << 5:
                    self.nonfatal_error_messages_received = False
                if data & 1 << 6:
                    self.fatal_error_messages_received = False



================================================
FILE: cocotbext/pcie/core/caps/common.py
================================================
"""

Copyright (c) 2021 Alex Forencich

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

"""

import enum


# PCI capability IDs
class PciCapId(enum.IntEnum):
    NULL    = 0x00  # Null capability
    PM      = 0x01  # Power Management
    AGP     = 0x02  # Accelerated Graphics Port
    VPD     = 0x03  # Vital Product Data
    SLOTID  = 0x04  # Slot Identification
    MSI     = 0x05  # Message Signalled Interrupts
    CHSWP   = 0x06  # CompactPCI HotSwap
    PCIX    = 0x07  # PCI-X
    HT      = 0x08  # HyperTransport
    VNDR    = 0x09  # Vendor specific
    DBG     = 0x0A  # Debug port
    CCRC    = 0x0B  # CompactPCI Central Resource Control
    SHPC    = 0x0C  # PCI Standard Hot-Plug Controller
    SSVID   = 0x0D  # Bridge subsystem vendor/device ID
    AGP3    = 0x0E  # AGP Target PCI-PCI bridge
    SEC     = 0x0F  # Secure device
    EXP     = 0x10  # PCI Express
    MSIX    = 0x11  # MSI-X
    SATA    = 0x12  # SATA data/index configuration
    AF      = 0x13  # PCI Advanced Features
    EA      = 0x14  # Enhanced allocation
    FPB     = 0x15  # Flattening portal bridge


class PciExtCapId(enum.IntEnum):
    NULL    = 0x0000  # Null capability
    AER     = 0x0001  # Advanced Error Reporting
    VC      = 0x0002  # Virtual Channel
    DSN     = 0x0003  # Device Serial Number
    PWR     = 0x0004  # Power budgeting capability
    RCLD    = 0x0005  # Root Complex Link Declaration
    RCILC   = 0x0006  # Root Complex Internal Link Control
    RCEC    = 0x0007  # Root Complex Event Collector endpoint association
    MFVC    = 0x0008  # Multi-Function Virtual Channel
    VC2     = 0x0009  # Virtual Channel (alternate ID)
    RCRB    = 0x000A  # Root Complex Register Block
    VSEC    = 0x000B  # Vendor Specific
    CAC     = 0x000C  # Configuration Access Correlation
    ACS     = 0x000D  # Access Control Services
    ARI     = 0x000E  # Alternative Routing ID
    ATS     = 0x000F  # Address Translation Services
    SRIOV   = 0x0010  # Single-Root IO Virtualization (SR-IOV)
    MRIOV   = 0x0011  # Multi-Root IO Virtualization (MR-IOV)
    MCAST   = 0x0012  # Multicast
    PRI     = 0x0013  # Page Request Interface
    RBAR    = 0x0015  # Resizable BAR
    DPA     = 0x0016  # Dynamic power allocation
    TPH     = 0x0017  # TPH requester
    LTR     = 0x0018  # Latency tolerance reporting
    EXP2    = 0x0019  # Secondary PCI express
    PMUX    = 0x001A  # Protocol Multiplexing
    PASID   = 0x001B  # Process address space ID
    LNR     = 0x001C  # LN requester
    DPC     = 0x001D  # Downstream port containment
    L1PM    = 0x001E  # L1 PM substates
    PTM     = 0x001F  # Precision Time Measurement
    MPCIE   = 0x0020  # PCI express over M-PHY
    FRSQ    = 0x0021  # Function readiness status queueing
    RTR     = 0x0022  # Readiness time reporting
    DVSEC   = 0x0023  # Designated vendor-specific
    VFRBAR  = 0x0024  # VF resizable BAR
    DLF     = 0x0025  # Data Link Feature
    PHY16   = 0x0026  # PHY 16.0 GT/s
    LM      = 0x0027  # Lane margining at the receiver
    HID     = 0x0028  # Hierarchy ID
    NPEM    = 0x0029  # Native PCIe enclosure management
    PHY32   = 0x002A  # PHY 32.0 GT/s
    AP      = 0x002B  # Alternate Protocol
    SFI     = 0x002C  # System Firmware Intermediary


class PciCap:
    def __init__(self, *args, **kwargs):
        self.cap_id = PciCapId.NULL
        self.cap_ver = 0
        self.length = 1
        self.offset = None
        self.next_cap = 0
        self.parent = None

        super().__init__(*args, **kwargs)

    async def read_register(self, reg):
        val = await self._read_register(reg)
        if reg == 0:
            val = (val & 0xffff0000) | ((self.next_cap & 0xff) << 8) | (self.cap_id & 0xff)
        return val

    async def write_register(self, reg, data, mask):
        await self._write_register(reg, data, mask)

    async def _read_register(self, reg):
        raise NotImplementedError()

    async def _write_register(self, reg, data, mask):
        raise NotImplementedError()

    def __repr__(self):
        return (
            f"{type(self).__name__}(cap_id={self.cap_id:#x}, "
            f"cap_ver={self.cap_ver}, "
            f"length={self.length}, "
            f"offset={self.offset}, "
            f"next_cap={self.next_cap})"
        )


class PciExtCap(PciCap):
    async def read_register(self, reg):
        if reg == 0:
            return ((self.next_cap & 0xfff) << 20) | ((self.cap_ver & 0xf) << 16) | (self.cap_id & 0xffff)
        return await self._read_register(reg)


class PciCapList:
    def __init__(self):
        self.cap_type = PciCap
        self.list = []
        self.start = 0x10
        self.end = 0x3f

    def find_by_id(self, cap_id):
        for cap in self.list:
            if cap.cap_id == cap_id:
                return cap
        return None

    def find_by_reg(self, reg):
        for cap in self.list:
            if cap.offset <= reg < cap.offset+cap.length:
                return cap
        return None

    async def read_register(self, reg):
        cap = self.find_by_reg(reg)
        if cap:
            return await cap.read_register(reg-cap.offset)
        return 0

    async def write_register(self, reg, data, mask):
        cap = self.find_by_reg(reg)
        if cap:
            await cap.write_register(reg-cap.offset, data, mask)

    def register(self, cap, offset=None):
        if not isinstance(cap, self.cap_type):
            cap = self.find_by_id(cap)
            if not cap:
                raise Exception("Capability not found")

        # remove from list
        if cap in self.list:
            self.list.remove(cap)

        # update parameters
        if offset is not None:
            cap.offset = offset

        bump_list = []

        if cap.offset:
            for c in self.list:
                if c.offset <= cap.offset+cap.length-1 and cap.offset <= c.offset+c.length-1:
                    bump_list.append(c)
            for c in bump_list:
                self.list.remove(c)
        else:
            cap.offset = self.start
            for c in self.list:
                if c.offset < cap.offset+cap.length-1 and cap.offset <= c.offset+c.length-1:
                    cap.offset = c.offset+c.length

        self.list.append(cap)

        self._build_linked_list()

        # re-insert bumped caps
        for c in bump_list:
            c.offset = None
            self.register(c)

    def deregister(self, cap):
        if cap in self.list:
            self.list.remove(cap)

        self._build_linked_list()

    def _build_linked_list(self):
        # sort list by offset
        self.list.sort(key=lambda x: x.offset)

        # update list next cap pointers
        for k in range(1, len(self.list)):
            self.list[k-1].next_cap = self.list[k].offset*4
            self.list[k].next_cap = 0


class PciExtCapList(PciCapList):
    def __init__(self):
        super().__init__()
        self.cap_type = PciExtCap
        self.start = 0x40
        self.end = 0x3ff



================================================
FILE: cocotbext/pcie/core/caps/msi.py
================================================
"""

Copyright (c) 2021 Alex Forencich

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

"""

import struct

from .common import PciCapId, PciCap
from ..tlp import TlpAttr, TlpTc
from ..utils import byte_mask_update


class MsiCapability(PciCap):
    """Message-signalled interrupt capability"""
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.cap_id = PciCapId.MSI
        self.length = 6

        # MSI Capability Registers
        self.msi_enable = False
        self.msi_multiple_message_capable = 0
        self.msi_multiple_message_enable = 0
        self.msi_64bit_address_capable = 0
        self.msi_per_vector_mask_capable = 0
        self.msi_extended_message_data_capable = 0
        self.msi_extended_message_data_enable = 0
        self.msi_message_address = 0
        self.msi_message_data = 0
        self.msi_mask_bits = 0
        self.msi_pending_bits = 0

    """
    MSI Capability (32 bit)

    31                                                                  0
    +---------------------------------+----------------+----------------+
    |         Message Control         |    Next Cap    |     Cap ID     |   0   0x00
    +---------------------------------+----------------+----------------+
    |                          Message Address                          |   1   0x04
    +---------------------------------+---------------------------------+
    |      Extended Message Data      |           Message Data          |   2   0x08
    +---------------------------------+---------------------------------+

    MSI Capability (64 bit)

    31                                                                  0
    +---------------------------------+----------------+----------------+
    |         Message Control         |    Next Cap    |     Cap ID     |   0   0x00
    +---------------------------------+----------------+----------------+
    |                          Message Address                          |   1   0x04
    +-------------------------------------------------------------------+
    |                       Message Upper Address                       |   2   0x08
    +---------------------------------+---------------------------------+
    |      Extended Message Data      |           Message Data          |   3   0x0C
    +---------------------------------+---------------------------------+

    MSI Capability (32 bit with per-vector masking)

    31                                                                  0
    +---------------------------------+----------------+----------------+
    |         Message Control         |    Next Cap    |     Cap ID     |   0   0x00
    +---------------------------------+----------------+----------------+
    |                          Message Address                          |   1   0x04
    +-------------------------------------------------------------------+
    |      Extended Message Data      |           Message Data          |   2   0x08
    +---------------------------------+---------------------------------+
    |                             Mask Bits                             |   3   0x0C
    +-------------------------------------------------------------------+
    |                           Pending Bits                            |   4   0x10
    +-------------------------------------------------------------------+

    MSI Capability (64 bit with per-vector masking)

    31                                                                  0
    +---------------------------------+----------------+----------------+
    |         Message Control         |    Next Cap    |     Cap ID     |   0   0x00
    +---------------------------------+----------------+----------------+
    |                          Message Address                          |   1   0x04
    +-------------------------------------------------------------------+
    |                       Message Upper Address                       |   2   0x08
    +---------------------------------+---------------------------------+
    |      Extended Message Data      |           Message Data          |   3   0x0C
    +---------------------------------+---------------------------------+
    |                             Mask Bits                             |   4   0x10
    +-------------------------------------------------------------------+
    |                           Pending Bits                            |   5   0x14
    +-------------------------------------------------------------------+
    """
    async def _read_register(self, reg):
        if reg == 0:
            # Message control
            val = bool(self.msi_enable) << 16
            val |= (self.msi_multiple_message_capable & 0x7) << 17
            val |= (self.msi_multiple_message_enable & 0x7) << 20
            val |= bool(self.msi_64bit_address_capable) << 23
            val |= bool(self.msi_per_vector_mask_capable) << 24
            val |= bool(self.msi_extended_message_data_capable) << 25
            val |= bool(self.msi_extended_message_data_enable) << 26
            return val
        elif reg == 1:
            # Message address
            return self.msi_message_address & 0xfffffffc
        elif reg == 2 and self.msi_64bit_address_capable:
            # Message upper address
            return (self.msi_message_address >> 32) & 0xffffffff
        elif reg == (3 if self.msi_64bit_address_capable else 2):
            # Message data
            if self.msi_extended_message_data_capable:
                return self.msi_message_data & 0xffffffff
            else:
                return self.msi_message_data & 0xffff
        elif reg == (4 if self.msi_64bit_address_capable else 3) and self.msi_per_vector_mask_capable:
            # Mask bits
            return self.msi_mask_bits & 0xffffffff
        elif reg == (5 if self.msi_64bit_address_capable else 4) and self.msi_per_vector_mask_capable:
            # Pending bits
            return self.msi_pending_bits & 0xffffffff

    async def _write_register(self, reg, data, mask):
        if reg == 0:
            # Message control
            if mask & 0x4:
                self.msi_enable = bool(data & 1 << 16)
                self.msi_multiple_message_enable = (data >> 20) & 0x7
                if self.msi_extended_message_data_capable:
                    self.msi_extended_message_data_enable = bool(data & 1 << 16)
        elif reg == 1:
            # Message address
            self.msi_message_address = byte_mask_update(self.msi_message_address, mask, data & 0xfffffffc)
        elif reg == 2 and self.msi_64bit_address_capable:
            # Message upper address
            self.msi_message_address = byte_mask_update(self.msi_message_address, mask << 4, data << 32)
        elif reg == (3 if self.msi_64bit_address_capable else 2):
            # Message data
            if self.msi_extended_message_data_capable:
                self.msi_message_data = byte_mask_update(self.msi_message_data, mask, data) & 0xffffffff
            else:
                self.msi_message_data = byte_mask_update(self.msi_message_data, mask & 0x3, data) & 0xffff
        elif reg == (4 if self.msi_64bit_address_capable else 3) and self.msi_per_vector_mask_capable:
            # Mask bits
            self.msi_mask_bits = byte_mask_update(self.msi_mask_bits, mask, data) & 0xffffffff

    async def issue_msi_interrupt(self, number=0, attr=TlpAttr(0), tc=TlpTc.TC0):
        if not self.msi_enable:
            raise Exception("MSI disabled")
        if number < 0 or number >= 2**min(self.msi_multiple_message_enable, self.msi_multiple_message_capable):
            raise ValueError("MSI message number out of range")

        if self.msi_extended_message_data_capable and self.msi_extended_message_data_enable:
            data = self.msi_message_data
        else:
            data = self.msi_message_data & 0xffff

        data = (data & ~(2**self.msi_multiple_message_enable-1)) | number
        await self.parent.mem_write(self.msi_message_address, struct.pack('<L', data), attr=attr, tc=tc)


class MsixCapability(PciCap):
    """Message-signalled interrupt capability"""
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.cap_id = PciCapId.MSIX
        self.length = 3

        # MSI-X Capability Registers
        self.msix_table_size = 0
        self.msix_function_mask = False
        self.msix_enable = False
        self.msix_table_bar_indicator_register = 0
        self.msix_table_offset = 0
        self.msix_pba_bar_indicator_register = 0
        self.msix_pba_offset = 0

    """
    MSI-X Capability

    31                                                                  0
    +---------------------------------+----------------+----------------+
    |         Message Control         |    Next Cap    |     Cap ID     |   0   0x00
    +---------------------------------+----------------+----------+-----+
    |                         Table Offset                        | BIR |   1   0x04
    +-------------------------------------------------------------+-----+
    |                          PBA Offset                         | BIR |   2   0x08
    +-------------------------------------------------------------+-----+
    """
    async def _read_register(self, reg):
        if reg == 0:
            # Message control
            val = (self.msix_table_size & 0x7ff) << 16
            val |= bool(self.msix_function_mask) << 30
            val |= bool(self.msix_enable) << 31
            return val
        elif reg == 1:
            # Table offset and BIR
            val = self.msix_table_bar_indicator_register & 0x7
            val |= self.msix_table_offset & 0xfffffff8
            return val
        elif reg == 2:
            # Pending bit array offset and BIR
            val = self.msix_pba_bar_indicator_register & 0x7
            val |= self.msix_pba_offset & 0xfffffff8
            return val

    async def _write_register(self, reg, data, mask):
        if reg == 0:
            # Message control
            if mask & 0x8:
                self.msix_function_mask = bool(data & 1 << 30)
                self.msix_enable = bool(data & 1 << 31)

    async def issue_msix_interrupt(self, addr, data, attr=TlpAttr(0), tc=TlpTc.TC0):
        if not self.msix_enable:
            raise Exception("MSI-X disabled")

        await self.parent.mem_write(addr, struct.pack('<L', data), attr=attr, tc=tc)



================================================
FILE: cocotbext/pcie/core/caps/pcie.py
================================================
"""

Copyright (c) 2021 Alex Forencich

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

"""

from .common import PciCapId, PciCap
from .common import PciExtCapId, PciExtCap
from ..utils import byte_mask_update


class PcieCapability(PciCap):
    """PCI Express capability"""
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.cap_id = PciCapId.EXP
        self.length = 15

        # PCIe capability registers
        # PCIe capabilities
        self.pcie_capability_version = 2
        self.pcie_device_type = 0
        self.pcie_slot_implemented = False
        self.interrupt_message_number = 0
        # Device capabilities
        self.max_payload_size_supported = 0x5
        self.phantom_functions_supported = 0
        self.extended_tag_supported = True
        self.endpoint_l0s_acceptable_latency = 0x7
        self.endpoint_l1_acceptable_latency = 0x7
        self.role_based_error_reporting = True  # TODO check ECN
        self.captured_slot_power_limit_value = 0
        self.captured_slot_power_limit_scale = 0
        self.function_level_reset_capability = False
        # Device control
        self.correctable_error_reporting_enable = False
        self.non_fatal_error_reporting_enable = False
        self.fatal_error_reporting_enable = False
        self.unsupported_request_reporting_enable = False
        self.enable_relaxed_ordering = True
        self.max_payload_size = 0x0
        self.extended_tag_field_enable = False
        self.phantom_functions_enable = False
        self.aux_power_pm_enable = False
        self.enable_no_snoop = True
        self.max_read_request_size = 0x2
        # Device status
        self.correctable_error_detected = False
        self.nonfatal_error_detected = False
        self.fatal_error_detected = False
        self.unsupported_request_detected = False
        self.aux_power_detected = False
        self.transactions_pending = False
        self.emergency_power_reduction_detected = False
        # Link capabilities
        self.max_link_speed = 0
        self.max_link_width = 0
        self.aspm_support = 0
        self.l0s_exit_latency = 0
        self.l1_exit_latency = 0
        self.clock_power_management = False
        self.surprise_down_error_reporting_capability = False
        self.data_link_layer_link_active_reporting_capable = False
        self.link_bandwidth_notification_capability = False
        self.aspm_optionality_compliance = False
        self.port_number = 0
        # Link control
        self.aspm_control = 0
        self.read_completion_boundary = False
        self.link_disable = False
        self.common_clock_configuration = False
        self.extended_synch = False
        self.enable_clock_power_management = False
        self.hardware_autonomous_width_disable = False
        self.link_bandwidth_management_interrupt_enable = False
        self.link_autonomous_bandwidth_interrupt_enable = False
        self.drs_signalling_control = 0
        # Link status
        self.current_link_speed = 0
        self.negotiated_link_width = 0
        self.link_training = False
        self.slot_clock_configuration = False
        self.data_link_layer_link_active = False
        self.link_bandwidth_management_status = False
        self.link_autonomous_bandwidth_status = False
        # Slot capabilities
        self.attention_button_present = False
        self.power_controller_present = False
        self.mrl_sensor_present = False
        self.attention_indicator_present = False
        self.power_indicator_present = False
        self.hot_plug_surprise = False
        self.hot_plug_capable = False
        self.slot_power_limit_value = 0
        self.slot_power_limit_scale = 0
        self.electromechanical_interlock_present = False
        self.no_command_completed_support = False
        self.physical_slot_number = 0
        # Slot control
        self.attention_button_pressed_enable = False
        self.power_fault_detected_enable = False
        self.mrl_sensor_changed_enable = False
        self.presence_detect_changed_enable = False
        self.command_completed_interrupt_enable = False
        self.hot_plug_interrupt_enable = False
        self.attention_indicator_control = 0
        self.power_indicator_control = 0
        self.power_controller_control = False
        self.electromechanical_interlock_control = False
        self.data_link_layer_state_changed_enable = False
        self.auto_slot_power_limit_disable = False
        # Slot status
        self.attention_button_pressed = False
        self.power_fault_detected = False
        self.mrl_sensor_changed = False
        self.presence_detect_changed = False
        self.command_completed = False
        self.mrl_sensor_state = False
        self.presence_detect_state = False
        self.electromechanical_interlock_status = False
        self.data_link_layer_state_changed = False
        # Root control
        self.system_error_on_correctable_error_enable = False
        self.system_error_on_non_fatal_error_enable = False
        self.system_error_on_fatal_error_enable = False
        self.pme_interrupt_enable = False
        self.crs_software_visibility_enable = False
        # Root capabilities
        self.crs_software_visibility = False
        # Root status
        self.pme_requester_id = 0
        self.pme_status = False
        self.pme_pending = False
        # Device capabilities 2
        self.completion_timeout_ranges_supported = 0
        self.completion_timeout_disable_supported = False
        self.ari_forwarding_supported = False
        self.atomic_op_forwarding_supported = False
        self.atomic_op_32_bit_completer_supported = False
        self.atomic_op_64_bit_completer_supported = False
        self.cas_128_bit_completer_supported = False
        self.no_ro_enabled_pr_pr_passing = False
        self.ltr_mechanism_supported = False
        self.tph_completer_supported = 0
        self.obff_supported = 0
        self.extended_fmt_field_supported = False
        self.end_end_tlp_prefix_supported = False
        self.max_end_end_tlp_prefix = 0
        self.emergency_power_reduction_supported = 0
        self.emergency_power_reduction_initialization_required = False
        self.frs_supported = False
        # Device control 2
        self.completion_timeout_value = 0
        self.completion_timeout_disable = False
        self.ari_forwarding_enable = False
        self.atomic_op_requester_enable = False
        self.atomic_op_egress_blocking = False
        self.ido_request_enable = False
        self.ido_completion_enable = False
        self.ltr_mechanism_enable = False
        self.emergency_power_reduction_request = False
        self.ten_bit_tag_requester_enable = False
        self.obff_enable = 0
        self.end_end_tlp_prefix_blocking = False
        # Device status 2
        # Link capabilities 2
        self.supported_link_speeds = 0
        self.crosslink_supported = False
        self.lower_skp_os_generation_supported_speeds = 0
        self.lower_skp_os_reception_supported_speeds = 0
        self.retimer_presence_detect_supported = False
        self.two_retimers_presence_detect_supported = False
        self.drs_supported = False
        # Link control 2
        self.target_link_speed = 0
        self.enter_compliance = False
        self.hardware_autonomous_speed_disable = False
        self.selectable_deemphasis = False
        self.transmit_margin = 0
        self.enter_modified_compliance = False
        self.compliance_sos = False
        self.compliance_preset_deemphasis = 0
        # Link status 2
        self.current_deemphasis_level = False
        self.equalization_8gt_complete = False
        self.equalization_8gt_phase_1_successful = False
        self.equalization_8gt_phase_2_successful = False
        self.equalization_8gt_phase_3_successful = False
        self.link_equalization_8gt_request = False
        self.retimer_presence_detected = False
        self.two_retimers_presence_detected = False
        self.crosslink_resolution = 0
        self.downstream_component_presence = 0
        self.drs_message_received = False
        # Slot capabilities 2
        # Slot control 2
        # Slot status 2

    """
    PCIe Capability

    31                                                                  0
    +---------------------------------+----------------+----------------+
    |        PCIe Capabilities        |    Next Cap    |    PCIe Cap    |   0   0x00
    +---------------------------------+----------------+----------------+
    |                        Device Capabilities                        |   1   0x04
    +---------------------------------+---------------------------------+
    |          Device Status          |         Device Control          |   2   0x08
    +---------------------------------+---------------------------------+
    |                         Link Capabilities                         |   3   0x0C
    +---------------------------------+---------------------------------+
    |           Link Status           |          Link Control           |   4   0x10
    +---------------------------------+---------------------------------+
    |                         Slot Capabilities                         |   5   0x14
    +---------------------------------+---------------------------------+
    |           Slot Status           |          Slot Control           |   6   0x18
    +---------------------------------+---------------------------------+
    |        Root Capabilities        |          Root Control           |   7   0x1C
    +---------------------------------+---------------------------------+
    |                            Root status                            |   8   0x20
    +-------------------------------------------------------------------+
    |                       Device Capabilities 2                       |   9   0x24
    +---------------------------------+---------------------------------+
    |         Device Status 2         |        Device Control 2         |  10   0x28
    +---------------------------------+---------------------------------+
    |                        Link Capabilities 2                        |  11   0x2C
    +---------------------------------+---------------------------------+
    |          Link Status 2          |         Link Control 2          |  12   0x30
    +---------------------------------+---------------------------------+
    |                        Slot Capabilities 2                        |  13   0x34
    +---------------------------------+---------------------------------+
    |          Slot Status 2          |         Slot Control 2          |  14   0x38
    +---------------------------------+---------------------------------+
    """
    async def _read_register(self, reg):
        if reg == 0:
            # PCIe capabilities
            val = 2 << 16
            val |= (self.pcie_device_type & 0xf) << 20
            val |= bool(self.pcie_slot_implemented) << 24
            val |= (self.interrupt_message_number & 0x1f) << 25
            return val
        elif reg == 1:
            # Device capabilities
            val = self.max_payload_size_supported & 0x7
            val |= (self.phantom_functions_supported & 0x3) << 3
            val |= bool(self.extended_tag_supported) << 5
            val |= (self.endpoint_l0s_acceptable_latency & 0x7) << 6
            val |= (self.endpoint_l1_acceptable_latency & 7) << 9
            val |= bool(self.role_based_error_reporting) << 15
            val |= (self.captured_slot_power_limit_value & 0xff) << 18
            val |= (self.captured_slot_power_limit_scale & 0x3) << 26
            val |= bool(self.function_level_reset_capability) << 28
            return val
        elif reg == 2:
            # Device control
            val = bool(self.correctable_error_reporting_enable) << 0
            val |= bool(self.non_fatal_error_reporting_enable) << 1
            val |= bool(self.fatal_error_reporting_enable) << 2
            val |= bool(self.unsupported_request_reporting_enable) << 3
            val |= bool(self.enable_relaxed_ordering) << 4
            val |= (self.max_payload_size & 0x7) << 5
            val |= bool(self.extended_tag_field_enable) << 8
            val |= bool(self.phantom_functions_enable) << 9
            val |= bool(self.aux_power_pm_enable) << 10
            val |= bool(self.enable_no_snoop) << 11
            val |= (self.max_read_request_size & 0x7) << 12
            # Device status
            val |= bool(self.correctable_error_detected) << 16
            val |= bool(self.nonfatal_error_detected) << 17
            val |= bool(self.fatal_error_detected) << 18
            val |= bool(self.unsupported_request_detected) << 19
            val |= bool(self.aux_power_detected) << 20
            val |= bool(self.transactions_pending) << 21
            val |= bool(self.emergency_power_reduction_detected) << 22
            return val
        elif reg == 3:
            # Link capabilities
            val = self.max_link_speed & 0xf
            val |= (self.max_link_width & 0x3f) >> 4
            val |= (self.aspm_support & 0x3) >> 10
            val |= (self.l0s_exit_latency & 0x7) >> 12
            val |= (self.l1_exit_latency & 0x7) >> 15
            val |= bool(self.clock_power_management) << 18
            val |= bool(self.surprise_down_error_reporting_capability) << 19
            val |= bool(self.data_link_layer_link_active_reporting_capable) << 20
            val |= bool(self.link_bandwidth_notification_capability) << 21
            val |= bool(self.aspm_optionality_compliance) << 22
            val |= (self.port_number & 0xff) << 24
            return val
        elif reg == 4:
            # Link control
            val = self.aspm_control & 0x3
            val |= bool(self.read_completion_boundary) << 3
            val |= bool(self.link_disable) << 4
            val |= bool(self.common_clock_configuration) << 6
            val |= bool(self.extended_synch) << 7
            val |= bool(self.enable_clock_power_management) << 8
            val |= bool(self.hardware_autonomous_width_disable) << 9
            val |= bool(self.link_bandwidth_management_interrupt_enable) << 10
            val |= bool(self.link_autonomous_bandwidth_interrupt_enable) << 11
            val |= (self.drs_signalling_control & 0x3) << 14
            # Link status
            val |= (self.current_link_speed & 0xf) << 16
            val |= (self.negotiated_link_width & 0x3f) << 20
            val |= bool(self.link_training) << 27
            val |= bool(self.slot_clock_configuration) << 28
            val |= bool(self.data_link_layer_link_active) << 29
            val |= bool(self.link_bandwidth_management_status) << 30
            val |= bool(self.link_autonomous_bandwidth_status) << 31
            return val
        elif reg == 5:
            # Slot capabilities
            val = bool(self.attention_button_present)
            val |= bool(self.power_controller_present) << 1
            val |= bool(self.mrl_sensor_present) << 2
            val |= bool(self.attention_indicator_present) << 3
            val |= bool(self.power_indicator_present) << 4
            val |= bool(self.hot_plug_surprise) << 5
            val |= bool(self.hot_plug_capable) << 6
            val |= (self.slot_power_limit_value & 0xff) << 7
            val |= (self.slot_power_limit_scale & 0x3) << 15
            val |= bool(self.electromechanical_interlock_present) << 17
            val |= bool(self.no_command_completed_support) << 18
            val |= (self.physical_slot_number & 0x1fff) << 19
            return val
        elif reg == 6:
            # Slot control
            val = bool(self.attention_button_pressed_enable) << 0
            val |= bool(self.power_fault_detected_enable) << 1
            val |= bool(self.mrl_sensor_changed_enable) << 2
            val |= bool(self.presence_detect_changed_enable) << 3
            val |= bool(self.command_completed_interrupt_enable) << 4
            val |= bool(self.hot_plug_interrupt_enable) << 5
            val |= (self.attention_indicator_control & 0x3) << 6
            val |= (self.power_indicator_control & 0x3) << 8
            val |= bool(self.power_controller_control) << 10
            val |= bool(self.electromechanical_interlock_control) << 11
            val |= bool(self.data_link_layer_state_changed_enable) << 12
            val |= bool(self.auto_slot_power_limit_disable) << 13
            # Slot status
            val |= bool(self.attention_button_pressed) << 16
            val |= bool(self.power_fault_detected) << 17
            val |= bool(self.mrl_sensor_changed) << 18
            val |= bool(self.presence_detect_changed) << 19
            val |= bool(self.command_completed) << 20
            val |= bool(self.mrl_sensor_state) << 21
            val |= bool(self.presence_detect_state) << 22
            val |= bool(self.electromechanical_interlock_status) << 23
            val |= bool(self.data_link_layer_state_changed) << 24
            return val
        elif reg == 7:
            # Root control
            val = bool(self.system_error_on_correctable_error_enable) << 0
            val |= bool(self.system_error_on_non_fatal_error_enable) << 1
            val |= bool(self.system_error_on_fatal_error_enable) << 2
            val |= bool(self.pme_interrupt_enable) << 3
            val |= bool(self.crs_software_visibility_enable) << 4
            # Root capabilities
            val |= bool(self.crs_software_visibility) << 16
            return val
        elif reg == 8:
            # Root status
            val = self.pme_requester_id & 0xffff
            val |= bool(self.pme_status) << 16
            val |= bool(self.pme_pending) << 17
            return val
        elif reg == 9:
            # Device capabilities 2
            val = self.completion_timeout_ranges_supported & 0xf
            val |= bool(self.completion_timeout_disable_supported) << 4
            val |= bool(self.ari_forwarding_supported) << 5
            val |= bool(self.atomic_op_forwarding_supported) << 6
            val |= bool(self.atomic_op_32_bit_completer_supported) << 7
            val |= bool(self.atomic_op_64_bit_completer_supported) << 8
            val |= bool(self.cas_128_bit_completer_supported) << 9
            val |= bool(self.no_ro_enabled_pr_pr_passing) << 10
            val |= bool(self.ltr_mechanism_supported) << 11
            val |= (self.tph_completer_supported & 0x3) << 12
            val |= (self.obff_supported & 0x3) << 18
            val |= bool(self.extended_fmt_field_supported) << 20
            val |= bool(self.end_end_tlp_prefix_supported) << 21
            val |= (self.max_end_end_tlp_prefix & 0x3) << 22
            val |= (self.emergency_power_reduction_supported & 0x3) << 24
            val |= bool(self.emergency_power_reduction_initialization_required) << 26
            val |= bool(self.frs_supported) << 31
            return val
        elif reg == 10:
            # Device control 2
            val = self.completion_timeout_value & 0xf
            val |= bool(self.completion_timeout_disable) << 4
            val |= bool(self.ari_forwarding_enable) << 5
            val |= bool(self.atomic_op_requester_enable) << 6
            val |= bool(self.atomic_op_egress_blocking) << 7
            val |= bool(self.ido_request_enable) << 8
            val |= bool(self.ido_completion_enable) << 9
            val |= bool(self.ltr_mechanism_enable) << 10
            val |= bool(self.emergency_power_reduction_request) << 11
            val |= bool(self.ten_bit_tag_requester_enable) << 12
            val |= (self.obff_enable & 0x3) << 13
            val |= bool(self.end_end_tlp_prefix_blocking) << 15
            # Device status 2
            return val
        elif reg == 11:
            # Link capabilities 2
            val = (self.supported_link_speeds & 0x7f) << 1
            val |= bool(self.crosslink_supported) << 8
            val |= (self.lower_skp_os_generation_supported_speeds & 0x7f) << 9
            val |= (self.lower_skp_os_reception_supported_speeds & 0x7f) << 16
            val |= bool(self.retimer_presence_detect_supported) << 23
            val |= bool(self.two_retimers_presence_detect_supported) << 24
            val |= bool(self.drs_supported) << 31
            return val
        elif reg == 12:
            # Link control 2
            val = self.target_link_speed & 0xf
            val |= bool(self.enter_compliance) << 4
            val |= bool(self.hardware_autonomous_speed_disable) << 5
            val |= bool(self.selectable_deemphasis) << 6
            val |= (self.transmit_margin & 0x7) << 7
            val |= bool(self.enter_modified_compliance) << 10
            val |= bool(self.compliance_sos) << 11
            val |= (self.compliance_preset_deemphasis & 0xf) << 12
            # Link status 2
            val |= bool(self.current_deemphasis_level) << 16
            val |= bool(self.equalization_8gt_complete) << 17
            val |= bool(self.equalization_8gt_phase_1_successful) << 18
            val |= bool(self.equalization_8gt_phase_2_successful) << 19
            val |= bool(self.equalization_8gt_phase_3_successful) << 20
            val |= bool(self.link_equalization_8gt_request) << 21
            val |= bool(self.retimer_presence_detected) << 22
            val |= bool(self.two_retimers_presence_detected) << 23
            val |= (self.crosslink_resolution & 0x3) << 24
            val |= (self.downstream_component_presence & 0x7) << 27
            val |= bool(self.drs_message_received) << 31
            return val
        else:
            return 0

    async def _write_register(self, reg, data, mask):
        if reg == 2:
            # Device control
            if mask & 0x1:
                self.correctable_error_reporting_enable = bool(data & 1 << 0)
                self.non_fatal_error_reporting_enable = bool(data & 1 << 1)
                self.fatal_error_reporting_enable = bool(data & 1 << 2)
                self.unsupported_request_reporting_enable = bool(data & 1 << 3)
                self.enable_relaxed_ordering = bool(data & 1 << 4)
                self.max_payload_size = (data >> 5) & 0x7
            if mask & 0x2:
                self.extended_tag_field_enable = bool(data & 1 << 8)
                self.phantom_functions_enable = bool(data & 1 << 9)
                self.aux_power_pm_enable = bool(data & 1 << 10)
                self.enable_no_snoop = bool(data & 1 << 11)
                self.max_read_request_size = (data >> 12) & 0x7
                if data & 1 << 15:
                    await self.initiate_function_level_reset()
            # Device status
            if mask & 0x4:
                if data & 1 << 16:
                    self.correctable_error_detected = False
                if data & 1 << 17:
                    self.nonfatal_error_detected = False
                if data & 1 << 18:
                    self.fatal_error_detected = False
                if data & 1 << 19:
                    self.unsupported_request_detected = False
                if data & 1 << 22:
                    self.emergency_power_reduction_detected = False
        elif reg == 4:
            # Link control
            if mask & 0x1:
                self.aspm_control = data & 3
                self.read_completion_boundary = bool(data & 1 << 3)
                self.link_disable = bool(data & 1 << 4)
                if data & 1 << 5:
                    await self.initiate_retrain_link()
                self.common_clock_configuration = bool(data & 1 << 6)
                self.extended_synch = bool(data & 1 << 7)
            if mask & 0x2:
                self.enable_clock_power_management = bool(data & 1 << 8)
                self.hardware_autonomous_width_disable = bool(data & 1 << 9)
                self.link_bandwidth_management_interrupt_enable = bool(data & 1 << 10)
                self.link_autonomous_bandwidth_interrupt_enable = bool(data & 1 << 11)
                self.drs_signalling_control = (data >> 14) & 0x3
            # Link status
            if mask & 0x8:
                if data & 1 << 30:
                    self.link_bandwidth_management_status = False
                if data & 1 << 31:
                    self.link_autonomous_bandwidth_status = False
        elif reg == 6:
            # Slot control
            if mask & 0x1:
                self.attention_button_pressed_enable = bool(data & 1 << 0)
                self.power_fault_detected_enable = bool(data & 1 << 1)
                self.mrl_sensor_changed_enable = bool(data & 1 << 2)
                self.presence_detect_changed_enable = bool(data & 1 << 3)
                self.command_completed_interrupt_enable = bool(data & 1 << 4)
                self.hot_plug_interrupt_enable = bool(data & 1 << 5)
                self.attention_indicator_control = (data >> 6) & 0x3
            if mask & 0x2:
                self.power_indicator_control = (data >> 8) & 0x3
                self.power_controller_control = bool(data & 1 << 10)
                self.electromechanical_interlock_control = bool(data & 1 << 11)
                self.data_link_layer_state_changed_enable = bool(data & 1 << 12)
                self.auto_slot_power_limit_disable = bool(data & 1 << 13)
            # Slot status
            if mask & 0x4:
                if data & 1 << 16:
                    self.attention_button_pressed = False
                if data & 1 << 17:
                    self.power_fault_detected = False
                if data & 1 << 18:
                    self.mrl_sensor_changed = False
                if data & 1 << 19:
                    self.presence_detect_changed = False
                if data & 1 << 20:
                    self.command_completed = False
                if data & 1 << 24:
                    self.data_link_layer_state_changed = False
        elif reg == 7:
            # Root control
            if mask & 0x1:
                self.system_error_on_correctable_error_enable = bool(data & 1 << 0)
                self.system_error_on_non_fatal_error_enable = bool(data & 1 << 1)
                self.system_error_on_fatal_error_enable = bool(data & 1 << 2)
                self.pme_interrupt_enable = bool(data & 1 << 3)
                self.crs_software_visibility_enable = bool(data & 1 << 4)
        elif reg == 8:
            # Root status
            if mask & 0x4:
                if data & 1 << 16:
                    self.pme_status = False
        elif reg == 10:
            # Device control 2
            if mask & 0x1:
                self.completion_timeout_value = data & 0xf
                self.completion_timeout_disable = bool(data & 1 << 4)
                self.ari_forwarding_enable = bool(data & 1 << 5)
                self.atomic_op_requester_enable = bool(data & 1 << 6)
                self.atomic_op_egress_blocking = bool(data & 1 << 7)
            if mask & 0x2:
                self.ido_request_enable = bool(data & 1 << 8)
                self.ido_completion_enable = bool(data & 1 << 9)
                self.ltr_mechanism_enable = bool(data & 1 << 10)
                self.emergency_power_reduction_request = bool(data & 1 << 11)
                self.ten_bit_tag_requester_enable = bool(data & 1 << 12)
                self.obff_enable = (data >> 13) & 0x3
                self.end_end_tlp_prefix_blocking = bool(data & 1 << 15)
            # Device status 2
        elif reg == 12:
            # Link control 2
            if mask & 0x1:
                self.target_link_speed = data & 0xf
                self.enter_compliance = bool(data & 1 << 4)
                self.hardware_autonomous_speed_disable = bool(data & 1 << 5)
                self.transmit_margin = self.transmit_margin & 0x6 | (data >> 7) & 0x1
            if mask & 0x2:
                self.transmit_margin = self.transmit_margin & 0x1 | (data >> 7) & 0x6
                self.enter_modified_compliance = bool(data & 1 << 10)
                self.compliance_sos = bool(data & 1 << 11)
                self.compliance_preset_deemphasis = (data >> 12) & 0xff
            # Link status 2
            if mask & 0x4:
                self.link_equalization_8gt_request = bool(data & 1 << 21)
                if data & 1 << 31:
                    self.drs_message_received = False

    async def initiate_function_level_reset(self):
        pass

    async def initiate_retrain_link(self):
        pass


class PcieExtendedCapability(PciExtCap):
    """Secondary PCI Express extended capability"""
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.cap_id = PciExtCapId.EXP2
        self.cap_ver = 1
        self.length = 4

        # Secondary PCIe extended capability registers
        # Link control 3 register
        self.perform_equalization = False
        self.link_equalization_request_interrupt_enable = False
        self.enable_lower_skp_os_generation = 0
        # Lane error status
        self.lane_error_status = 0
        self.downstream_port_8gt_transmitter_preset = [0]*32
        self.downstream_port_8gt_receiver_preset_hint = [0]*32
        self.upstream_port_8gt_transmitter_preset = [0]*32
        self.upstream_port_8gt_receiver_preset_hint = [0]*32

    """
    Secondary PCIe Extended Capability

    31                                                                  0
    +-------------------------+-------+---------------------------------+
    |     Next Cap Offset     |  Ver  |         PCIe Ext Cap ID         |   0   0x00
    +-------------------------+-------+---------------------------------+
    |                          Link Control 3                           |   1   0x04
    +-------------------------------------------------------------------+
    |                         Lane Error Status                         |   2   0x08
    +-------------------------------------------------------------------+
    |                     Lane Equalization Control                     |   3   0x0C
    +-------------------------------------------------------------------+
    """
    async def _read_register(self, reg):
        if reg == 1:
            # Link Control 3
            val = bool(self.perform_equalization)
            val |= bool(self.link_equalization_request_interrupt_enable) << 1
            val |= (self.enable_lower_skp_os_generation & 0x7f) << 9
            return val
        elif reg == 2:
            # Lane Error Status
            return self.lane_error_status & 0xffffffff
        elif reg < 18:
            # Lane equalization control
            val = self.downstream_port_8gt_transmitter_preset[(reg-2)*2] & 0xf
            val |= (self.downstream_port_8gt_receiver_preset_hint[(reg-2)*2] & 0x7) << 4
            val |= (self.upstream_port_8gt_transmitter_preset[(reg-2)*2] & 0xf) << 8
            val |= (self.upstream_port_8gt_receiver_preset_hint[(reg-2)*2] & 0x7) << 12
            val |= (self.downstream_port_8gt_transmitter_preset[(reg-2)*2+1] & 0xf) << 16
            val |= (self.downstream_port_8gt_receiver_preset_hint[(reg-2)*2+1] & 0x7) << 20
            val |= (self.upstream_port_8gt_transmitter_preset[(reg-2)*2+1] & 0xf) << 24
            val |= (self.upstream_port_8gt_receiver_preset_hint[(reg-2)*2+1] & 0x7) << 28
            return val
        else:
            return 0

    async def _write_register(self, reg, data, mask):
        if reg == 1:
            # Link Control 3
            if mask & 0x1:
                self.perform_equalization = bool(data & 1 << 0)
                self.link_equalization_request_interrupt_enable = bool(data & 1 << 1)
            if mask & 0x2:
                self.enable_lower_skp_os_generation = (data >> 9) & 0x7f
        elif reg == 2:
            # Lane Error Status
            self.lane_error_status = byte_mask_update(self.lane_error_status, mask, self.lane_error_status & ~data) & 0xffffffff



================================================
FILE: cocotbext/pcie/core/caps/pm.py
================================================
"""

Copyright (c) 2021 Alex Forencich

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

"""

from .common import PciCapId, PciCap


class PmCapability(PciCap):
    """Power Management capability"""
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.cap_id = PciCapId.PM
        self.length = 2

        # Power management capability registers
        # Power management capabilities
        self.version = 3
        self.pme_clock = False
        self.immediate_readiness_on_return_to_d0 = False
        self.device_specific_initialization = False
        self.aux_current = False
        self.d1_support = False
        self.d2_support = False
        self.pme_support = 0
        # Power management control/status
        self.power_state = 0
        self.no_soft_reset = False
        self.pme_enable = False
        self.data_select = 0
        self.data_scale = 0
        self.pme_status = False
        # PM data
        self.pm_data = 0

    """
    PCI Power Management Capability

    31                                                                  0
    +---------------------------------+----------------+----------------+
    |         PM Capabilities         |    Next Cap    |     PM Cap     |   0   0x00
    +----------------+----------------+----------------+----------------+
    |    PM Data     |                |        PM Control/Status        |   1   0x04
    +----------------+----------------+---------------------------------+
    """
    async def _read_register(self, reg):
        if reg == 0:
            # Power management capabilities
            val = 3 << 16
            val |= bool(self.pme_clock) << 19
            val |= bool(self.immediate_readiness_on_return_to_d0) << 20
            val |= bool(self.device_specific_initialization) << 21
            val |= (self.aux_current & 0x7) << 22
            val |= bool(self.d1_support) << 25
            val |= bool(self.d2_support) << 26
            val |= (self.pme_support & 0x1f) << 27
            return val
        elif reg == 1:
            # Power management control/status
            val = self.power_state & 0x3
            val |= bool(self.no_soft_reset) << 3
            val |= bool(self.pme_enable) << 8
            val |= (self.data_select & 0xf) << 9
            val |= (self.data_scale & 0x3) << 13
            val |= bool(self.pme_status) << 15
            # PM data
            val |= (self.pm_data & 0xff) << 24
            return val
        else:
            return 0

    async def _write_register(self, reg, data, mask):
        if reg == 1:
            # Power management control/status
            if mask & 0x1:
                self.power_state = data & 0x3
            if mask & 0x2:
                self.pme_enable = bool(data & 1 << 8)
                self.data_select = (data >> 9) & 0xf
                self.data_scale = (data >> 13) & 0x3
                if data & 1 << 15:
                    self.pme_status = False



================================================
FILE: cocotbext/pcie/intel/ptile/__init__.py
================================================
"""

Copyright (c) 2022 Alex Forencich

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

"""

from .ptile_model import PTilePcieDevice, PTilePcieFunction
from .interface import PTileRxBus, PTileTxBus



================================================
FILE: cocotbext/pcie/intel/ptile/interface.py
================================================
"""

Copyright (c) 2022 Alex Forencich

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

"""

import logging
import struct

import cocotb
from cocotb.queue import Queue, QueueFull
from cocotb.triggers import RisingEdge, Timer, First, Event
from cocotb_bus.bus import Bus

from cocotbext.pcie.core.tlp import Tlp


class BaseBus(Bus):

    _signals = ["data"]
    _optional_signals = []

    def __init__(self, entity=None, prefix=None, **kwargs):
        super().__init__(entity, prefix, self._signals, optional_signals=self._optional_signals, **kwargs)

    @classmethod
    def from_entity(cls, entity, **kwargs):
        return cls(entity, **kwargs)

    @classmethod
    def from_prefix(cls, entity, prefix, **kwargs):
        return cls(entity, prefix, **kwargs)


class PTileTxBus(BaseBus):
    _signals = ["data", "sop", "eop", "valid", "ready", "err", "hdr", "tlp_prfx"]
    _optional_signals = ["data_par", "hdr_par", "tlp_prfx_par"]


class PTileRxBus(BaseBus):
    _signals = ["data", "empty", "sop", "eop", "valid", "ready", "hdr", "tlp_prfx", "bar_range", "tlp_abort"]
    _optional_signals = ["vf_active", "func_num", "vf_num", "data_par", "hdr_par", "tlp_prfx_par"]


def dword_parity(d):
    d ^= d >> 4
    d ^= d >> 2
    d ^= d >> 1
    p = d & 0x1
    if d & 0x100:
        p |= 0x2
    if d & 0x10000:
        p |= 0x4
    if d & 0x1000000:
        p |= 0x8
    return p


def parity(d):
    d ^= d >> 4
    d ^= d >> 2
    d ^= d >> 1
    b = 0x1
    p = 0
    while d:
        if d & 0x1:
            p |= b
        d >>= 8
        b <<= 1
    return p


class PTilePcieFrame:
    def __init__(self, frame=None):
        self.tlp_prfx = 0
        self.hdr = 0
        self.data = []
        self.tlp_prfx_par = 0
        self.hdr_par = 0
        self.parity = []
        self.func_num = 0
        self.vf_num = None
        self.bar_range = 0
        self.tlp_abort = 0
        self.err = 0

        if isinstance(frame, Tlp):
            hdr = frame.pack_header().ljust(16, b'\x00')
            self.hdr = int.from_bytes(hdr, 'big')

            data = frame.get_data()
            for k in range(0, len(data), 4):
                self.data.extend(struct.unpack_from('<L', data, k))

            self.update_parity()

        elif isinstance(frame, PTilePcieFrame):
            self.tlp_prfx = frame.tlp_prfx
            self.hdr = frame.hdr
            self.data = list(frame.data)
            self.tlp_prfx_par = frame.tlp_prfx_par
            self.hdr_par = frame.hdr_par
            self.parity = list(frame.parity)
            self.func_num = frame.func_num
            self.vf_num = frame.vf_num
            self.bar_range = frame.bar_range
            self.tlp_abort = frame.tlp_abort
            self.err = frame.err

    @classmethod
    def from_tlp(cls, tlp):
        return cls(tlp)

    def to_tlp(self):
        tlp = Tlp.unpack_header(self.hdr.to_bytes(16, 'big'))

        for dw in self.data:
            tlp.data.extend(struct.pack('<L', dw))

        return tlp

    def update_parity(self):
        self.parity = [dword_parity(d) ^ 0xf for d in self.data]
        self.hdr_par = parity(self.hdr)
        self.tlp_prfx_par = dword_parity(self.tlp_prfx)

    def check_parity(self):
        return (
            self.parity == [dword_parity(d) ^ 0xf for d in self.data] and
            self.hdr_par == parity(self.hdr) and
            self.tlp_prfx_par == dword_parity(self.tlp_prfx)
        )

    def __eq__(self, other):
        if isinstance(other, PTilePcieFrame):
            return (
                self.tlp_prfx == other.tlp_prfx and
                self.hdr == other.hdr and
                self.data == other.data and
                self.tlp_prfx_par == other.tlp_prfx_par and
                self.hdr_par == other.hdr_par and
                self.parity == other.parity and
                self.func_num == other.func_num and
                self.vf_num == other.vf_num and
                self.bar_range == other.bar_range and
                self.tlp_abort == other.tlp_abort and
                self.err == other.err
            )
        return False

    def __repr__(self):
        return (
            f"{type(self).__name__}(tlp_prfx={self.tlp_prfx:#010x}, hdr={self.hdr:#034x}, "
            f"data=[{', '.join(f'{x:#010x}' for x in self.data)}], "
            f"tlp_prfx_par={self.tlp_prfx_par:#x}, hdr_par={self.hdr_par:#06x}, "
            f"parity=[{', '.join(hex(x) for x in self.parity)}], "
            f"func_num={self.func_num}, "
            f"vf_num={self.vf_num}, "
            f"bar_range={self.bar_range}, "
            f"tlp_abort={self.tlp_abort}, "
            f"err={self.err})"
        )

    def __len__(self):
        return len(self.data)


class PTilePcieTransaction:

    __slots__ = ("data", "empty", "sop", "eop", "valid", "err", "hdr", "tlp_prfx",
        "vf_active", "func_num", "vf_num", "bar_range", "tlp_abort", "data_par", "hdr_par", "tlp_prfx_par")

    def __init__(self, *args, **kwargs):
        for sig in self.__slots__:
            if sig in kwargs:
                setattr(self, sig, kwargs[sig])
                del kwargs[sig]
            else:
                setattr(self, sig, 0)

        super().__init__(*args, **kwargs)

    def __repr__(self):
        return f"{type(self).__name__}({', '.join(f'{s}={int(getattr(self, s))}' for s in self.__slots__)})"


class PTilePcieBase:

    _signal_widths = {"ready": 1}

    _valid_signal = "valid"
    _ready_signal = "ready"

    _transaction_obj = PTilePcieTransaction
    _frame_obj = PTilePcieFrame

    def __init__(self, bus, clock, reset=None, ready_latency=0, *args, **kwargs):
        self.bus = bus
        self.clock = clock
        self.reset = reset
        self.ready_latency = ready_latency
        if bus._name:
            self.log = logging.getLogger(f"cocotb.{bus._entity._name}.{bus._name}")
        else:
            self.log = logging.getLogger(f"cocotb.{bus._entity._name}")

        super().__init__(*args, **kwargs)

        self.active = False
        self.queue = Queue()
        self.dequeue_event = Event()
        self.idle_event = Event()
        self.idle_event.set()
        self.active_event = Event()

        self.pause = False
        self._pause_generator = None
        self._pause_cr = None

        self.queue_occupancy_bytes = 0
        self.queue_occupancy_frames = 0

        self.width = len(self.bus.data)
        self.byte_size = 32
        self.byte_lanes = self.width // self.byte_size
        self.byte_mask = 2**self.byte_size-1

        self.seg_count = len(self.bus.valid)
        self.seg_width = self.width // self.seg_count
        self.seg_mask = 2**self.seg_width-1
        self.seg_par_width = self.seg_width // 8
        self.seg_par_mask = 2**self.seg_par_width-1
        self.seg_byte_lanes = self.byte_lanes // self.seg_count
        self.seg_empty_width = (self.seg_byte_lanes-1).bit_length()
        self.seg_empty_mask = 2**self.seg_empty_width-1

        assert self.width in {128, 256, 512}

        assert len(self.bus.data) == self.seg_count*self.seg_width
        assert len(self.bus.sop) == self.seg_count
        assert len(self.bus.eop) == self.seg_count
        assert len(self.bus.valid) == self.seg_count
        assert len(self.bus.hdr) == self.seg_count*128
        assert len(self.bus.tlp_prfx) == self.seg_count*32

        if hasattr(self.bus, "empty"):
            assert len(self.bus.empty) == self.seg_count*self.seg_empty_width

        if hasattr(self.bus, "err"):
            assert len(self.bus.err) == self.seg_count
        if hasattr(self.bus, "bar_range"):
            assert len(self.bus.bar_range) == self.seg_count*3
        if hasattr(self.bus, "tlp_abort"):
            assert len(self.bus.tlp_abort) == self.seg_count

        if hasattr(self.bus, "vf_active"):
            assert len(self.bus.vf_active) == self.seg_count
        if hasattr(self.bus, "func_num"):
            assert len(self.bus.func_num) == self.seg_count*3
        if hasattr(self.bus, "vf_num"):
            assert len(self.bus.vf_num) == self.seg_count*11

        if hasattr(self.bus, "data_par"):
            assert len(self.bus.data_par) == self.seg_count*self.seg_width//8
        if hasattr(self.bus, "hdr_par"):
            assert len(self.bus.hdr_par) == self.seg_count*128//8
        if hasattr(self.bus, "tlp_prfx_par"):
            assert len(self.bus.tlp_prfx_par) == self.seg_count*32//8

    def count(self):
        return self.queue.qsize()

    def empty(self):
        return self.queue.empty()

    def clear(self):
        while not self.queue.empty():
            self.queue.get_nowait()
        self.idle_event.set()
        self.active_event.clear()

    def idle(self):
        raise NotImplementedError()

    async def wait(self):
        raise NotImplementedError()

    def set_pause_generator(self, generator=None):
        if self._pause_cr is not None:
            self._pause_cr.kill()
            self._pause_cr = None

        self._pause_generator = generator

        if self._pause_generator is not None:
            self._pause_cr = cocotb.start_soon(self._run_pause())

    def clear_pause_generator(self):
        self.set_pause_generator(None)

    async def _run_pause(self):
        clock_edge_event = RisingEdge(self.clock)

        for val in self._pause_generator:
            self.pause = val
            await clock_edge_event


class PTilePcieSource(PTilePcieBase):

    _signal_widths = {"valid": 1, "ready": 1}

    _valid_signal = "valid"
    _ready_signal = "ready"

    _transaction_obj = PTilePcieTransaction
    _frame_obj = PTilePcieFrame

    def __init__(self, bus, clock, reset=None, ready_latency=0, *args, **kwargs):
        super().__init__(bus, clock, reset, ready_latency, *args, **kwargs)

        self.drive_obj = None
        self.drive_sync = Event()

        self.queue_occupancy_limit_bytes = -1
        self.queue_occupancy_limit_frames = -1

        self.bus.data.setimmediatevalue(0)
        self.bus.sop.setimmediatevalue(0)
        self.bus.eop.setimmediatevalue(0)
        self.bus.valid.setimmediatevalue(0)
        self.bus.hdr.setimmediatevalue(0)
        self.bus.tlp_prfx.setimmediatevalue(0)

        if hasattr(self.bus, "empty"):
            self.bus.empty.setimmediatevalue(0)

        if hasattr(self.bus, "err"):
            self.bus.err.setimmediatevalue(0)
        if hasattr(self.bus, "bar_range"):
            self.bus.bar_range.setimmediatevalue(0)
        if hasattr(self.bus, "tlp_abort"):
            self.bus.tlp_abort.setimmediatevalue(0)

        if hasattr(self.bus, "vf_active"):
            self.bus.vf_active.setimmediatevalue(0)
        if hasattr(self.bus, "func_num"):
            self.bus.func_num.setimmediatevalue(0)
        if hasattr(self.bus, "vf_num"):
            self.bus.vf_num.setimmediatevalue(0)

        if hasattr(self.bus, "data_par"):
            self.bus.data_par.setimmediatevalue(0)
        if hasattr(self.bus, "hdr_par"):
            self.bus.hdr_par.setimmediatevalue(0)
        if hasattr(self.bus, "tlp_prfx_par"):
            self.bus.tlp_prfx_par.setimmediatevalue(0)

        cocotb.start_soon(self._run_source())
        cocotb.start_soon(self._run())

    async def _drive(self, obj):
        if self.drive_obj is not None:
            self.drive_sync.clear()
            await self.drive_sync.wait()

        self.drive_obj = obj

    async def send(self, frame):
        while self.full():
            self.dequeue_event.clear()
            await self.dequeue_event.wait()
        frame = PTilePcieFrame(frame)
        await self.queue.put(frame)
        self.idle_event.clear()
        self.queue_occupancy_bytes += len(frame)
        self.queue_occupancy_frames += 1

    def send_nowait(self, frame):
        if self.full():
            raise QueueFull()
        frame = PTilePcieFrame(frame)
        self.queue.put_nowait(frame)
        self.idle_event.clear()
        self.queue_occupancy_bytes += len(frame)
        self.queue_occupancy_frames += 1

    def full(self):
        if self.queue_occupancy_limit_bytes > 0 and self.queue_occupancy_bytes > self.queue_occupancy_limit_bytes:
            return True
        elif self.queue_occupancy_limit_frames > 0 and self.queue_occupancy_frames > self.queue_occupancy_limit_frames:
            return True
        else:
            return False

    def idle(self):
        return self.empty() and not self.active

    async def wait(self):
        await self.idle_event.wait()

    async def _run_source(self):
        self.active = False
        ready_delay = []

        clock_edge_event = RisingEdge(self.clock)

        while True:
            await clock_edge_event

            # read handshake signals
            ready_sample = self.bus.ready.value
            valid_sample = self.bus.valid.value

            if self.reset is not None and self.reset.value:
                self.active = False
                self.bus.valid.value = 0
                continue

            # ready delay
            if self.ready_latency > 1:
                if len(ready_delay) != (self.ready_latency-1):
                    ready_delay = [0]*(self.ready_latency-1)
                ready_delay.append(ready_sample)
                ready_sample = ready_delay.pop(0)

            if (ready_sample and valid_sample) or not valid_sample or self.ready_latency > 0:
                if self.drive_obj and not self.pause and (ready_sample or self.ready_latency == 0):
                    self.bus.drive(self.drive_obj)
                    self.drive_obj = None
                    self.drive_sync.set()
                    self.active = True
                else:
                    self.bus.valid.value = 0
                    self.active = bool(self.drive_obj)
                    if not self.drive_obj:
                        self.idle_event.set()

    async def _run(self):
        while True:
            frame = await self._get_frame()
            frame_offset = 0
            self.log.info("TX frame: %r", frame)
            first = True

            while frame is not None:
                transaction = self._transaction_obj()

                for seg in range(self.seg_count):
                    if frame is None:
                        if not self.empty():
                            frame = self._get_frame_nowait()
                            frame_offset = 0
                            self.log.info("TX frame: %r", frame)
                            first = True
                        else:
                            break

                    if first:
                        first = False

                        transaction.valid |= 1 << seg
                        transaction.sop |= 1 << seg
                        transaction.hdr |= frame.hdr << seg*128
                        transaction.tlp_prfx |= frame.tlp_prfx << seg*32
                        transaction.hdr_par |= frame.hdr_par << seg*16
                        transaction.tlp_prfx_par |= frame.tlp_prfx_par << seg*4

                    transaction.bar_range |= frame.bar_range << seg*3
                    transaction.func_num |= frame.func_num << seg*3
                    if frame.vf_num is not None:
                        transaction.vf_active |= 1 << seg
                        transaction.vf_num |= frame.vf_num << seg*11
                    transaction.err |= frame.err << seg

                    empty = 0
                    if frame.data:
                        transaction.valid |= 1 << seg

                        for k in range(min(self.seg_byte_lanes, len(frame.data)-frame_offset)):
                            transaction.data |= frame.data[frame_offset] << 32*(k+seg*self.seg_byte_lanes)
                            transaction.data_par |= frame.parity[frame_offset] << 4*(k+seg*self.seg_byte_lanes)
                            empty = self.seg_byte_lanes-1-k
                            frame_offset += 1

                    if frame_offset >= len(frame.data):
                        transaction.eop |= 1 << seg
                        transaction.empty |= empty << seg*self.seg_empty_width

                        frame = None

                await self._drive(transaction)

    async def _get_frame(self):
        frame = await self.queue.get()
        self.dequeue_event.set()
        self.queue_occupancy_bytes -= len(frame)
        self.queue_occupancy_frames -= 1
        return frame

    def _get_frame_nowait(self):
        frame = self.queue.get_nowait()
        self.dequeue_event.set()
        self.queue_occupancy_bytes -= len(frame)
        self.queue_occupancy_frames -= 1
        return frame


class PTilePcieSink(PTilePcieBase):

    _signal_widths = {"valid": 1, "ready": 1}

    _valid_signal = "valid"
    _ready_signal = "ready"

    _transaction_obj = PTilePcieTransaction
    _frame_obj = PTilePcieFrame

    def __init__(self, bus, clock, reset=None, ready_latency=0, *args, **kwargs):
        super().__init__(bus, clock, reset, ready_latency, *args, **kwargs)

        self.sample_obj = None
        self.sample_sync = Event()

        self.queue_occupancy_limit_bytes = -1
        self.queue_occupancy_limit_frames = -1

        self.bus.ready.setimmediatevalue(0)

        cocotb.start_soon(self._run_sink())
        cocotb.start_soon(self._run())

    def _recv(self, frame):
        if self.queue.empty():
            self.active_event.clear()
        self.queue_occupancy_bytes -= len(frame)
        self.queue_occupancy_frames -= 1
        return frame

    async def recv(self):
        frame = await self.queue.get()
        return self._recv(frame)

    def recv_nowait(self):
        frame = self.queue.get_nowait()
        return self._recv(frame)

    def full(self):
        if self.queue_occupancy_limit_bytes > 0 and self.queue_occupancy_bytes > self.queue_occupancy_limit_bytes:
            return True
        elif self.queue_occupancy_limit_frames > 0 and self.queue_occupancy_frames > self.queue_occupancy_limit_frames:
            return True
        else:
            return False

    def idle(self):
        return not self.active

    async def wait(self, timeout=0, timeout_unit='ns'):
        if not self.empty():
            return
        if timeout:
            await First(self.active_event.wait(), Timer(timeout, timeout_unit))
        else:
            await self.active_event.wait()

    async def _run_sink(self):
        ready_delay = []

        clock_edge_event = RisingEdge(self.clock)

        while True:
            await clock_edge_event

            # read handshake signals
            ready_sample = self.bus.ready.value
            valid_sample = self.bus.valid.value

            if self.reset is not None and self.reset.value:
                self.bus.ready.value = 0
                continue

            # ready delay
            if self.ready_latency > 0:
                if len(ready_delay) != self.ready_latency:
                    ready_delay = [0]*self.ready_latency
                ready_delay.append(ready_sample)
                ready_sample = ready_delay.pop(0)

            if valid_sample and ready_sample:
                self.sample_obj = self._transaction_obj()
                self.bus.sample(self.sample_obj)
                self.sample_sync.set()
            elif self.ready_latency > 0:
                assert not valid_sample, "handshake error: valid asserted outside of ready cycle"

            self.bus.ready.value = (not self.full() and not self.pause)

    async def _run(self):
        self.active = False
        frame = None
        dword_count = 0

        while True:
            while not self.sample_obj:
                self.sample_sync.clear()
                await self.sample_sync.wait()

            self.active = True
            sample = self.sample_obj
            self.sample_obj = None

            for seg in range(self.seg_count):
                if not sample.valid & (1 << seg):
                    continue

                if sample.sop & (1 << seg):
                    assert frame is None, "framing error: sop asserted in frame"
                    frame = PTilePcieFrame()

                    frame.tlp_prfx = (sample.tlp_prfx >> (seg*32)) & 0xffffffff
                    frame.tlp_prfx_par = (sample.tlp_prfx_par >> (seg*4)) & 0xf
                    frame.hdr = (sample.hdr >> (seg*128)) & (2**128-1)
                    frame.hdr_par = (sample.hdr_par >> (seg*16)) & 0xffff
                    if frame.hdr & (1 << 126):
                        dword_count = (frame.hdr >> 96) & 0x3ff
                        if dword_count == 0:
                            dword_count = 1024
                    else:
                        dword_count = 0

                    frame.bar_range = (sample.bar_range >> seg*3) & 0x7
                    frame.func_num = (sample.func_num >> seg*3) & 0x7
                    if sample.vf_active & (1 << seg):
                        frame.vf_num = (sample.vf_num >> seg*11) & 0x7ff
                    frame.err = (sample.err >> seg) & 0x1

                assert frame is not None, "framing error: data transferred outside of frame"

                if dword_count > 0:
                    data = (sample.data >> (seg*self.seg_width)) & self.seg_mask
                    data_par = (sample.data_par >> (seg*self.seg_par_width)) & self.seg_par_mask
                    for k in range(min(self.seg_byte_lanes, dword_count)):
                        frame.data.append((data >> 32*k) & 0xffffffff)
                        frame.parity.append((data_par >> 4*k) & 0xf)
                        dword_count -= 1

                if sample.eop & (1 << seg):
                    assert dword_count == 0, "framing error: incorrect length or early eop"
                    self.log.info("RX frame: %r", frame)
                    self._sink_frame(frame)
                    self.active = False
                    frame = None

    def _sink_frame(self, frame):
        self.queue_occupancy_bytes += len(frame)
        self.queue_occupancy_frames += 1

        self.queue.put_nowait(frame)
        self.active_event.set()



================================================
FILE: cocotbext/pcie/intel/ptile/ptile_model.py
================================================
"""

Copyright (c) 2022 Alex Forencich

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

"""

import cocotb
from cocotb.clock import Clock
from cocotb.queue import Queue
from cocotb.triggers import RisingEdge, FallingEdge, Timer, First

from cocotbext.pcie.core import Device, Endpoint, __version__
from cocotbext.pcie.core.caps import MsiCapability, MsixCapability
from cocotbext.pcie.core.caps import AerExtendedCapability, PcieExtendedCapability
from cocotbext.pcie.core.utils import PcieId
from cocotbext.pcie.core.tlp import Tlp, TlpType

from .interface import PTilePcieFrame, PTilePcieSource, PTilePcieSink


valid_configs = [
    # speed, links, width, freq
    (3,  4, 128, 250.0e6),
    (3,  8, 256, 250.0e6),
    (3, 16, 256, 250.0e6),
    (3, 16, 512, 250.0e6),
    (4,  4, 128, 350.0e6),
    (4,  4, 128, 400.0e6),
    (4,  4, 128, 450.0e6),
    (4,  4, 128, 500.0e6),
    (4,  8, 256, 175.0e6),
    (4,  8, 256, 200.0e6),
    (4,  8, 256, 225.0e6),
    (4,  8, 256, 250.0e6),
    (4,  8, 256, 350.0e6),
    (4,  8, 256, 400.0e6),
    (4,  8, 256, 450.0e6),
    (4,  8, 256, 500.0e6),
    (4,  8, 512, 175.0e6),
    (4,  8, 512, 200.0e6),
    (4,  8, 512, 225.0e6),
    (4,  8, 512, 250.0e6),
    (4, 16, 512, 175.0e6),
    (4, 16, 512, 200.0e6),
    (4, 16, 512, 225.0e6),
    (4, 16, 512, 250.0e6),
    (4, 16, 512, 350.0e6),
    (4, 16, 512, 400.0e6),
    (4, 16, 512, 450.0e6),
    (4, 16, 512, 500.0e6),
]


class PTilePcieFunction(Endpoint):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        # PCIe capabilities
        self.register_capability(self.pm_cap, offset=0x10)

        self.msi_cap = MsiCapability()
        self.msi_cap.msi_64bit_address_capable = 1
        self.msi_cap.msi_per_vector_mask_capable = 0
        self.register_capability(self.msi_cap, offset=0x14)

        self.msix_cap = MsixCapability()
        self.register_capability(self.msix_cap, offset=0x1c)

        self.register_capability(self.pcie_cap, offset=0x2c)

        # PCIe extended capabilities
        self.aer_ext_cap = AerExtendedCapability()
        self.register_capability(self.aer_ext_cap, offset=0x40)

        # VC 0x52
        # ARI 0x5e

        self.pcie_ext_cap = PcieExtendedCapability()
        self.register_capability(self.pcie_ext_cap, offset=0x62)

        # PHY16 0x6e
        # LM 0x7a
        # SRIOV 0x8c
        # TPH 0x9c
        # ATS 0xbf
        # ACS 0xc3
        # PRS 0xc6
        # LTR 0xcb
        # PASID 0xcc
        # VSEC (RAS D.E.S.) 0xce
        # DL 0x11c
        # VSEC (Intel) 0x340


def init_signal(sig, width=None, initval=None):
    if sig is None:
        return None
    if width is not None:
        assert len(sig) == width
    if initval is not None:
        sig.setimmediatevalue(initval)
    return sig


class PTilePcieDevice(Device):
    def __init__(self,
            # configuration options
            port_num=0,
            pcie_generation=None,
            pcie_link_width=None,
            pld_clk_frequency=None,
            pf_count=1,
            max_payload_size=128,
            enable_extended_tag=False,

            pf0_msi_enable=False,
            pf0_msi_count=1,
            pf1_msi_enable=False,
            pf1_msi_count=1,
            pf2_msi_enable=False,
            pf2_msi_count=1,
            pf3_msi_enable=False,
            pf3_msi_count=1,
            pf0_msix_enable=False,
            pf0_msix_table_size=0,
            pf0_msix_table_bir=0,
            pf0_msix_table_offset=0x00000000,
            pf0_msix_pba_bir=0,
            pf0_msix_pba_offset=0x00000000,
            pf1_msix_enable=False,
            pf1_msix_table_size=0,
            pf1_msix_table_bir=0,
            pf1_msix_table_offset=0x00000000,
            pf1_msix_pba_bir=0,
            pf1_msix_pba_offset=0x00000000,
            pf2_msix_enable=False,
            pf2_msix_table_size=0,
            pf2_msix_table_bir=0,
            pf2_msix_table_offset=0x00000000,
            pf2_msix_pba_bir=0,
            pf2_msix_pba_offset=0x00000000,
            pf3_msix_enable=False,
            pf3_msix_table_size=0,
            pf3_msix_table_bir=0,
            pf3_msix_table_offset=0x00000000,
            pf3_msix_pba_bir=0,
            pf3_msix_pba_offset=0x00000000,

            # signals
            # Clock and reset
            reset_status=None,
            reset_status_n=None,
            coreclkout_hip=None,
            refclk0=None,
            refclk1=None,
            pin_perst_n=None,

            # RX interface
            rx_bus=None,
            rx_par_err=None,

            # TX interface
            tx_bus=None,
            tx_par_err=None,

            # RX flow control
            rx_buffer_limit=None,
            rx_buffer_limit_tdm_idx=None,

            # TX flow control
            tx_cdts_limit=None,
            tx_cdts_limit_tdm_idx=None,

            # Power management and hard IP status interface
            link_up=None,
            dl_up=None,
            surprise_down_err=None,
            ltssm_state=None,
            pm_state=None,
            pm_dstate=None,
            apps_pm_xmt_pme=None,
            app_req_retry_en=None,

            # Interrupt interface
            app_int=None,
            msi_pnd_func=None,
            msi_pnd_byte=None,
            msi_pnd_addr=None,

            # Error interface
            serr_out=None,
            hip_enter_err_mode=None,
            app_err_valid=None,
            app_err_hdr=None,
            app_err_info=None,
            app_err_func_num=None,

            # Completion timeout interface
            cpl_timeout=None,
            cpl_timeout_avmm_clk=None,
            cpl_timeout_avmm_address=None,
            cpl_timeout_avmm_read=None,
            cpl_timeout_avmm_readdata=None,
            cpl_timeout_avmm_readdatavalid=None,
            cpl_timeout_avmm_write=None,
            cpl_timeout_avmm_writedata=None,
            cpl_timeout_avmm_waitrequest=None,

            # Configuration output
            tl_cfg_func=None,
            tl_cfg_add=None,
            tl_cfg_ctl=None,
            dl_timer_update=None,

            # Configuration intercept interface
            cii_req=None,
            cii_hdr_poisoned=None,
            cii_hdr_first_be=None,
            cii_func_num=None,
            cii_wr_vf_active=None,
            cii_vf_num=None,
            cii_wr=None,
            cii_addr=None,
            cii_dout=None,
            cii_override_en=None,
            cii_override_din=None,
            cii_halt=None,

            # Hard IP reconfiguration interface
            hip_reconfig_clk=None,
            hip_reconfig_address=None,
            hip_reconfig_read=None,
            hip_reconfig_readdata=None,
            hip_reconfig_readdatavalid=None,
            hip_reconfig_write=None,
            hip_reconfig_writedata=None,
            hip_reconfig_waitrequest=None,

            # Page request service
            prs_event_valid=None,
            prs_event_func=None,
            prs_event=None,

            # SR-IOV (VF error)
            vf_err_ur_posted_s0=None,
            vf_err_ur_posted_s1=None,
            vf_err_ur_posted_s2=None,
            vf_err_ur_posted_s3=None,
            vf_err_func_num_s0=None,
            vf_err_func_num_s1=None,
            vf_err_func_num_s2=None,
            vf_err_func_num_s3=None,
            vf_err_ca_postedreq_s0=None,
            vf_err_ca_postedreq_s1=None,
            vf_err_ca_postedreq_s2=None,
            vf_err_ca_postedreq_s3=None,
            vf_err_vf_num_s0=None,
            vf_err_vf_num_s1=None,
            vf_err_vf_num_s2=None,
            vf_err_vf_num_s3=None,
            vf_err_poisonedwrreq_s0=None,
            vf_err_poisonedwrreq_s1=None,
            vf_err_poisonedwrreq_s2=None,
            vf_err_poisonedwrreq_s3=None,
            vf_err_poisonedcompl_s0=None,
            vf_err_poisonedcompl_s1=None,
            vf_err_poisonedcompl_s2=None,
            vf_err_poisonedcompl_s3=None,
            user_vfnonfatalmsg_func_num=None,
            user_vfnonfatalmsg_vfnum=None,
            user_sent_vfnonfatalmsg=None,
            vf_err_overflow=None,

            # FLR
            flr_rcvd_pf=None,
            flr_rcvd_vf=None,
            flr_rcvd_pf_num=None,
            flr_rcvd_vf_num=None,
            flr_completed_pf=None,
            flr_completed_vf=None,
            flr_completed_pf_num=None,
            flr_completed_vf_num=None,

            # VirtIO
            virtio_pcicfg_vfaccess=None,
            virtio_pcicfg_vfnum=None,
            virtio_pcicfg_pfnum=None,
            virtio_pcicfg_bar=None,
            virtio_pcicfg_length=None,
            virtio_pcicfg_baroffset=None,
            virtio_pcicfg_cfgdata=None,
            virtio_pcicfg_cfgwr=None,
            virtio_pcicfg_cfgrd=None,
            virtio_pcicfg_appvfnum=None,
            virtio_pcicfg_apppfnum=None,
            virtio_pcicfg_rdack=None,
            virtio_pcicfg_rdbe=None,
            virtio_pcicfg_data=None,

            *args, **kwargs):

        super().__init__(*args, **kwargs)

        self.log.info("Intel P-tile PCIe hard IP core model")
        self.log.info("cocotbext-pcie version %s", __version__)
        self.log.info("Copyright (c) 2022 Alex Forencich")
        self.log.info("https://github.com/alexforencich/cocotbext-pcie")

        self.default_function = PTilePcieFunction

        self.dw = None

        self.rx_queue = Queue()

        if port_num == 0:
            # UG lists 1144 CPLH and 1444 "256 bit" CPLD
            # Tests confirm >=1024 CPLH and >=2888 CPLD
            self.rx_buf_cplh_fc_limit = 1144
            self.rx_buf_cpld_fc_limit = 1444 * 2
        elif port_num == 1:
            self.rx_buf_cplh_fc_limit = 572
            self.rx_buf_cpld_fc_limit = 1444
        else:
            self.rx_buf_cplh_fc_limit = 286
            self.rx_buf_cpld_fc_limit = 1444 // 2

        self.rx_buf_cplh_fc_count = 0
        self.rx_buf_cpld_fc_count = 0

        # configuration options
        self.port_num = port_num
        self.pcie_generation = pcie_generation
        self.pcie_link_width = pcie_link_width
        self.pld_clk_frequency = pld_clk_frequency
        self.pf_count = pf_count
        self.max_payload_size = max_payload_size
        self.enable_extended_tag = enable_extended_tag

        self.pf0_msi_enable = pf0_msi_enable
        self.pf0_msi_count = pf0_msi_count
        self.pf1_msi_enable = pf1_msi_enable
        self.pf1_msi_count = pf1_msi_count
        self.pf2_msi_enable = pf2_msi_enable
        self.pf2_msi_count = pf2_msi_count
        self.pf3_msi_enable = pf3_msi_enable
        self.pf3_msi_count = pf3_msi_count
        self.pf0_msix_enable = pf0_msix_enable
        self.pf0_msix_table_size = pf0_msix_table_size
        self.pf0_msix_table_bir = pf0_msix_table_bir
        self.pf0_msix_table_offset = pf0_msix_table_offset
        self.pf0_msix_pba_bir = pf0_msix_pba_bir
        self.pf0_msix_pba_offset = pf0_msix_pba_offset
        self.pf1_msix_enable = pf1_msix_enable
        self.pf1_msix_table_size = pf1_msix_table_size
        self.pf1_msix_table_bir = pf1_msix_table_bir
        self.pf1_msix_table_offset = pf1_msix_table_offset
        self.pf1_msix_pba_bir = pf1_msix_pba_bir
        self.pf1_msix_pba_offset = pf1_msix_pba_offset
        self.pf2_msix_enable = pf2_msix_enable
        self.pf2_msix_table_size = pf2_msix_table_size
        self.pf2_msix_table_bir = pf2_msix_table_bir
        self.pf2_msix_table_offset = pf2_msix_table_offset
        self.pf2_msix_pba_bir = pf2_msix_pba_bir
        self.pf2_msix_pba_offset = pf2_msix_pba_offset
        self.pf3_msix_enable = pf3_msix_enable
        self.pf3_msix_table_size = pf3_msix_table_size
        self.pf3_msix_table_bir = pf3_msix_table_bir
        self.pf3_msix_table_offset = pf3_msix_table_offset
        self.pf3_msix_pba_bir = pf3_msix_pba_bir
        self.pf3_msix_pba_offset = pf3_msix_pba_offset

        # signals

        # Clock and reset
        self.reset_status = init_signal(reset_status, 1, 0)
        self.reset_status_n = init_signal(reset_status_n, 1, 0)
        self.coreclkout_hip = init_signal(coreclkout_hip, 1, 0)
        self.refclk0 = init_signal(refclk0, 1)
        self.refclk1 = init_signal(refclk1, 1)
        self.pin_perst_n = init_signal(pin_perst_n, 1)

        # RX interface
        self.rx_source = None
        self.rx_par_err = init_signal(rx_par_err, 1, 0)

        if rx_bus is not None:
            self.rx_source = PTilePcieSource(rx_bus, self.coreclkout_hip)
            self.rx_source.queue_occupancy_limit_frames = 2
            self.rx_source.ready_latency = 27
            self.dw = self.rx_source.width

        # TX interface
        self.tx_sink = None
        self.tx_par_err = init_signal(tx_par_err, 1, 0)

        if tx_bus is not None:
            self.tx_sink = PTilePcieSink(tx_bus, self.coreclkout_hip)
            self.tx_sink.queue_occupancy_limit_frames = 2
            self.tx_sink.ready_latency = 3
            self.dw = self.tx_sink.width

        # RX flow control
        self.rx_buffer_limit = init_signal(rx_buffer_limit, 12)
        self.rx_buffer_limit_tdm_idx = init_signal(rx_buffer_limit_tdm_idx, 2)

        # TX flow control
        self.tx_cdts_limit = init_signal(tx_cdts_limit, 16, 0)
        self.tx_cdts_limit_tdm_idx = init_signal(tx_cdts_limit_tdm_idx, 3, 0)

        # Power management and hard IP status interface
        self.link_up = init_signal(link_up, 1, 0)
        self.dl_up = init_signal(dl_up, 1, 0)
        self.surprise_down_err = init_signal(surprise_down_err, 1, 0)
        self.ltssm_state = init_signal(ltssm_state, 6, 0)
        self.pm_state = init_signal(pm_state, 3, 0)
        self.pm_dstate = init_signal(pm_dstate, 32, 0)
        self.apps_pm_xmt_pme = init_signal(apps_pm_xmt_pme, 8)
        self.app_req_retry_en = init_signal(app_req_retry_en, 8)

        # Interrupt interface
        self.app_int = init_signal(app_int, 8)
        self.msi_pnd_func = init_signal(msi_pnd_func, 3, 0)
        self.msi_pnd_byte = init_signal(msi_pnd_byte, 8, 0)
        self.msi_pnd_addr = init_signal(msi_pnd_addr, 2, 0)

        # Error interface
        self.serr_out = init_signal(serr_out, 1, 0)
        self.hip_enter_err_mode = init_signal(hip_enter_err_mode, 1, 0)
        self.app_err_valid = init_signal(app_err_valid, 1)
        self.app_err_hdr = init_signal(app_err_hdr, 32)
        self.app_err_info = init_signal(app_err_info, 13)
        self.app_err_func_num = init_signal(app_err_func_num, 3)

        # Completion timeout interface
        self.cpl_timeout = init_signal(cpl_timeout, 1, 0)
        self.cpl_timeout_avmm_clk = init_signal(cpl_timeout_avmm_clk, 1)
        self.cpl_timeout_avmm_address = init_signal(cpl_timeout_avmm_address, 3)
        self.cpl_timeout_avmm_read = init_signal(cpl_timeout_avmm_read, 1)
        self.cpl_timeout_avmm_readdata = init_signal(cpl_timeout_avmm_readdata, 8, 0)
        self.cpl_timeout_avmm_readdatavalid = init_signal(cpl_timeout_avmm_readdatavalid, 1, 0)
        self.cpl_timeout_avmm_write = init_signal(cpl_timeout_avmm_write, 1)
        self.cpl_timeout_avmm_writedata = init_signal(cpl_timeout_avmm_writedata, 8)
        self.cpl_timeout_avmm_waitrequest = init_signal(cpl_timeout_avmm_waitrequest, 1, 0)

        # Configuration output
        self.tl_cfg_func = init_signal(tl_cfg_func, 3, 0)
        self.tl_cfg_add = init_signal(tl_cfg_add, 5, 0)
        self.tl_cfg_ctl = init_signal(tl_cfg_ctl, 16, 0)
        self.dl_timer_update = init_signal(dl_timer_update, 1, 0)

        # Configuration intercept interface
        self.cii_req = init_signal(cii_req, 1, 0)
        self.cii_hdr_poisoned = init_signal(cii_hdr_poisoned, 1, 0)
        self.cii_hdr_first_be = init_signal(cii_hdr_first_be, 4, 0)
        self.cii_func_num = init_signal(cii_func_num, 3, 0)
        self.cii_wr_vf_active = init_signal(cii_wr_vf_active, 1, 0)
        self.cii_vf_num = init_signal(cii_vf_num, 11, 0)
        self.cii_wr = init_signal(cii_wr, 1, 0)
        self.cii_addr = init_signal(cii_addr, 10, 0)
        self.cii_dout = init_signal(cii_dout, 32, 0)
        self.cii_override_en = init_signal(cii_override_en, 1)
        self.cii_override_din = init_signal(cii_override_din, 32)
        self.cii_halt = init_signal(cii_halt, 1)

        # Hard IP reconfiguration interface
        self.hip_reconfig_clk = init_signal(hip_reconfig_clk, 1)
        self.hip_reconfig_address = init_signal(hip_reconfig_address, 21)
        self.hip_reconfig_read = init_signal(hip_reconfig_read, 1)
        self.hip_reconfig_readdata = init_signal(hip_reconfig_readdata, 8, 0)
        self.hip_reconfig_readdatavalid = init_signal(hip_reconfig_readdatavalid, 1, 0)
        self.hip_reconfig_write = init_signal(hip_reconfig_write, 1)
        self.hip_reconfig_writedata = init_signal(hip_reconfig_writedata, 8)
        self.hip_reconfig_waitrequest = init_signal(hip_reconfig_waitrequest, 1, 0)

        # Page request service
        self.prs_event_valid = init_signal(prs_event_valid, 1)
        self.prs_event_func = init_signal(prs_event_func, 3)
        self.prs_event = init_signal(prs_event, 2)

        # SR-IOV (VF error)
        self.vf_err_ur_posted_s0 = init_signal(vf_err_ur_posted_s0, 1, 0)
        self.vf_err_ur_posted_s1 = init_signal(vf_err_ur_posted_s1, 1, 0)
        self.vf_err_ur_posted_s2 = init_signal(vf_err_ur_posted_s2, 1, 0)
        self.vf_err_ur_posted_s3 = init_signal(vf_err_ur_posted_s3, 1, 0)
        self.vf_err_func_num_s0 = init_signal(vf_err_func_num_s0, 3, 0)
        self.vf_err_func_num_s1 = init_signal(vf_err_func_num_s1, 3, 0)
        self.vf_err_func_num_s2 = init_signal(vf_err_func_num_s2, 3, 0)
        self.vf_err_func_num_s3 = init_signal(vf_err_func_num_s3, 3, 0)
        self.vf_err_ca_postedreq_s0 = init_signal(vf_err_ca_postedreq_s0, 1, 0)
        self.vf_err_ca_postedreq_s1 = init_signal(vf_err_ca_postedreq_s1, 1, 0)
        self.vf_err_ca_postedreq_s2 = init_signal(vf_err_ca_postedreq_s2, 1, 0)
        self.vf_err_ca_postedreq_s3 = init_signal(vf_err_ca_postedreq_s3, 1, 0)
        self.vf_err_vf_num_s0 = init_signal(vf_err_vf_num_s0, 11, 0)
        self.vf_err_vf_num_s1 = init_signal(vf_err_vf_num_s1, 11, 0)
        self.vf_err_vf_num_s2 = init_signal(vf_err_vf_num_s2, 11, 0)
        self.vf_err_vf_num_s3 = init_signal(vf_err_vf_num_s3, 11, 0)
        self.vf_err_poisonedwrreq_s0 = init_signal(vf_err_poisonedwrreq_s0, 1, 0)
        self.vf_err_poisonedwrreq_s1 = init_signal(vf_err_poisonedwrreq_s1, 1, 0)
        self.vf_err_poisonedwrreq_s2 = init_signal(vf_err_poisonedwrreq_s2, 1, 0)
        self.vf_err_poisonedwrreq_s3 = init_signal(vf_err_poisonedwrreq_s3, 1, 0)
        self.vf_err_poisonedcompl_s0 = init_signal(vf_err_poisonedcompl_s0, 1, 0)
        self.vf_err_poisonedcompl_s1 = init_signal(vf_err_poisonedcompl_s1, 1, 0)
        self.vf_err_poisonedcompl_s2 = init_signal(vf_err_poisonedcompl_s2, 1, 0)
        self.vf_err_poisonedcompl_s3 = init_signal(vf_err_poisonedcompl_s3, 1, 0)
        self.user_vfnonfatalmsg_func_num = init_signal(user_vfnonfatalmsg_func_num, 3)
        self.user_vfnonfatalmsg_vfnum = init_signal(user_vfnonfatalmsg_vfnum, 11)
        self.user_sent_vfnonfatalmsg = init_signal(user_sent_vfnonfatalmsg, 1)
        self.vf_err_overflow = init_signal(vf_err_overflow, 1, 0)

        # FLR
        self.flr_rcvd_pf = init_signal(flr_rcvd_pf, 8, 0)
        self.flr_rcvd_vf = init_signal(flr_rcvd_vf, 1, 0)
        self.flr_rcvd_pf_num = init_signal(flr_rcvd_pf_num, 3, 0)
        self.flr_rcvd_vf_num = init_signal(flr_rcvd_vf_num, 11, 0)
        self.flr_completed_pf = init_signal(flr_completed_pf, 8)
        self.flr_completed_vf = init_signal(flr_completed_vf, 1)
        self.flr_completed_pf_num = init_signal(flr_completed_pf_num, 3)
        self.flr_completed_vf_num = init_signal(flr_completed_vf_num, 11)

        # VirtIO
        self.virtio_pcicfg_vfaccess = init_signal(virtio_pcicfg_vfaccess, 1, 0)
        self.virtio_pcicfg_vfnum = init_signal(virtio_pcicfg_vfnum, 11, 0)
        self.virtio_pcicfg_pfnum = init_signal(virtio_pcicfg_pfnum, 3, 0)
        self.virtio_pcicfg_bar = init_signal(virtio_pcicfg_bar, 8, 0)
        self.virtio_pcicfg_length = init_signal(virtio_pcicfg_length, 32, 0)
        self.virtio_pcicfg_baroffset = init_signal(virtio_pcicfg_baroffset, 32, 0)
        self.virtio_pcicfg_cfgdata = init_signal(virtio_pcicfg_cfgdata, 32, 0)
        self.virtio_pcicfg_cfgwr = init_signal(virtio_pcicfg_cfgwr, 1, 0)
        self.virtio_pcicfg_cfgrd = init_signal(virtio_pcicfg_cfgrd, 1, 0)
        self.virtio_pcicfg_appvfnum = init_signal(virtio_pcicfg_appvfnum, 11)
        self.virtio_pcicfg_apppfnum = init_signal(virtio_pcicfg_apppfnum, 3)
        self.virtio_pcicfg_rdack = init_signal(virtio_pcicfg_rdack, 1)
        self.virtio_pcicfg_rdbe = init_signal(virtio_pcicfg_rdbe, 4)
        self.virtio_pcicfg_data = init_signal(virtio_pcicfg_data, 32)

        # validate parameters
        assert self.dw in {128, 256, 512}

        # rescale clock frequency
        if self.pld_clk_frequency is not None and self.pld_clk_frequency < 1e6:
            self.pld_clk_frequency *= 1e6

        if not self.pcie_generation or not self.pcie_link_width or not self.pld_clk_frequency:
            self.log.info("Incomplete configuration specified, attempting to select reasonable options")
            # guess some reasonable values for unspecified parameters
            for config in reversed(valid_configs):
                # find configuration matching specified parameters
                if self.pcie_generation is not None and self.pcie_generation != config[0]:
                    continue
                if self.pcie_link_width is not None and self.pcie_link_width != config[1]:
                    continue
                if self.dw != config[2]:
                    continue
                if self.pld_clk_frequency is not None and self.pld_clk_frequency != config[3]:
                    continue

                if self.pcie_link_width is not None:
                    if self.port_num == 1 and config[1] > 8:
                        # port 1 only supports x4 and x8
                        continue
                    if self.port_num >= 2 and config[1] > 4:
                        # ports 2 and 3 only supports x4
                        continue

                # set the unspecified parameters
                if self.pcie_generation is None:
                    self.log.info("Setting PCIe speed to gen %d", config[0])
                    self.pcie_generation = config[0]
                if self.pcie_link_width is None:
                    self.log.info("Setting PCIe link width to x%d", config[1])
                    self.pcie_link_width = config[1]
                if self.pld_clk_frequency is None:
                    self.log.info("Setting user clock frequency to %d MHz", config[3]/1e6)
                    self.pld_clk_frequency = config[3]
                break

        self.log.info("Intel P-tile PCIe hard IP core configuration:")
        self.log.info("  PCIe speed: gen %d", self.pcie_generation)
        self.log.info("  PCIe link width: x%d", self.pcie_link_width)
        self.log.info("  PLD clock frequency: %d MHz", self.pld_clk_frequency/1e6)
        self.log.info("  PF count: %d", self.pf_count)
        self.log.info("  Max payload size: %d", self.max_payload_size)
        self.log.info("  Enable extended tag: %s", self.enable_extended_tag)
        self.log.info("  P-tile port number: %d", self.port_num)
        self.log.info("  Enable PF0 MSI: %s", self.pf0_msi_enable)
        self.log.info("  PF0 MSI vector count: %d", self.pf0_msi_count)
        self.log.info("  Enable PF1 MSI: %s", self.pf1_msi_enable)
        self.log.info("  PF1 MSI vector count: %d", self.pf1_msi_count)
        self.log.info("  Enable PF2 MSI: %s", self.pf2_msi_enable)
        self.log.info("  PF2 MSI vector count: %d", self.pf2_msi_count)
        self.log.info("  Enable PF3 MSI: %s", self.pf3_msi_enable)
        self.log.info("  PF3 MSI vector count: %d", self.pf3_msi_count)
        self.log.info("  Enable PF0 MSIX: %s", self.pf0_msix_enable)
        self.log.info("  PF0 MSIX table size: %d", self.pf0_msix_table_size)
        self.log.info("  PF0 MSIX table BIR: %d", self.pf0_msix_table_bir)
        self.log.info("  PF0 MSIX table offset: 0x%08x", self.pf0_msix_table_offset)
        self.log.info("  PF0 MSIX PBA BIR: %d", self.pf0_msix_pba_bir)
        self.log.info("  PF0 MSIX PBA offset: 0x%08x", self.pf0_msix_pba_offset)
        self.log.info("  Enable PF1 MSIX: %s", self.pf1_msix_enable)
        self.log.info("  PF1 MSIX table size: %d", self.pf1_msix_table_size)
        self.log.info("  PF1 MSIX table BIR: %d", self.pf1_msix_table_bir)
        self.log.info("  PF1 MSIX table offset: 0x%08x", self.pf1_msix_table_offset)
        self.log.info("  PF1 MSIX PBA BIR: %d", self.pf1_msix_pba_bir)
        self.log.info("  PF1 MSIX PBA offset: 0x%08x", self.pf1_msix_pba_offset)
        self.log.info("  Enable PF2 MSIX: %s", self.pf2_msix_enable)
        self.log.info("  PF2 MSIX table size: %d", self.pf2_msix_table_size)
        self.log.info("  PF2 MSIX table BIR: %d", self.pf2_msix_table_bir)
        self.log.info("  PF2 MSIX table offset: 0x%08x", self.pf2_msix_table_offset)
        self.log.info("  PF2 MSIX PBA BIR: %d", self.pf2_msix_pba_bir)
        self.log.info("  PF2 MSIX PBA offset: 0x%08x", self.pf2_msix_pba_offset)
        self.log.info("  Enable PF3 MSIX: %s", self.pf3_msix_enable)
        self.log.info("  PF3 MSIX table size: %d", self.pf3_msix_table_size)
        self.log.info("  PF3 MSIX table BIR: %d", self.pf3_msix_table_bir)
        self.log.info("  PF3 MSIX table offset: 0x%08x", self.pf3_msix_table_offset)
        self.log.info("  PF3 MSIX PBA BIR: %d", self.pf3_msix_pba_bir)
        self.log.info("  PF3 MSIX PBA offset: 0x%08x", self.pf3_msix_pba_offset)

        assert self.pcie_generation in {3, 4}
        assert self.pcie_link_width in {4, 8, 16}
        assert self.pld_clk_frequency in {175e6, 200e6, 225e6, 250e6, 350e6, 400e6, 450e6, 500e6}

        # check for valid configuration
        config_valid = False
        for config in valid_configs:
            if self.pcie_generation != config[0]:
                continue
            if self.pcie_link_width != config[1]:
                continue
            if self.dw != config[2]:
                continue
            if self.pld_clk_frequency != config[3]:
                continue

            if self.port_num == 1 and config[1] > 8:
                # port 1 only supports x4 and x8
                continue
            if self.port_num >= 2 and config[1] > 4:
                # ports 2 and 3 only supports x4
                continue

            config_valid = True
            break

        assert config_valid, "link speed/link width/clock speed/interface width setting combination not valid"

        # configure port
        self.upstream_port.max_link_speed = self.pcie_generation
        self.upstream_port.max_link_width = self.pcie_link_width

        # configure functions

        self.make_function()

        if self.pf0_msi_enable:
            self.functions[0].msi_cap.msi_multiple_message_capable = (self.pf0_msi_count-1).bit_length()
        else:
            self.functions[0].deregister_capability(self.functions[0].msi_cap)

        if self.pf0_msix_enable:
            self.functions[0].msix_cap.msix_table_size = self.pf0_msix_table_size
            self.functions[0].msix_cap.msix_table_bar_indicator_register = self.pf0_msix_table_bir
            self.functions[0].msix_cap.msix_table_offset = self.pf0_msix_table_offset
            self.functions[0].msix_cap.msix_pba_bar_indicator_register = self.pf0_msix_pba_bir
            self.functions[0].msix_cap.msix_pba_offset = self.pf0_msix_pba_offset
        else:
            self.functions[0].deregister_capability(self.functions[0].msix_cap)

        if self.pf_count > 1:
            self.make_function()

            if self.pf1_msi_enable:
                self.functions[1].msi_cap.msi_multiple_message_capable = (self.pf1_msi_count-1).bit_length()
            else:
                self.functions[1].deregister_capability(self.functions[1].msi_cap)

            if self.pf1_msix_enable:
                self.functions[1].msix_cap.msix_table_size = self.pf1_msix_table_size
                self.functions[1].msix_cap.msix_table_bar_indicator_register = self.pf1_msix_table_bir
                self.functions[1].msix_cap.msix_table_offset = self.pf1_msix_table_offset
                self.functions[1].msix_cap.msix_pba_bar_indicator_register = self.pf1_msix_pba_bir
                self.functions[1].msix_cap.msix_pba_offset = self.pf1_msix_pba_offset
            else:
                self.functions[1].deregister_capability(self.functions[1].msix_cap)

        if self.pf_count > 2:
            self.make_function()

            if self.pf2_msi_enable:
                self.functions[2].msi_cap.msi_multiple_message_capable = (self.pf2_msi_count-1).bit_length()
            else:
                self.functions[2].deregister_capability(self.functions[2].msi_cap)

            if self.pf2_msix_enable:
                self.functions[2].msix_cap.msix_table_size = self.pf2_msix_table_size
                self.functions[2].msix_cap.msix_table_bar_indicator_register = self.pf2_msix_table_bir
                self.functions[2].msix_cap.msix_table_offset = self.pf2_msix_table_offset
                self.functions[2].msix_cap.msix_pba_bar_indicator_register = self.pf2_msix_pba_bir
                self.functions[2].msix_cap.msix_pba_offset = self.pf2_msix_pba_offset
            else:
                self.functions[2].deregister_capability(self.functions[2].msix_cap)

        if self.pf_count > 3:
            self.make_function()

            if self.pf3_msi_enable:
                self.functions[3].msi_cap.msi_multiple_message_capable = (self.pf3_msi_count-1).bit_length()
            else:
                self.functions[3].deregister_capability(self.functions[3].msi_cap)

            if self.pf3_msix_enable:
                self.functions[3].msix_cap.msix_table_size = self.pf3_msix_table_size
                self.functions[3].msix_cap.msix_table_bar_indicator_register = self.pf3_msix_table_bir
                self.functions[3].msix_cap.msix_table_offset = self.pf3_msix_table_offset
                self.functions[3].msix_cap.msix_pba_bar_indicator_register = self.pf3_msix_pba_bir
                self.functions[3].msix_cap.msix_pba_offset = self.pf3_msix_pba_offset
            else:
                self.functions[3].deregister_capability(self.functions[3].msix_cap)

        for f in self.functions:
            f.pcie_cap.max_payload_size_supported = (self.max_payload_size//128-1).bit_length()
            f.pcie_cap.extended_tag_supported = self.enable_extended_tag

        # fork coroutines

        if self.coreclkout_hip is not None:
            cocotb.start_soon(Clock(self.coreclkout_hip, int(1e9/self.pld_clk_frequency), units="ns").start())

        if self.rx_source:
            cocotb.start_soon(self._run_rx_logic())
        if self.tx_sink:
            cocotb.start_soon(self._run_tx_logic())
        if self.tx_cdts_limit:
            cocotb.start_soon(self._run_tx_fc_logic())
        if self.tl_cfg_ctl:
            cocotb.start_soon(self._run_cfg_out_logic())

        cocotb.start_soon(self._run_reset())

    async def upstream_recv(self, tlp):
        self.log.debug("Got downstream TLP: %r", tlp)

        if tlp.fmt_type in {TlpType.CFG_READ_0, TlpType.CFG_WRITE_0}:
            # config type 0

            # capture address information
            self.bus_num = tlp.completer_id.bus

            # pass TLP to function
            for f in self.functions:
                if f.pcie_id == tlp.completer_id:
                    await f.upstream_recv(tlp)
                    return

            tlp.release_fc()

            self.log.warning("Function not found: failed to route config type 0 TLP: %r", tlp)
        elif tlp.fmt_type in {TlpType.CFG_READ_1, TlpType.CFG_WRITE_1}:
            # config type 1

            tlp.release_fc()

            self.log.warning("Malformed TLP: endpoint received config type 1 TLP: %r", tlp)
        elif tlp.fmt_type in {TlpType.CPL, TlpType.CPL_DATA, TlpType.CPL_LOCKED, TlpType.CPL_LOCKED_DATA}:
            # Completion

            for f in self.functions:
                if f.pcie_id == tlp.requester_id:

                    frame = PTilePcieFrame.from_tlp(tlp)

                    frame.func_num = tlp.requester_id.function

                    # check and track buffer occupancy
                    data_fc = tlp.get_data_credits()

                    if self.rx_buf_cplh_fc_count+1 <= self.rx_buf_cplh_fc_limit and self.rx_buf_cpld_fc_count+data_fc <= self.rx_buf_cpld_fc_limit:
                        self.rx_buf_cplh_fc_count += 1
                        self.rx_buf_cpld_fc_count += data_fc
                        await self.rx_queue.put((tlp, frame))
                    else:
                        self.log.warning("No space in RX completion buffer, dropping TLP: CPLH %d (limit %d), CPLD %d (limit %d)",
                            self.rx_buf_cplh_fc_count, self.rx_buf_cplh_fc_limit, self.rx_buf_cpld_fc_count, self.rx_buf_cpld_fc_limit)

                    tlp.release_fc()

                    return

            tlp.release_fc()

            self.log.warning("Unexpected completion: failed to route completion to function: %r", tlp)
            return  # no UR response for completion
        elif tlp.fmt_type in {TlpType.IO_READ, TlpType.IO_WRITE}:
            # IO read/write

            for f in self.functions:
                bar = f.match_bar(tlp.address, True)
                if bar:

                    frame = PTilePcieFrame.from_tlp(tlp)

                    frame.bar_range = 6
                    frame.func_num = tlp.requester_id.function

                    await self.rx_queue.put((tlp, frame))

                    tlp.release_fc()

                    return

            tlp.release_fc()

            self.log.warning("No BAR match: IO request did not match any BARs: %r", tlp)
        elif tlp.fmt_type in {TlpType.MEM_READ, TlpType.MEM_READ_64, TlpType.MEM_WRITE, TlpType.MEM_WRITE_64}:
            # Memory read/write

            for f in self.functions:
                bar = f.match_bar(tlp.address)
                if bar:

                    frame = PTilePcieFrame.from_tlp(tlp)

                    frame.bar_range = bar[0]
                    frame.func_num = tlp.requester_id.function

                    await self.rx_queue.put((tlp, frame))

                    tlp.release_fc()

                    return

            tlp.release_fc()

            if tlp.fmt_type in {TlpType.MEM_WRITE, TlpType.MEM_WRITE_64}:
                self.log.warning("No BAR match: memory write request did not match any BARs: %r", tlp)
                return  # no UR response for write request
            else:
                self.log.warning("No BAR match: memory read request did not match any BARs: %r", tlp)
        else:
            raise Exception("TODO")

        # Unsupported request
        cpl = Tlp.create_ur_completion_for_tlp(tlp, PcieId(self.bus_num, 0, 0))
        self.log.debug("UR Completion: %r", cpl)
        await self.upstream_send(cpl)

    async def _run_reset(self):
        clock_edge_event = RisingEdge(self.coreclkout_hip)

        while True:
            await clock_edge_event
            await clock_edge_event

            if self.reset_status is not None:
                self.reset_status.value = 1
            if self.reset_status_n is not None:
                self.reset_status_n.value = 0

            if self.pin_perst_n is not None:
                if not self.pin_perst_n.value:
                    await RisingEdge(self.pin_perst_n)
                await First(FallingEdge(self.pin_perst_n), Timer(100, 'ns'))
                await First(FallingEdge(self.pin_perst_n), RisingEdge(self.coreclkout_hip))
                if not self.pin_perst_n.value:
                    continue
            else:
                await Timer(100, 'ns')
                await clock_edge_event

            if self.reset_status is not None:
                self.reset_status.value = 0
            if self.reset_status_n is not None:
                self.reset_status_n.value = 1

            if self.pin_perst_n is not None:
                await FallingEdge(self.pin_perst_n)
            else:
                return

    async def _run_rx_logic(self):
        while True:
            tlp, frame = await self.rx_queue.get()
            await self.rx_source.send(frame)

            self.rx_buf_cplh_fc_count = max(self.rx_buf_cplh_fc_count-1, 0)
            self.rx_buf_cpld_fc_count = max(self.rx_buf_cpld_fc_count-tlp.get_data_credits(), 0)

    async def _run_tx_logic(self):
        while True:
            frame = await self.tx_sink.recv()
            tlp = frame.to_tlp()
            await self.send(tlp)

    async def _run_rx_fc_logic(self):
        pass

        # RX flow control
        # rx_buffer_limit
        # rx_buffer_limit_tdm_idx

    async def _run_tx_fc_logic(self):
        clock_edge_event = RisingEdge(self.coreclkout_hip)

        while True:
            self.tx_cdts_limit.value = self.upstream_port.fc_state[0].ph.tx_credit_limit & 0xfff
            self.tx_cdts_limit_tdm_idx.value = 0
            await clock_edge_event

            self.tx_cdts_limit.value = self.upstream_port.fc_state[0].nph.tx_credit_limit & 0xfff
            self.tx_cdts_limit_tdm_idx.value = 1
            await clock_edge_event

            self.tx_cdts_limit.value = self.upstream_port.fc_state[0].cplh.tx_credit_limit & 0xfff
            self.tx_cdts_limit_tdm_idx.value = 2
            await clock_edge_event

            self.tx_cdts_limit.value = self.upstream_port.fc_state[0].pd.tx_credit_limit & 0xffff
            self.tx_cdts_limit_tdm_idx.value = 4
            await clock_edge_event

            self.tx_cdts_limit.value = self.upstream_port.fc_state[0].npd.tx_credit_limit & 0xffff
            self.tx_cdts_limit_tdm_idx.value = 5
            await clock_edge_event

            self.tx_cdts_limit.value = self.upstream_port.fc_state[0].cpld.tx_credit_limit & 0xffff
            self.tx_cdts_limit_tdm_idx.value = 6
            await clock_edge_event

    async def _run_pm_status_logic(self):
        pass

        # Power management and hard IP status interface
        # link_up
        # dl_up
        # surprise_down_err
        # ltssm_state
        # pm_state
        # pm_dstate
        # apps_pm_xmt_pme
        # app_req_retry_en

    async def _run_int_logic(self):
        pass

        # Interrupt interface
        # app_int
        # msi_pnd_func
        # msi_pnd_byte
        # msi_pnd_addr

    # Error interface
    # serr_out
    # hip_enter_err_mode
    # app_err_valid
    # app_err_hdr
    # app_err_info
    # app_err_func_num

    # Completion timeout interface
    # cpl_timeout
    # cpl_timeout_avmm_clk
    # cpl_timeout_avmm_address
    # cpl_timeout_avmm_read
    # cpl_timeout_avmm_readdata
    # cpl_timeout_avmm_readdatavalid
    # cpl_timeout_avmm_write
    # cpl_timeout_avmm_writedata
    # cpl_timeout_avmm_waitrequest

    async def _run_cfg_out_logic(self):
        clock_edge_event = RisingEdge(self.coreclkout_hip)

        while True:
            for func in self.functions:
                self.tl_cfg_func.value = func.pcie_id.function

                self.tl_cfg_add.value = 0x00
                val = bool(func.memory_space_enable) << 15
                val |= bool(func.pcie_cap.ido_completion_enable) << 14
                val |= bool(func.parity_error_response_enable) << 13
                val |= bool(func.serr_enable) << 12
                val |= bool(func.pcie_cap.fatal_error_reporting_enable) << 11
                val |= bool(func.pcie_cap.non_fatal_error_reporting_enable) << 10
                val |= bool(func.pcie_cap.correctable_error_reporting_enable) << 9
                val |= bool(func.pcie_cap.unsupported_request_reporting_enable) << 8
                val |= bool(func.bus_master_enable) << 7
                val |= bool(func.pcie_cap.extended_tag_field_enable) << 6
                val |= (func.pcie_cap.max_read_request_size & 0x7) << 3
                val |= (func.pcie_cap.max_payload_size & 0x7)
                self.tl_cfg_ctl.value = val
                await clock_edge_event

                self.tl_cfg_add.value = 0x01
                val = bool(func.pcie_cap.ido_request_enable) << 15
                val |= bool(func.pcie_cap.enable_no_snoop) << 14
                val |= bool(func.pcie_cap.enable_relaxed_ordering) << 13
                val |= (func.pcie_id.device & 0x1f) << 8
                val |= func.pcie_id.bus & 0xff
                self.tl_cfg_ctl.value = val
                await clock_edge_event

                self.tl_cfg_add.value = 0x02
                val = bool(func.pm_cap.no_soft_reset) << 15
                val |= bool(func.pcie_cap.read_completion_boundary) << 14
                val |= bool(func.interrupt_disable) << 13
                val |= (func.pcie_cap.interrupt_message_number & 0x1f) << 8
                val |= bool(func.pcie_cap.power_controller_control) << 4
                val |= (func.pcie_cap.attention_indicator_control & 0x3) << 2
                val |= func.pcie_cap.power_indicator_control & 0x3
                self.tl_cfg_ctl.value = val
                await clock_edge_event

                self.tl_cfg_add.value = 0x03
                # num vfs
                self.tl_cfg_ctl.value = 0
                await clock_edge_event

                self.tl_cfg_add.value = 0x04
                val = bool(func.pcie_cap.atomic_op_egress_blocking) << 14
                # ats
                val |= bool(func.pcie_cap.ari_forwarding_enable) << 7
                val |= bool(func.pcie_cap.atomic_op_requester_enable) << 6
                # tph
                # vf en
                self.tl_cfg_ctl.value = val
                await clock_edge_event

                self.tl_cfg_add.value = 0x05
                val = (func.pcie_cap.current_link_speed & 0xf) << 12
                # start vf
                self.tl_cfg_ctl.value = val
                await clock_edge_event

                self.tl_cfg_add.value = 0x06
                self.tl_cfg_ctl.value = func.msi_cap.msi_message_address & 0xffff
                await clock_edge_event

                self.tl_cfg_add.value = 0x07
                self.tl_cfg_ctl.value = (func.msi_cap.msi_message_address >> 16) & 0xffff
                await clock_edge_event

                self.tl_cfg_add.value = 0x08
                self.tl_cfg_ctl.value = (func.msi_cap.msi_message_address >> 32) & 0xffff
                await clock_edge_event

                self.tl_cfg_add.value = 0x09
                self.tl_cfg_ctl.value = (func.msi_cap.msi_message_address >> 48) & 0xffff
                await clock_edge_event

                self.tl_cfg_add.value = 0x0A
                self.tl_cfg_ctl.value = func.msi_cap.msi_mask_bits & 0xffff
                await clock_edge_event

                self.tl_cfg_add.value = 0x0B
                self.tl_cfg_ctl.value = (func.msi_cap.msi_mask_bits >> 16) & 0xffff
                await clock_edge_event

                self.tl_cfg_add.value = 0x0C
                val = bool(func.pcie_cap.system_error_on_fatal_error_enable) << 15
                val |= bool(func.pcie_cap.system_error_on_non_fatal_error_enable) << 14
                val |= bool(func.pcie_cap.system_error_on_correctable_error_enable) << 13
                val |= (func.aer_ext_cap.advanced_error_interrupt_message_number & 0x1f) << 8
                val |= bool(func.msi_cap.msi_extended_message_data_enable) << 7
                val |= bool(func.msix_cap.msix_function_mask) << 6
                val |= bool(func.msix_cap.msix_enable) << 5
                val |= (func.msi_cap.msi_multiple_message_enable & 0x7) << 2
                val |= bool(func.msi_cap.msi_64bit_address_capable) << 1
                val |= bool(func.msi_cap.msi_enable)
                self.tl_cfg_ctl.value = val
                await clock_edge_event

                self.tl_cfg_add.value = 0x0D
                self.tl_cfg_ctl.value = func.msi_cap.msi_message_data & 0xffff
                await clock_edge_event

                self.tl_cfg_add.value = 0x0E
                # AER uncorrectable error mask
                val = await func.aer_ext_cap.read_register(2)
                self.tl_cfg_ctl.value = val & 0xffff
                await clock_edge_event

                self.tl_cfg_add.value = 0x0F
                # AER uncorrectable error mask
                self.tl_cfg_ctl.value = (val >> 16) & 0xffff
                await clock_edge_event

                self.tl_cfg_add.value = 0x10
                # AER correctable error mask
                val = await func.aer_ext_cap.read_register(5)
                self.tl_cfg_ctl.value = val & 0xffff
                await clock_edge_event

                self.tl_cfg_add.value = 0x11
                # AER correctable error mask
                self.tl_cfg_ctl.value = (val >> 16) & 0xffff
                await clock_edge_event

                self.tl_cfg_add.value = 0x12
                # AER uncorrectable error severity
                val = await func.aer_ext_cap.read_register(3)
                self.tl_cfg_ctl.value = val & 0xffff
                await clock_edge_event

                self.tl_cfg_add.value = 0x13
                # AER uncorrectable error severity
                self.tl_cfg_ctl.value = (val >> 16) & 0xffff
                await clock_edge_event

                self.tl_cfg_add.value = 0x14
                # acs
                self.tl_cfg_ctl.value = 0
                await clock_edge_event

                self.tl_cfg_add.value = 0x15
                # prs
                self.tl_cfg_ctl.value = 0
                await clock_edge_event

                self.tl_cfg_add.value = 0x16
                # prs
                self.tl_cfg_ctl.value = 0
                await clock_edge_event

                self.tl_cfg_add.value = 0x17
                # prs
                self.tl_cfg_ctl.value = 0
                await clock_edge_event

                self.tl_cfg_add.value = 0x18
                # ltr
                # pasid
                self.tl_cfg_ctl.value = 0
                await clock_edge_event

                self.tl_cfg_add.value = 0x19
                # slot control
                self.tl_cfg_ctl.value = 0
                await clock_edge_event

                self.tl_cfg_add.value = 0x1A
                # ltr max snoop lat
                self.tl_cfg_ctl.value = 0
                await clock_edge_event

                self.tl_cfg_add.value = 0x1B
                # ltr max snoop lat
                self.tl_cfg_ctl.value = 0
                await clock_edge_event

                self.tl_cfg_add.value = 0x1C
                # TC en
                val = func.pcie_cap.negotiated_link_width & 0x3f
                self.tl_cfg_ctl.value = val
                await clock_edge_event

                self.tl_cfg_add.value = 0x1D
                self.tl_cfg_ctl.value = (func.msi_cap.msi_message_data >> 16) & 0xffff
                await clock_edge_event

                self.tl_cfg_add.value = 0x1E
                self.tl_cfg_ctl.value = 0
                await clock_edge_event

                self.tl_cfg_add.value = 0x1F
                self.tl_cfg_ctl.value = 0
                await clock_edge_event

        # dl_timer_update

    # Configuration intercept interface
    # cii_req
    # cii_hdr_poisoned
    # cii_hdr_first_be
    # cii_func_num
    # cii_wr_vf_active
    # cii_vf_num
    # cii_wr
    # cii_addr
    # cii_dout
    # cii_override_en
    # cii_override_din
    # cii_halt

    # Hard IP reconfiguration interface
    # hip_reconfig_clk
    # hip_reconfig_address
    # hip_reconfig_read
    # hip_reconfig_readdata
    # hip_reconfig_readdatavalid
    # hip_reconfig_write
    # hip_reconfig_writedata
    # hip_reconfig_waitrequest

    # Page request service
    # prs_event_valid
    # prs_event_func
    # prs_event

    # SR-IOV (VF error)
    # vf_err_ur_posted_s0
    # vf_err_ur_posted_s1
    # vf_err_ur_posted_s2
    # vf_err_ur_posted_s3
    # vf_err_func_num_s0
    # vf_err_func_num_s1
    # vf_err_func_num_s2
    # vf_err_func_num_s3
    # vf_err_ca_postedreq_s0
    # vf_err_ca_postedreq_s1
    # vf_err_ca_postedreq_s2
    # vf_err_ca_postedreq_s3
    # vf_err_vf_num_s0
    # vf_err_vf_num_s1
    # vf_err_vf_num_s2
    # vf_err_vf_num_s3
    # vf_err_poisonedwrreq_s0
    # vf_err_poisonedwrreq_s1
    # vf_err_poisonedwrreq_s2
    # vf_err_poisonedwrreq_s3
    # vf_err_poisonedcompl_s0
    # vf_err_poisonedcompl_s1
    # vf_err_poisonedcompl_s2
    # vf_err_poisonedcompl_s3
    # user_vfnonfatalmsg_func_num
    # user_vfnonfatalmsg_vfnum
    # user_sent_vfnonfatalmsg
    # vf_err_overflow

    # FLR
    # flr_rcvd_pf
    # flr_rcvd_vf
    # flr_rcvd_pf_num
    # flr_rcvd_vf_num
    # flr_completed_pf
    # flr_completed_vf
    # flr_completed_pf_num
    # flr_completed_vf_num

    # VirtIO
    # virtio_pcicfg_vfaccess
    # virtio_pcicfg_vfnum
    # virtio_pcicfg_pfnum
    # virtio_pcicfg_bar
    # virtio_pcicfg_length
    # virtio_pcicfg_baroffset
    # virtio_pcicfg_cfgdata
    # virtio_pcicfg_cfgwr
    # virtio_pcicfg_cfgrd
    # virtio_pcicfg_appvfnum
    # virtio_pcicfg_apppfnum
    # virtio_pcicfg_rdack
    # virtio_pcicfg_rdbe
    # virtio_pcicfg_data



================================================
FILE: cocotbext/pcie/intel/s10/__init__.py
================================================
"""

Copyright (c) 2021 Alex Forencich

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

"""

from .s10_model import S10PcieDevice, S10PcieFunction
from .interface import S10RxBus, S10TxBus



================================================
FILE: cocotbext/pcie/intel/s10/interface.py
================================================
"""

Copyright (c) 2021 Alex Forencich

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

"""

import logging
import struct

import cocotb
from cocotb.queue import Queue, QueueFull
from cocotb.triggers import RisingEdge, Timer, First, Event
from cocotb_bus.bus import Bus

from cocotbext.pcie.core.tlp import Tlp


class BaseBus(Bus):

    _signals = ["data"]
    _optional_signals = []

    def __init__(self, entity=None, prefix=None, **kwargs):
        super().__init__(entity, prefix, self._signals, optional_signals=self._optional_signals, **kwargs)

    @classmethod
    def from_entity(cls, entity, **kwargs):
        return cls(entity, **kwargs)

    @classmethod
    def from_prefix(cls, entity, prefix, **kwargs):
        return cls(entity, prefix, **kwargs)


class S10TxBus(BaseBus):
    _signals = ["data", "sop", "eop", "valid", "ready", "err"]
    _optional_signals = ["parity", "vf_active"]


class S10RxBus(BaseBus):
    _signals = ["data", "empty", "sop", "eop", "valid", "ready", "bar_range"]
    _optional_signals = ["vf_active", "func_num", "vf_num", "parity"]


def dword_parity(d):
    d ^= d >> 4
    d ^= d >> 2
    d ^= d >> 1
    p = d & 0x1
    if d & 0x100:
        p |= 0x2
    if d & 0x10000:
        p |= 0x4
    if d & 0x1000000:
        p |= 0x8
    return p


def parity(d):
    d ^= d >> 4
    d ^= d >> 2
    d ^= d >> 1
    b = 0x1
    p = 0
    while d:
        if d & 0x1:
            p |= b
        d >>= 8
        b <<= 1
    return p


class S10PcieFrame:
    def __init__(self, frame=None):
        self.data = []
        self.parity = []
        self.func_num = 0
        self.vf_num = None
        self.bar_range = 0
        self.err = 0

        if isinstance(frame, Tlp):
            hdr = frame.pack_header()
            for k in range(0, len(hdr), 4):
                self.data.extend(struct.unpack_from('>L', hdr, k))

            data = frame.get_data()
            for k in range(0, len(data), 4):
                self.data.extend(struct.unpack_from('<L', data, k))

            self.update_parity()

        elif isinstance(frame, S10PcieFrame):
            self.data = list(frame.data)
            self.parity = list(frame.parity)
            self.func_num = frame.func_num
            self.vf_num = frame.vf_num
            self.bar_range = frame.bar_range
            self.err = frame.err

    @classmethod
    def from_tlp(cls, tlp):
        return cls(tlp)

    def to_tlp(self):
        hdr = bytearray()
        for dw in self.data[:5]:
            hdr.extend(struct.pack('>L', dw))
        tlp = Tlp.unpack_header(hdr)

        for dw in self.data[tlp.get_header_size_dw():]:
            tlp.data.extend(struct.pack('<L', dw))

        return tlp

    def update_parity(self):
        self.parity = [dword_parity(d) ^ 0xf for d in self.data]

    def check_parity(self):
        return (
            self.parity == [dword_parity(d) ^ 0xf for d in self.data]
        )

    def __eq__(self, other):
        if isinstance(other, S10PcieFrame):
            return (
                self.data == other.data and
                self.parity == other.parity and
                self.func_num == other.func_num and
                self.vf_num == other.vf_num and
                self.bar_range == other.bar_range and
                self.err == other.err
            )
        return False

    def __repr__(self):
        return (
            f"{type(self).__name__}(data=[{', '.join(f'{x:#010x}' for x in self.data)}], "
            f"parity=[{', '.join(hex(x) for x in self.parity)}], "
            f"func_num={self.func_num}, "
            f"vf_num={self.vf_num}, "
            f"bar_range={self.bar_range}, "
            f"err={self.err})"
        )

    def __len__(self):
        return len(self.data)


class S10PcieTransaction:

    _signals = ["data", "empty", "sop", "eop", "valid", "err",
        "vf_active", "func_num", "vf_num", "bar_range", "parity"]

    def __init__(self, *args, **kwargs):
        for sig in self._signals:
            if sig in kwargs:
                setattr(self, sig, kwargs[sig])
                del kwargs[sig]
            else:
                setattr(self, sig, 0)

        super().__init__(*args, **kwargs)

    def __repr__(self):
        return f"{type(self).__name__}({', '.join(f'{s}={int(getattr(self, s))}' for s in self._signals)})"


class S10PcieBase:

    _signal_widths = {"ready": 1}

    _valid_signal = "valid"
    _ready_signal = "ready"

    _transaction_obj = S10PcieTransaction
    _frame_obj = S10PcieFrame

    def __init__(self, bus, clock, reset=None, ready_latency=0, *args, **kwargs):
        self.bus = bus
        self.clock = clock
        self.reset = reset
        self.ready_latency = ready_latency
        if bus._name:
            self.log = logging.getLogger(f"cocotb.{bus._entity._name}.{bus._name}")
        else:
            self.log = logging.getLogger(f"cocotb.{bus._entity._name}")

        super().__init__(*args, **kwargs)

        self.active = False
        self.queue = Queue()
        self.dequeue_event = Event()
        self.idle_event = Event()
        self.idle_event.set()
        self.active_event = Event()

        self.pause = False
        self._pause_generator = None
        self._pause_cr = None

        self.queue_occupancy_bytes = 0
        self.queue_occupancy_frames = 0

        self.width = len(self.bus.data)
        self.byte_size = 32
        self.byte_lanes = self.width // self.byte_size
        self.byte_mask = 2**self.byte_size-1

        self.seg_count = len(self.bus.valid)
        self.seg_width = self.width // self.seg_count
        self.seg_mask = 2**self.seg_width-1
        self.seg_par_width = self.seg_width // 8
        self.seg_par_mask = 2**self.seg_par_width-1
        self.seg_byte_lanes = self.byte_lanes // self.seg_count
        self.seg_empty_width = (self.seg_byte_lanes-1).bit_length()
        self.seg_empty_mask = 2**self.seg_empty_width-1

        assert self.width in {256, 512}

        assert len(self.bus.data) == self.seg_count*self.seg_width
        assert len(self.bus.sop) == self.seg_count
        assert len(self.bus.eop) == self.seg_count
        assert len(self.bus.valid) == self.seg_count

        if hasattr(self.bus, "empty"):
            assert len(self.bus.empty) == self.seg_count*self.seg_empty_width

        if hasattr(self.bus, "err"):
            assert len(self.bus.err) == self.seg_count
        if hasattr(self.bus, "bar_range"):
            assert len(self.bus.bar_range) == self.seg_count*3

        if hasattr(self.bus, "vf_active"):
            assert len(self.bus.vf_active) == self.seg_count
        if hasattr(self.bus, "func_num"):
            assert len(self.bus.func_num) == self.seg_count*2
        if hasattr(self.bus, "vf_num"):
            assert len(self.bus.vf_num) == self.seg_count*11

        if hasattr(self.bus, "parity"):
            assert len(self.bus.parity) == self.seg_count*self.seg_width//8

    def count(self):
        return self.queue.qsize()

    def empty(self):
        return self.queue.empty()

    def clear(self):
        while not self.queue.empty():
            self.queue.get_nowait()
        self.idle_event.set()
        self.active_event.clear()

    def idle(self):
        raise NotImplementedError()

    async def wait(self):
        raise NotImplementedError()

    def set_pause_generator(self, generator=None):
        if self._pause_cr is not None:
            self._pause_cr.kill()
            self._pause_cr = None

        self._pause_generator = generator

        if self._pause_generator is not None:
            self._pause_cr = cocotb.start_soon(self._run_pause())

    def clear_pause_generator(self):
        self.set_pause_generator(None)

    async def _run_pause(self):
        clock_edge_event = RisingEdge(self.clock)

        for val in self._pause_generator:
            self.pause = val
            await clock_edge_event


class S10PcieSource(S10PcieBase):

    _signal_widths = {"valid": 1, "ready": 1}

    _valid_signal = "valid"
    _ready_signal = "ready"

    _transaction_obj = S10PcieTransaction
    _frame_obj = S10PcieFrame

    def __init__(self, bus, clock, reset=None, ready_latency=0, *args, **kwargs):
        super().__init__(bus, clock, reset, ready_latency, *args, **kwargs)

        self.drive_obj = None
        self.drive_sync = Event()

        self.queue_occupancy_limit_bytes = -1
        self.queue_occupancy_limit_frames = -1

        self.bus.data.setimmediatevalue(0)
        self.bus.sop.setimmediatevalue(0)
        self.bus.eop.setimmediatevalue(0)
        self.bus.valid.setimmediatevalue(0)

        if hasattr(self.bus, "empty"):
            self.bus.empty.setimmediatevalue(0)

        if hasattr(self.bus, "err"):
            self.bus.err.setimmediatevalue(0)
        if hasattr(self.bus, "bar_range"):
            self.bus.bar_range.setimmediatevalue(0)

        if hasattr(self.bus, "vf_active"):
            self.bus.vf_active.setimmediatevalue(0)
        if hasattr(self.bus, "func_num"):
            self.bus.func_num.setimmediatevalue(0)
        if hasattr(self.bus, "vf_num"):
            self.bus.vf_num.setimmediatevalue(0)

        if hasattr(self.bus, "parity"):
            self.bus.parity.setimmediatevalue(0)

        cocotb.start_soon(self._run_source())
        cocotb.start_soon(self._run())

    async def _drive(self, obj):
        if self.drive_obj is not None:
            self.drive_sync.clear()
            await self.drive_sync.wait()

        self.drive_obj = obj

    async def send(self, frame):
        while self.full():
            self.dequeue_event.clear()
            await self.dequeue_event.wait()
        frame = S10PcieFrame(frame)
        await self.queue.put(frame)
        self.idle_event.clear()
        self.queue_occupancy_bytes += len(frame)
        self.queue_occupancy_frames += 1

    def send_nowait(self, frame):
        if self.full():
            raise QueueFull()
        frame = S10PcieFrame(frame)
        self.queue.put_nowait(frame)
        self.idle_event.clear()
        self.queue_occupancy_bytes += len(frame)
        self.queue_occupancy_frames += 1

    def full(self):
        if self.queue_occupancy_limit_bytes > 0 and self.queue_occupancy_bytes > self.queue_occupancy_limit_bytes:
            return True
        elif self.queue_occupancy_limit_frames > 0 and self.queue_occupancy_frames > self.queue_occupancy_limit_frames:
            return True
        else:
            return False

    def idle(self):
        return self.empty() and not self.active

    async def wait(self):
        await self.idle_event.wait()

    async def _run_source(self):
        self.active = False
        ready_delay = []

        clock_edge_event = RisingEdge(self.clock)

        while True:
            await clock_edge_event

            # read handshake signals
            ready_sample = self.bus.ready.value
            valid_sample = self.bus.valid.value

            if self.reset is not None and self.reset.value:
                self.active = False
                self.bus.valid.value = 0
                continue

            # ready delay
            if self.ready_latency > 1:
                if len(ready_delay) != (self.ready_latency-1):
                    ready_delay = [0]*(self.ready_latency-1)
                ready_delay.append(ready_sample)
                ready_sample = ready_delay.pop(0)

            if (ready_sample and valid_sample) or not valid_sample or self.ready_latency > 0:
                if self.drive_obj and not self.pause and (ready_sample or self.ready_latency == 0):
                    self.bus.drive(self.drive_obj)
                    self.drive_obj = None
                    self.drive_sync.set()
                    self.active = True
                else:
                    self.bus.valid.value = 0
                    self.active = bool(self.drive_obj)
                    if not self.drive_obj:
                        self.idle_event.set()

    async def _run(self):
        while True:
            frame = await self._get_frame()
            frame_offset = 0
            self.log.info("TX frame: %r", frame)
            first = True

            while frame is not None:
                transaction = self._transaction_obj()

                for seg in range(self.seg_count):
                    if frame is None:
                        if not self.empty():
                            frame = self._get_frame_nowait()
                            frame_offset = 0
                            self.log.info("TX frame: %r", frame)
                            first = True
                        else:
                            break

                    if first:
                        first = False

                        transaction.valid |= 1 << seg
                        transaction.sop |= 1 << seg

                    transaction.bar_range |= frame.bar_range << seg*3
                    transaction.func_num |= frame.func_num << seg*3
                    if frame.vf_num is not None:
                        transaction.vf_active |= 1 << seg
                        transaction.vf_num |= frame.vf_num << seg*11
                    transaction.err |= frame.err << seg

                    empty = 0
                    if frame.data:
                        transaction.valid |= 1 << seg

                        for k in range(min(self.seg_byte_lanes, len(frame.data)-frame_offset)):
                            transaction.data |= frame.data[frame_offset] << 32*(k+seg*self.seg_byte_lanes)
                            transaction.parity |= frame.parity[frame_offset] << 4*(k+seg*self.seg_byte_lanes)
                            empty = self.seg_byte_lanes-1-k
                            frame_offset += 1

                    if frame_offset >= len(frame.data):
                        transaction.eop |= 1 << seg
                        transaction.empty |= empty << seg*self.seg_empty_width

                        frame = None

                await self._drive(transaction)

    async def _get_frame(self):
        frame = await self.queue.get()
        self.dequeue_event.set()
        self.queue_occupancy_bytes -= len(frame)
        self.queue_occupancy_frames -= 1
        return frame

    def _get_frame_nowait(self):
        frame = self.queue.get_nowait()
        self.dequeue_event.set()
        self.queue_occupancy_bytes -= len(frame)
        self.queue_occupancy_frames -= 1
        return frame


class S10PcieSink(S10PcieBase):

    _signal_widths = {"valid": 1, "ready": 1}

    _valid_signal = "valid"
    _ready_signal = "ready"

    _transaction_obj = S10PcieTransaction
    _frame_obj = S10PcieFrame

    def __init__(self, bus, clock, reset=None, ready_latency=0, *args, **kwargs):
        super().__init__(bus, clock, reset, ready_latency, *args, **kwargs)

        self.sample_obj = None
        self.sample_sync = Event()

        self.queue_occupancy_limit_bytes = -1
        self.queue_occupancy_limit_frames = -1

        self.bus.ready.setimmediatevalue(0)

        cocotb.start_soon(self._run_sink())
        cocotb.start_soon(self._run())

    def _recv(self, frame):
        if self.queue.empty():
            self.active_event.clear()
        self.queue_occupancy_bytes -= len(frame)
        self.queue_occupancy_frames -= 1
        return frame

    async def recv(self):
        frame = await self.queue.get()
        return self._recv(frame)

    def recv_nowait(self):
        frame = self.queue.get_nowait()
        return self._recv(frame)

    def full(self):
        if self.queue_occupancy_limit_bytes > 0 and self.queue_occupancy_bytes > self.queue_occupancy_limit_bytes:
            return True
        elif self.queue_occupancy_limit_frames > 0 and self.queue_occupancy_frames > self.queue_occupancy_limit_frames:
            return True
        else:
            return False

    def idle(self):
        return not self.active

    async def wait(self, timeout=0, timeout_unit='ns'):
        if not self.empty():
            return
        if timeout:
            await First(self.active_event.wait(), Timer(timeout, timeout_unit))
        else:
            await self.active_event.wait()

    async def _run_sink(self):
        ready_delay = []

        clock_edge_event = RisingEdge(self.clock)

        while True:
            await clock_edge_event

            # read handshake signals
            ready_sample = self.bus.ready.value
            valid_sample = self.bus.valid.value

            if self.reset is not None and self.reset.value:
                self.bus.ready.value = 0
                continue

            # ready delay
            if self.ready_latency > 0:
                if len(ready_delay) != self.ready_latency:
                    ready_delay = [0]*self.ready_latency
                ready_delay.append(ready_sample)
                ready_sample = ready_delay.pop(0)

            if valid_sample and ready_sample:
                self.sample_obj = self._transaction_obj()
                self.bus.sample(self.sample_obj)
                self.sample_sync.set()
            elif self.ready_latency > 0:
                assert not valid_sample, "handshake error: valid asserted outside of ready cycle"

            self.bus.ready.value = (not self.full() and not self.pause)

    async def _run(self):
        self.active = False
        frame = None
        dword_count = 0

        while True:
            while not self.sample_obj:
                self.sample_sync.clear()
                await self.sample_sync.wait()

            self.active = True
            sample = self.sample_obj
            self.sample_obj = None

            for seg in range(self.seg_count):
                if not sample.valid & (1 << seg):
                    continue

                if sample.sop & (1 << seg):
                    assert frame is None, "framing error: sop asserted in frame"
                    frame = S10PcieFrame()

                    hdr = (sample.data >> (seg*self.seg_width)) & self.seg_mask
                    fmt = (hdr >> 29) & 0b111
                    if fmt & 0b001:
                        dword_count = 4
                    else:
                        dword_count = 3

                    if fmt & 0b010:
                        count = hdr & 0x3ff
                        if count == 0:
                            count = 1024
                        dword_count += count

                    frame.bar_range = (sample.bar_range >> seg*3) & 0x7
                    frame.func_num = (sample.func_num >> seg*3) & 0x7
                    if sample.vf_active & (1 << seg):
                        frame.vf_num = (sample.vf_num >> seg*11) & 0x7ff
                    frame.err = (sample.err >> seg) & 0x1

                assert frame is not None, "framing error: data transferred outside of frame"

                if dword_count > 0:
                    data = (sample.data >> (seg*self.seg_width)) & self.seg_mask
                    parity = (sample.parity >> (seg*self.seg_par_width)) & self.seg_par_mask
                    for k in range(min(self.seg_byte_lanes, dword_count)):
                        frame.data.append((data >> 32*k) & 0xffffffff)
                        frame.parity.append((parity >> 4*k) & 0xf)
                        dword_count -= 1

                if sample.eop & (1 << seg):
                    assert dword_count == 0, "framing error: incorrect length or early eop"
                    self.log.info("RX frame: %r", frame)
                    self._sink_frame(frame)
                    self.active = False
                    frame = None

    def _sink_frame(self, frame):
        self.queue_occupancy_bytes += len(frame)
        self.queue_occupancy_frames += 1

        self.queue.put_nowait(frame)
        self.active_event.set()



================================================
FILE: cocotbext/pcie/intel/s10/s10_model.py
================================================
"""

Copyright (c) 2021 Alex Forencich

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

"""

import cocotb
from cocotb.clock import Clock
from cocotb.queue import Queue
from cocotb.triggers import RisingEdge, FallingEdge, Timer, First

from cocotbext.pcie.core import Device, Endpoint, __version__
from cocotbext.pcie.core.caps import MsiCapability, MsixCapability
from cocotbext.pcie.core.caps import AerExtendedCapability, PcieExtendedCapability
from cocotbext.pcie.core.utils import PcieId
from cocotbext.pcie.core.tlp import Tlp, TlpType

from .interface import S10PcieFrame, S10PcieSource, S10PcieSink


valid_configs = [
    # speed, links, width, freq
    (1,  1, 256, 125.0e6),
    (1,  2, 256, 125.0e6),
    (1,  4, 256, 125.0e6),
    (1,  8, 256, 125.0e6),
    (1, 16, 256, 125.0e6),
    (2,  1, 256, 125.0e6),
    (2,  2, 256, 125.0e6),
    (2,  4, 256, 125.0e6),
    (2,  8, 256, 125.0e6),
    (2, 16, 256, 250.0e6),
    (3,  1, 256, 125.0e6),
    (3,  2, 256, 125.0e6),
    (3,  4, 256, 125.0e6),
    (3,  8, 256, 250.0e6),
    (3, 16, 512, 250.0e6),
]


class S10PcieFunction(Endpoint):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        # PCIe capabilities
        self.register_capability(self.pm_cap, offset=0x10)

        self.msi_cap = MsiCapability()
        self.msi_cap.msi_64bit_address_capable = 1
        self.msi_cap.msi_per_vector_mask_capable = 0
        self.register_capability(self.msi_cap, offset=0x14)

        self.register_capability(self.pcie_cap, offset=0x1c)

        self.msix_cap = MsixCapability()
        self.register_capability(self.msix_cap, offset=0x2c)

        # PCIe extended capabilities
        self.aer_ext_cap = AerExtendedCapability()
        self.register_capability(self.aer_ext_cap, offset=0x40)

        # VC 0x4e
        # ARI 0x5e

        self.pcie_ext_cap = PcieExtendedCapability()
        self.register_capability(self.pcie_ext_cap, offset=0x62)

        # SRIOV 0x6e
        # TPH 0x7e
        # ATS 0xa1
        # VSEC (Intel) 0x2e0


def init_signal(sig, width=None, initval=None):
    if sig is None:
        return None
    if width is not None:
        assert len(sig) == width
    if initval is not None:
        sig.setimmediatevalue(initval)
    return sig


class S10PcieDevice(Device):
    def __init__(self,
            # configuration options
            pcie_generation=None,
            pcie_link_width=None,
            pld_clk_frequency=None,
            l_tile=False,
            pf_count=1,
            max_payload_size=128,
            enable_extended_tag=False,

            pf0_msi_enable=False,
            pf0_msi_count=1,
            pf1_msi_enable=False,
            pf1_msi_count=1,
            pf2_msi_enable=False,
            pf2_msi_count=1,
            pf3_msi_enable=False,
            pf3_msi_count=1,
            pf0_msix_enable=False,
            pf0_msix_table_size=0,
            pf0_msix_table_bir=0,
            pf0_msix_table_offset=0x00000000,
            pf0_msix_pba_bir=0,
            pf0_msix_pba_offset=0x00000000,
            pf1_msix_enable=False,
            pf1_msix_table_size=0,
            pf1_msix_table_bir=0,
            pf1_msix_table_offset=0x00000000,
            pf1_msix_pba_bir=0,
            pf1_msix_pba_offset=0x00000000,
            pf2_msix_enable=False,
            pf2_msix_table_size=0,
            pf2_msix_table_bir=0,
            pf2_msix_table_offset=0x00000000,
            pf2_msix_pba_bir=0,
            pf2_msix_pba_offset=0x00000000,
            pf3_msix_enable=False,
            pf3_msix_table_size=0,
            pf3_msix_table_bir=0,
            pf3_msix_table_offset=0x00000000,
            pf3_msix_pba_bir=0,
            pf3_msix_pba_offset=0x00000000,

            # signals
            # Clock and reset
            npor=None,
            pin_perst=None,
            ninit_done=None,
            pld_clk_inuse=None,
            pld_core_ready=None,
            reset_status=None,
            clr_st=None,
            refclk=None,
            coreclkout_hip=None,

            # RX interface
            rx_bus=None,

            # TX interface
            tx_bus=None,

            # TX flow control
            tx_ph_cdts=None,
            tx_pd_cdts=None,
            tx_nph_cdts=None,
            tx_npd_cdts=None,
            tx_cplh_cdts=None,
            tx_cpld_cdts=None,
            tx_hdr_cdts_consumed=None,
            tx_data_cdts_consumed=None,
            tx_cdts_type=None,
            tx_cdts_data_value=None,

            # Hard IP status
            int_status=None,
            int_status_common=None,
            derr_cor_ext_rpl=None,
            derr_rpl=None,
            derr_cor_ext_rcv=None,
            derr_uncor_ext_rcv=None,
            rx_par_err=None,
            tx_par_err=None,
            ltssmstate=None,
            link_up=None,
            lane_act=None,
            currentspeed=None,

            # Power management
            pm_linkst_in_l1=None,
            pm_linkst_in_l0s=None,
            pm_state=None,
            pm_dstate=None,
            apps_pm_xmt_pme=None,
            apps_ready_entr_l23=None,
            apps_pm_xmt_turnoff=None,
            app_init_rst=None,
            app_xfer_pending=None,

            # Interrupt interface
            app_msi_req=None,
            app_msi_ack=None,
            app_msi_tc=None,
            app_msi_num=None,
            app_msi_func_num=None,
            app_int_sts=None,

            # Error interface
            app_err_valid=None,
            app_err_hdr=None,
            app_err_info=None,
            app_err_func_num=None,

            # Configuration output
            tl_cfg_func=None,
            tl_cfg_add=None,
            tl_cfg_ctl=None,

            # Configuration extension bus
            ceb_req=None,
            ceb_ack=None,
            ceb_addr=None,
            ceb_din=None,
            ceb_dout=None,
            ceb_wr=None,
            ceb_cdm_convert_data=None,
            ceb_func_num=None,
            ceb_vf_num=None,
            ceb_vf_active=None,

            # Hard IP reconfiguration interface
            hip_reconfig_clk=None,
            hip_reconfig_rst_n=None,
            hip_reconfig_address=None,
            hip_reconfig_read=None,
            hip_reconfig_readdata=None,
            hip_reconfig_readdatavalid=None,
            hip_reconfig_write=None,
            hip_reconfig_writedata=None,
            hip_reconfig_waitrequest=None,

            *args, **kwargs):

        super().__init__(*args, **kwargs)

        self.log.info("Intel Stratix 10 H-Tile/L-Tile PCIe hard IP core model")
        self.log.info("cocotbext-pcie version %s", __version__)
        self.log.info("Copyright (c) 2021 Alex Forencich")
        self.log.info("https://github.com/alexforencich/cocotbext-pcie")

        self.default_function = S10PcieFunction

        self.dw = None

        self.rx_queue = Queue()

        # UG lists 770 CPLH and 2500 CPLD
        # Tests confirm ~770 CPLH and ~2432 CPLD
        self.rx_buf_cplh_fc_limit = 770
        self.rx_buf_cpld_fc_limit = 2432
        self.rx_buf_cplh_fc_count = 0
        self.rx_buf_cpld_fc_count = 0

        # configuration options
        self.pcie_generation = pcie_generation
        self.pcie_link_width = pcie_link_width
        self.pld_clk_frequency = pld_clk_frequency
        self.l_tile = l_tile
        self.pf_count = pf_count
        self.max_payload_size = max_payload_size
        self.enable_extended_tag = enable_extended_tag

        self.pf0_msi_enable = pf0_msi_enable
        self.pf0_msi_count = pf0_msi_count
        self.pf1_msi_enable = pf1_msi_enable
        self.pf1_msi_count = pf1_msi_count
        self.pf2_msi_enable = pf2_msi_enable
        self.pf2_msi_count = pf2_msi_count
        self.pf3_msi_enable = pf3_msi_enable
        self.pf3_msi_count = pf3_msi_count
        self.pf0_msix_enable = pf0_msix_enable
        self.pf0_msix_table_size = pf0_msix_table_size
        self.pf0_msix_table_bir = pf0_msix_table_bir
        self.pf0_msix_table_offset = pf0_msix_table_offset
        self.pf0_msix_pba_bir = pf0_msix_pba_bir
        self.pf0_msix_pba_offset = pf0_msix_pba_offset
        self.pf1_msix_enable = pf1_msix_enable
        self.pf1_msix_table_size = pf1_msix_table_size
        self.pf1_msix_table_bir = pf1_msix_table_bir
        self.pf1_msix_table_offset = pf1_msix_table_offset
        self.pf1_msix_pba_bir = pf1_msix_pba_bir
        self.pf1_msix_pba_offset = pf1_msix_pba_offset
        self.pf2_msix_enable = pf2_msix_enable
        self.pf2_msix_table_size = pf2_msix_table_size
        self.pf2_msix_table_bir = pf2_msix_table_bir
        self.pf2_msix_table_offset = pf2_msix_table_offset
        self.pf2_msix_pba_bir = pf2_msix_pba_bir
        self.pf2_msix_pba_offset = pf2_msix_pba_offset
        self.pf3_msix_enable = pf3_msix_enable
        self.pf3_msix_table_size = pf3_msix_table_size
        self.pf3_msix_table_bir = pf3_msix_table_bir
        self.pf3_msix_table_offset = pf3_msix_table_offset
        self.pf3_msix_pba_bir = pf3_msix_pba_bir
        self.pf3_msix_pba_offset = pf3_msix_pba_offset

        # signals

        # Clock and reset
        self.npor = init_signal(reset_status, 1)
        self.pin_perst = init_signal(pin_perst, 1)
        self.ninit_done = init_signal(ninit_done, 1)
        self.pld_clk_inuse = init_signal(pld_clk_inuse, 1, 0)
        self.pld_core_ready = init_signal(pld_core_ready, 1)
        self.reset_status = init_signal(reset_status, 1, 0)
        self.clr_st = init_signal(clr_st, 1, 0)
        self.refclk = init_signal(refclk, 1)
        self.coreclkout_hip = init_signal(coreclkout_hip, 1, 0)

        # RX interface
        self.rx_source = None

        if rx_bus is not None:
            self.rx_source = S10PcieSource(rx_bus, self.coreclkout_hip)
            self.rx_source.queue_occupancy_limit_frames = 2
            self.rx_source.ready_latency = 18 if self.rx_source.width == 512 else 17
            self.dw = self.rx_source.width

        # TX interface
        self.tx_sink = None

        if tx_bus is not None:
            self.tx_sink = S10PcieSink(tx_bus, self.coreclkout_hip)
            self.tx_sink.queue_occupancy_limit_frames = 2
            self.tx_sink.ready_latency = 3
            self.dw = self.tx_sink.width

        # TX flow control
        self.tx_ph_cdts = init_signal(tx_ph_cdts, 8, 0)
        self.tx_pd_cdts = init_signal(tx_pd_cdts, 12, 0)
        self.tx_nph_cdts = init_signal(tx_nph_cdts, 8, 0)
        self.tx_cplh_cdts = init_signal(tx_cplh_cdts, 8, 0)
        if self.l_tile:
            self.tx_npd_cdts = init_signal(tx_npd_cdts, 12, 0)
            self.tx_cpld_cdts = init_signal(tx_cpld_cdts, 12, 0)
        # self.tx_hdr_cdts_consumed
        # self.tx_data_cdts_consumed
        # self.tx_cdts_type
        # self.tx_cdts_data_value

        # Hard IP status
        self.int_status = init_signal(int_status, 11, 0)
        self.int_status_common = init_signal(int_status_common, 3, 0)
        self.derr_cor_ext_rpl = init_signal(derr_cor_ext_rpl, 1, 0)
        self.derr_rpl = init_signal(derr_rpl, 1, 0)
        self.derr_cor_ext_rcv = init_signal(derr_cor_ext_rcv, 1, 0)
        self.derr_uncor_ext_rcv = init_signal(derr_uncor_ext_rcv, 1, 0)
        self.rx_par_err = init_signal(rx_par_err, 1, 0)
        self.tx_par_err = init_signal(tx_par_err, 1, 0)
        self.ltssmstate = init_signal(ltssmstate, 6, 0)
        self.link_up = init_signal(link_up, 1, 0)
        self.lane_act = init_signal(lane_act, 5, 0)
        self.currentspeed = init_signal(currentspeed, 2, 0)

        # Power management
        self.pm_linkst_in_l1 = init_signal(pm_linkst_in_l1, 1, 0)
        self.pm_linkst_in_l0s = init_signal(pm_linkst_in_l0s, 1, 0)
        self.pm_state = init_signal(pm_state, 3, 0)
        self.pm_dstate = init_signal(pm_dstate, 3, 0)
        self.apps_pm_xmt_pme = init_signal(apps_pm_xmt_pme, 1)
        self.apps_ready_entr_l23 = init_signal(apps_ready_entr_l23, 1)
        self.apps_pm_xmt_turnoff = init_signal(apps_pm_xmt_turnoff, 1)
        self.app_init_rst = init_signal(app_init_rst, 1)
        self.app_xfer_pending = init_signal(app_xfer_pending, 1)

        # Interrupt interface
        self.app_msi_req = init_signal(app_msi_req, 1)
        self.app_msi_ack = init_signal(app_msi_ack, 1, 0)
        self.app_msi_tc = init_signal(app_msi_tc, 3)
        self.app_msi_num = init_signal(app_msi_num, 5)
        self.app_msi_func_num = init_signal(app_msi_func_num, 2)
        self.app_int_sts = init_signal(app_int_sts, 4)

        # Error interface
        self.app_err_valid = init_signal(app_err_valid, 1)
        self.app_err_hdr = init_signal(app_err_hdr, 32)
        self.app_err_info = init_signal(app_err_info, 11)
        self.app_err_func_num = init_signal(app_err_func_num, 2)

        # Configuration output
        self.tl_cfg_func = init_signal(tl_cfg_func, 2, 0)
        self.tl_cfg_add = init_signal(tl_cfg_add, 5, 0)
        self.tl_cfg_ctl = init_signal(tl_cfg_ctl, 32, 0)

        # Configuration intercept interface
        self.ceb_req = init_signal(ceb_req, 1, 0)
        self.ceb_ack = init_signal(ceb_ack, 1)
        self.ceb_addr = init_signal(ceb_addr, 12, 0)
        self.ceb_din = init_signal(ceb_din, 32)
        self.ceb_dout = init_signal(ceb_dout, 32, 0)
        self.ceb_wr = init_signal(ceb_wr, 4, 0)
        self.ceb_cdm_convert_data = init_signal(ceb_cdm_convert_data, 32)
        self.ceb_func_num = init_signal(ceb_func_num, 2, 0)
        self.ceb_vf_num = init_signal(ceb_vf_num, 11, 0)
        self.ceb_vf_active = init_signal(ceb_vf_active, 1, 0)

        # Hard IP reconfiguration interface
        self.hip_reconfig_clk = init_signal(hip_reconfig_clk, 1)
        self.hip_reconfig_rst_n = init_signal(hip_reconfig_rst_n, 1)
        self.hip_reconfig_address = init_signal(hip_reconfig_address, 21)
        self.hip_reconfig_read = init_signal(hip_reconfig_read, 1)
        self.hip_reconfig_readdata = init_signal(hip_reconfig_readdata, 8, 0)
        self.hip_reconfig_readdatavalid = init_signal(hip_reconfig_readdatavalid, 1, 0)
        self.hip_reconfig_write = init_signal(hip_reconfig_write, 1)
        self.hip_reconfig_writedata = init_signal(hip_reconfig_writedata, 8)
        self.hip_reconfig_waitrequest = init_signal(hip_reconfig_waitrequest, 1, 0)

        # validate parameters
        assert self.dw in {256, 512}

        # rescale clock frequency
        if self.pld_clk_frequency is not None and self.pld_clk_frequency < 1e6:
            self.pld_clk_frequency *= 1e6

        if not self.pcie_generation or not self.pcie_link_width or not self.pld_clk_frequency:
            self.log.info("Incomplete configuration specified, attempting to select reasonable options")
            # guess some reasonable values for unspecified parameters
            for config in reversed(valid_configs):
                # find configuration matching specified parameters
                if self.pcie_generation is not None and self.pcie_generation != config[0]:
                    continue
                if self.pcie_link_width is not None and self.pcie_link_width != config[1]:
                    continue
                if self.dw != config[2]:
                    continue
                if self.pld_clk_frequency is not None and self.pld_clk_frequency != config[3]:
                    continue

                # set the unspecified parameters
                if self.pcie_generation is None:
                    self.log.info("Setting PCIe speed to gen %d", config[0])
                    self.pcie_generation = config[0]
                if self.pcie_link_width is None:
                    self.log.info("Setting PCIe link width to x%d", config[1])
                    self.pcie_link_width = config[1]
                if self.pld_clk_frequency is None:
                    self.log.info("Setting user clock frequency to %d MHz", config[3]/1e6)
                    self.pld_clk_frequency = config[3]
                break

        self.log.info("Intel Stratix 10 H-Tile/L-Tile PCIe hard IP core configuration:")
        self.log.info("  PCIe speed: gen %d", self.pcie_generation)
        self.log.info("  PCIe link width: x%d", self.pcie_link_width)
        self.log.info("  PLD clock frequency: %d MHz", self.pld_clk_frequency/1e6)
        self.log.info("  Tile: %s", "L-Tile" if self.l_tile else "H-Tile")
        self.log.info("  PF count: %d", self.pf_count)
        self.log.info("  Max payload size: %d", self.max_payload_size)
        self.log.info("  Enable extended tag: %s", self.enable_extended_tag)
        self.log.info("  Enable PF0 MSI: %s", self.pf0_msi_enable)
        self.log.info("  PF0 MSI vector count: %d", self.pf0_msi_count)
        self.log.info("  Enable PF1 MSI: %s", self.pf1_msi_enable)
        self.log.info("  PF1 MSI vector count: %d", self.pf1_msi_count)
        self.log.info("  Enable PF2 MSI: %s", self.pf2_msi_enable)
        self.log.info("  PF2 MSI vector count: %d", self.pf2_msi_count)
        self.log.info("  Enable PF3 MSI: %s", self.pf3_msi_enable)
        self.log.info("  PF3 MSI vector count: %d", self.pf3_msi_count)
        self.log.info("  Enable PF0 MSIX: %s", self.pf0_msix_enable)
        self.log.info("  PF0 MSIX table size: %d", self.pf0_msix_table_size)
        self.log.info("  PF0 MSIX table BIR: %d", self.pf0_msix_table_bir)
        self.log.info("  PF0 MSIX table offset: 0x%08x", self.pf0_msix_table_offset)
        self.log.info("  PF0 MSIX PBA BIR: %d", self.pf0_msix_pba_bir)
        self.log.info("  PF0 MSIX PBA offset: 0x%08x", self.pf0_msix_pba_offset)
        self.log.info("  Enable PF1 MSIX: %s", self.pf1_msix_enable)
        self.log.info("  PF1 MSIX table size: %d", self.pf1_msix_table_size)
        self.log.info("  PF1 MSIX table BIR: %d", self.pf1_msix_table_bir)
        self.log.info("  PF1 MSIX table offset: 0x%08x", self.pf1_msix_table_offset)
        self.log.info("  PF1 MSIX PBA BIR: %d", self.pf1_msix_pba_bir)
        self.log.info("  PF1 MSIX PBA offset: 0x%08x", self.pf1_msix_pba_offset)
        self.log.info("  Enable PF2 MSIX: %s", self.pf2_msix_enable)
        self.log.info("  PF2 MSIX table size: %d", self.pf2_msix_table_size)
        self.log.info("  PF2 MSIX table BIR: %d", self.pf2_msix_table_bir)
        self.log.info("  PF2 MSIX table offset: 0x%08x", self.pf2_msix_table_offset)
        self.log.info("  PF2 MSIX PBA BIR: %d", self.pf2_msix_pba_bir)
        self.log.info("  PF2 MSIX PBA offset: 0x%08x", self.pf2_msix_pba_offset)
        self.log.info("  Enable PF3 MSIX: %s", self.pf3_msix_enable)
        self.log.info("  PF3 MSIX table size: %d", self.pf3_msix_table_size)
        self.log.info("  PF3 MSIX table BIR: %d", self.pf3_msix_table_bir)
        self.log.info("  PF3 MSIX table offset: 0x%08x", self.pf3_msix_table_offset)
        self.log.info("  PF3 MSIX PBA BIR: %d", self.pf3_msix_pba_bir)
        self.log.info("  PF3 MSIX PBA offset: 0x%08x", self.pf3_msix_pba_offset)

        assert self.pcie_generation in {1, 2, 3}
        assert self.pcie_link_width in {1, 2, 4, 8, 16}
        assert self.pld_clk_frequency in {125e6, 250e6}

        # check for valid configuration
        config_valid = False
        for config in valid_configs:
            if self.pcie_generation != config[0]:
                continue
            if self.pcie_link_width != config[1]:
                continue
            if self.dw != config[2]:
                continue
            if self.pld_clk_frequency != config[3]:
                continue

            config_valid = True
            break

        assert config_valid, "link speed/link width/clock speed/interface width setting combination not valid"

        # configure port
        self.upstream_port.max_link_speed = self.pcie_generation
        self.upstream_port.max_link_width = self.pcie_link_width

        # configure functions

        self.make_function()

        if self.pf0_msi_enable:
            self.functions[0].msi_cap.msi_multiple_message_capable = (self.pf0_msi_count-1).bit_length()
        else:
            self.functions[0].deregister_capability(self.functions[0].msi_cap)

        if self.pf0_msix_enable:
            self.functions[0].msix_cap.msix_table_size = self.pf0_msix_table_size
            self.functions[0].msix_cap.msix_table_bar_indicator_register = self.pf0_msix_table_bir
            self.functions[0].msix_cap.msix_table_offset = self.pf0_msix_table_offset
            self.functions[0].msix_cap.msix_pba_bar_indicator_register = self.pf0_msix_pba_bir
            self.functions[0].msix_cap.msix_pba_offset = self.pf0_msix_pba_offset
        else:
            self.functions[0].deregister_capability(self.functions[0].msix_cap)

        if self.pf_count > 1:
            self.make_function()

            if self.pf1_msi_enable:
                self.functions[1].msi_cap.msi_multiple_message_capable = (self.pf1_msi_count-1).bit_length()
            else:
                self.functions[1].deregister_capability(self.functions[1].msi_cap)

            if self.pf1_msix_enable:
                self.functions[1].msix_cap.msix_table_size = self.pf1_msix_table_size
                self.functions[1].msix_cap.msix_table_bar_indicator_register = self.pf1_msix_table_bir
                self.functions[1].msix_cap.msix_table_offset = self.pf1_msix_table_offset
                self.functions[1].msix_cap.msix_pba_bar_indicator_register = self.pf1_msix_pba_bir
                self.functions[1].msix_cap.msix_pba_offset = self.pf1_msix_pba_offset
            else:
                self.functions[1].deregister_capability(self.functions[1].msix_cap)

        if self.pf_count > 2:
            self.make_function()

            if self.pf2_msi_enable:
                self.functions[2].msi_cap.msi_multiple_message_capable = (self.pf2_msi_count-2).bit_length()
            else:
                self.functions[2].deregister_capability(self.functions[2].msi_cap)

            if self.pf2_msix_enable:
                self.functions[2].msix_cap.msix_table_size = self.pf2_msix_table_size
                self.functions[2].msix_cap.msix_table_bar_indicator_register = self.pf2_msix_table_bir
                self.functions[2].msix_cap.msix_table_offset = self.pf2_msix_table_offset
                self.functions[2].msix_cap.msix_pba_bar_indicator_register = self.pf2_msix_pba_bir
                self.functions[2].msix_cap.msix_pba_offset = self.pf2_msix_pba_offset
            else:
                self.functions[2].deregister_capability(self.functions[2].msix_cap)

        if self.pf_count > 3:
            self.make_function()

            if self.pf3_msi_enable:
                self.functions[3].msi_cap.msi_multiple_message_capable = (self.pf3_msi_count-3).bit_length()
            else:
                self.functions[3].deregister_capability(self.functions[3].msi_cap)

            if self.pf3_msix_enable:
                self.functions[3].msix_cap.msix_table_size = self.pf3_msix_table_size
                self.functions[3].msix_cap.msix_table_bar_indicator_register = self.pf3_msix_table_bir
                self.functions[3].msix_cap.msix_table_offset = self.pf3_msix_table_offset
                self.functions[3].msix_cap.msix_pba_bar_indicator_register = self.pf3_msix_pba_bir
                self.functions[3].msix_cap.msix_pba_offset = self.pf3_msix_pba_offset
            else:
                self.functions[3].deregister_capability(self.functions[3].msix_cap)

        for f in self.functions:
            f.pcie_cap.max_payload_size_supported = (self.max_payload_size//128-1).bit_length()
            f.pcie_cap.extended_tag_supported = self.enable_extended_tag

        # fork coroutines

        if self.coreclkout_hip is not None:
            cocotb.start_soon(Clock(self.coreclkout_hip, int(1e9/self.pld_clk_frequency), units="ns").start())

        if self.rx_source:
            cocotb.start_soon(self._run_rx_logic())
        if self.tx_sink:
            cocotb.start_soon(self._run_tx_logic())
        if self.tx_pd_cdts:
            cocotb.start_soon(self._run_tx_fc_logic())
        if self.app_msi_req:
            cocotb.start_soon(self._run_int_logic())
        if self.tl_cfg_ctl:
            if self.l_tile:
                cocotb.start_soon(self._run_cfg_out_logic_ltile())
            else:
                cocotb.start_soon(self._run_cfg_out_logic_htile())

        cocotb.start_soon(self._run_reset())

    async def upstream_recv(self, tlp):
        self.log.debug("Got downstream TLP: %r", tlp)

        if tlp.fmt_type in {TlpType.CFG_READ_0, TlpType.CFG_WRITE_0}:
            # config type 0

            # capture address information
            self.bus_num = tlp.completer_id.bus

            # pass TLP to function
            for f in self.functions:
                if f.pcie_id == tlp.completer_id:
                    await f.upstream_recv(tlp)
                    return

            tlp.release_fc()

            self.log.warning("Function not found: failed to route config type 0 TLP: %r", tlp)
        elif tlp.fmt_type in {TlpType.CFG_READ_1, TlpType.CFG_WRITE_1}:
            # config type 1

            tlp.release_fc()

            self.log.warning("Malformed TLP: endpoint received config type 1 TLP: %r", tlp)
        elif tlp.fmt_type in {TlpType.CPL, TlpType.CPL_DATA, TlpType.CPL_LOCKED, TlpType.CPL_LOCKED_DATA}:
            # Completion

            for f in self.functions:
                if f.pcie_id == tlp.requester_id:

                    frame = S10PcieFrame.from_tlp(tlp)

                    frame.func_num = tlp.requester_id.function

                    # check and track buffer occupancy
                    data_fc = tlp.get_data_credits()

                    if self.rx_buf_cplh_fc_count+1 <= self.rx_buf_cplh_fc_limit and self.rx_buf_cpld_fc_count+data_fc <= self.rx_buf_cpld_fc_limit:
                        self.rx_buf_cplh_fc_count += 1
                        self.rx_buf_cpld_fc_count += data_fc
                        await self.rx_queue.put((tlp, frame))
                    else:
                        self.log.warning("No space in RX completion buffer, dropping TLP: CPLH %d (limit %d), CPLD %d (limit %d)",
                            self.rx_buf_cplh_fc_count, self.rx_buf_cplh_fc_limit, self.rx_buf_cpld_fc_count, self.rx_buf_cpld_fc_limit)

                    tlp.release_fc()

                    return

            tlp.release_fc()

            self.log.warning("Unexpected completion: failed to route completion to function: %r", tlp)
            return  # no UR response for completion
        elif tlp.fmt_type in {TlpType.IO_READ, TlpType.IO_WRITE}:
            # IO read/write

            for f in self.functions:
                bar = f.match_bar(tlp.address, True)
                if bar:

                    frame = S10PcieFrame.from_tlp(tlp)

                    frame.bar_range = 6
                    frame.func_num = tlp.requester_id.function

                    await self.rx_queue.put((tlp, frame))

                    tlp.release_fc()

                    return

            tlp.release_fc()

            self.log.warning("No BAR match: IO request did not match any BARs: %r", tlp)
        elif tlp.fmt_type in {TlpType.MEM_READ, TlpType.MEM_READ_64, TlpType.MEM_WRITE, TlpType.MEM_WRITE_64}:
            # Memory read/write

            for f in self.functions:
                bar = f.match_bar(tlp.address)
                if bar:

                    frame = S10PcieFrame.from_tlp(tlp)

                    frame.bar_range = bar[0]
                    frame.func_num = tlp.requester_id.function

                    await self.rx_queue.put((tlp, frame))

                    tlp.release_fc()

                    return

            tlp.release_fc()

            if tlp.fmt_type in {TlpType.MEM_WRITE, TlpType.MEM_WRITE_64}:
                self.log.warning("No BAR match: memory write request did not match any BARs: %r", tlp)
                return  # no UR response for write request
            else:
                self.log.warning("No BAR match: memory read request did not match any BARs: %r", tlp)
        else:
            raise Exception("TODO")

        # Unsupported request
        cpl = Tlp.create_ur_completion_for_tlp(tlp, PcieId(self.bus_num, 0, 0))
        self.log.debug("UR Completion: %r", cpl)
        await self.upstream_send(cpl)

    async def _run_reset(self):
        clock_edge_event = RisingEdge(self.coreclkout_hip)

        while True:
            await clock_edge_event
            await clock_edge_event

            if self.pld_clk_inuse is not None:
                self.pld_clk_inuse.value = 1
            if self.reset_status is not None:
                self.reset_status.value = 1
            if self.clr_st is not None:
                self.clr_st.value = 1

            if self.pin_perst is not None:
                if not self.pin_perst.value:
                    await RisingEdge(self.pin_perst)
                await First(FallingEdge(self.pin_perst), Timer(100, 'ns'))
                await First(FallingEdge(self.pin_perst), RisingEdge(self.coreclkout_hip))
                if not self.pin_perst.value:
                    continue
            else:
                await Timer(100, 'ns')
                await clock_edge_event

            if self.pld_clk_inuse is not None:
                self.pld_clk_inuse.value = 0
            if self.reset_status is not None:
                self.reset_status.value = 0
            if self.clr_st is not None:
                self.clr_st.value = 0

            if self.pin_perst is not None:
                await FallingEdge(self.pin_perst)
            else:
                return

    async def _run_rx_logic(self):
        while True:
            tlp, frame = await self.rx_queue.get()
            await self.rx_source.send(frame)

            self.rx_buf_cplh_fc_count = max(self.rx_buf_cplh_fc_count-1, 0)
            self.rx_buf_cpld_fc_count = max(self.rx_buf_cpld_fc_count-tlp.get_data_credits(), 0)

    async def _run_tx_logic(self):
        while True:
            frame = await self.tx_sink.recv()
            tlp = frame.to_tlp()
            await self.send(tlp)

    async def _run_tx_fc_logic(self):
        clock_edge_event = RisingEdge(self.coreclkout_hip)

        while True:
            if self.tx_ph_cdts is not None:
                self.tx_ph_cdts.value = self.upstream_port.fc_state[0].ph.tx_credits_available & 0xff
            if self.tx_pd_cdts is not None:
                self.tx_pd_cdts.value = self.upstream_port.fc_state[0].pd.tx_credits_available & 0xfff
            if self.tx_nph_cdts is not None:
                self.tx_nph_cdts.value = self.upstream_port.fc_state[0].nph.tx_credits_available & 0xff
            if self.tx_cplh_cdts is not None:
                self.tx_cplh_cdts.value = self.upstream_port.fc_state[0].cplh.tx_credits_available & 0xff
            if self.l_tile:
                if self.tx_npd_cdts is not None:
                    self.tx_npd_cdts.value = self.upstream_port.fc_state[0].npd.tx_credits_available & 0xfff
                if self.tx_cpld_cdts is not None:
                    self.tx_cpld_cdts.value = self.upstream_port.fc_state[0].cpld.tx_credits_available & 0xfff
            # self.tx_hdr_cdts_consumed
            # self.tx_data_cdts_consumed
            # self.tx_cdts_type
            # self.tx_cdts_data_value
            await clock_edge_event

    async def _run_status_logic(self):
        pass

        # Hard IP status
        # int_status
        # int_status_common
        # derr_cor_ext_rpl
        # derr_rpl
        # derr_cor_ext_rcv
        # derr_uncor_ext_rcv
        # rx_par_err
        # tx_par_err
        # ltssmstate
        # link_up
        # lane_act
        # currentspeed

    async def _run_pm_logic(self):
        pass

        # Power management
        # pm_linkst_in_l1
        # pm_linkst_in_l0s
        # pm_state
        # pm_dstate
        # apps_pm_xmt_pme
        # apps_ready_entr_l23
        # apps_pm_xmt_turnoff
        # app_init_rst
        # app_xfer_pending

    async def _run_int_logic(self):
        clock_edge_event = RisingEdge(self.coreclkout_hip)

        while True:
            await clock_edge_event

            # Interrupt interface
            while not self.app_msi_req.value.integer:
                await RisingEdge(self.app_msi_req)
                await clock_edge_event

            # issue MSI interrupt
            app_msi_func_num = self.app_msi_func_num.value.integer
            app_msi_num = self.app_msi_num.value.integer
            app_msi_tc = self.app_msi_tc.value.integer
            await self.functions[app_msi_func_num].msi_cap.issue_msi_interrupt(app_msi_num, tc=app_msi_tc)

            self.app_msi_ack.value = 1
            await clock_edge_event
            self.app_msi_ack.value = 0

            while self.app_msi_req.value.integer:
                await clock_edge_event

    # Error interface
    # app_err_valid
    # app_err_hdr
    # app_err_info
    # app_err_func_num

    async def _run_cfg_out_logic_htile(self):
        clock_edge_event = RisingEdge(self.coreclkout_hip)

        while True:
            for func in self.functions:
                self.tl_cfg_func.value = func.pcie_id.function

                self.tl_cfg_add.value = 0x00
                val = bool(func.pcie_cap.ido_request_enable) << 31
                val |= bool(func.pcie_cap.enable_no_snoop) << 30
                val |= bool(func.pcie_cap.enable_relaxed_ordering) << 29
                val |= (func.pcie_id.device & 0x1f) << 24
                val |= (func.pcie_id.bus & 0xff) << 16
                val |= bool(func.memory_space_enable) << 15
                val |= bool(func.pcie_cap.ido_completion_enable) << 14
                val |= bool(func.parity_error_response_enable) << 13
                val |= bool(func.serr_enable) << 12
                val |= bool(func.pcie_cap.fatal_error_reporting_enable) << 11
                val |= bool(func.pcie_cap.non_fatal_error_reporting_enable) << 10
                val |= bool(func.pcie_cap.correctable_error_reporting_enable) << 9
                val |= bool(func.pcie_cap.unsupported_request_reporting_enable) << 8
                val |= bool(func.bus_master_enable) << 7
                val |= bool(func.pcie_cap.extended_tag_field_enable) << 6
                val |= (func.pcie_cap.max_read_request_size & 0x7) << 3
                val |= (func.pcie_cap.max_payload_size & 0x7)
                self.tl_cfg_ctl.value = val
                await clock_edge_event

                self.tl_cfg_add.value = 0x01
                # num vfs
                val = bool(func.pm_cap.no_soft_reset) << 15
                val |= bool(func.pcie_cap.read_completion_boundary) << 14
                val |= bool(func.interrupt_disable) << 13
                val |= (func.pcie_cap.interrupt_message_number & 0x1f) << 8
                val |= bool(func.pcie_cap.power_controller_control) << 4
                val |= (func.pcie_cap.attention_indicator_control & 0x3) << 2
                val |= func.pcie_cap.power_indicator_control & 0x3
                self.tl_cfg_ctl.value = val
                await clock_edge_event

                self.tl_cfg_add.value = 0x02
                val = (func.pcie_cap.current_link_speed & 0xf) << 28
                # start vf
                # ats
                val |= bool(func.pcie_cap.ari_forwarding_enable) << 7
                val |= bool(func.pcie_cap.atomic_op_requester_enable) << 6
                # tph
                # vf en
                self.tl_cfg_ctl.value = val
                await clock_edge_event

                self.tl_cfg_add.value = 0x03
                self.tl_cfg_ctl.value = func.msi_cap.msi_message_address & 0xffffffff
                await clock_edge_event

                self.tl_cfg_add.value = 0x04
                self.tl_cfg_ctl.value = (func.msi_cap.msi_message_address >> 32) & 0xffffffff
                await clock_edge_event

                self.tl_cfg_add.value = 0x05
                self.tl_cfg_ctl.value = func.msi_cap.msi_mask_bits
                await clock_edge_event

                self.tl_cfg_add.value = 0x06
                val = (func.msi_cap.msi_message_data & 0xffff) << 16
                val |= bool(func.pcie_cap.system_error_on_fatal_error_enable) << 15
                val |= bool(func.pcie_cap.system_error_on_non_fatal_error_enable) << 14
                val |= bool(func.pcie_cap.system_error_on_correctable_error_enable) << 13
                val |= (func.aer_ext_cap.advanced_error_interrupt_message_number & 0x1f) << 8
                val |= bool(func.msix_cap.msix_function_mask) << 6
                val |= bool(func.msix_cap.msix_enable) << 5
                val |= (func.msi_cap.msi_multiple_message_enable & 0x7) << 2
                val |= bool(func.msi_cap.msi_64bit_address_capable) << 1
                val |= bool(func.msi_cap.msi_enable)
                self.tl_cfg_ctl.value = val
                await clock_edge_event

                self.tl_cfg_add.value = 0x07
                # AER uncorrectable error mask
                self.tl_cfg_ctl.value = await func.aer_ext_cap.read_register(2)
                await clock_edge_event

                self.tl_cfg_add.value = 0x08
                # AER correctable error mask
                self.tl_cfg_ctl.value = await func.aer_ext_cap.read_register(5)
                await clock_edge_event

                self.tl_cfg_add.value = 0x09
                # AER uncorrectable error severity
                self.tl_cfg_ctl.value = await func.aer_ext_cap.read_register(3)
                await clock_edge_event

    async def _run_cfg_out_logic_ltile(self):
        clock_edge_event = RisingEdge(self.coreclkout_hip)

        while True:
            for func in self.functions:
                self.tl_cfg_func.value = func.pcie_id.function

                self.tl_cfg_add.value = 0x00
                val = bool(func.pcie_cap.ido_request_enable) << 31
                val |= bool(func.pcie_cap.enable_no_snoop) << 30
                val |= bool(func.pcie_cap.enable_relaxed_ordering) << 29
                val |= (func.pcie_id.device & 0x1f) << 24
                val |= (func.pcie_id.bus & 0xff) << 16
                val |= bool(func.memory_space_enable) << 15
                val |= bool(func.pcie_cap.ido_completion_enable) << 14
                val |= (func.pcie_cap.negotiated_link_width & 0x3f) << 8
                val |= bool(func.bus_master_enable) << 7
                val |= bool(func.pcie_cap.extended_tag_field_enable) << 6
                val |= (func.pcie_cap.max_read_request_size & 0x7) << 3
                val |= (func.pcie_cap.max_payload_size & 0x7)
                self.tl_cfg_ctl.value = val
                await clock_edge_event

                self.tl_cfg_add.value = 0x01
                val = bool(func.pcie_cap.system_error_on_fatal_error_enable) << 31
                val |= bool(func.pcie_cap.system_error_on_non_fatal_error_enable) << 30
                val |= bool(func.pcie_cap.system_error_on_correctable_error_enable) << 29
                val |= (func.aer_ext_cap.advanced_error_interrupt_message_number & 0x1f) << 28
                val |= (func.pcie_cap.negotiated_link_width & 0x3f) << 18
                val |= bool(func.pm_cap.no_soft_reset) << 17
                val |= bool(func.pcie_cap.read_completion_boundary) << 16
                val |= bool(func.interrupt_disable) << 13
                val |= (func.pcie_cap.interrupt_message_number & 0x1f) << 8
                val |= bool(func.pcie_cap.power_controller_control) << 4
                val |= (func.pcie_cap.attention_indicator_control & 0x3) << 2
                val |= func.pcie_cap.power_indicator_control & 0x3
                self.tl_cfg_ctl.value = val
                await clock_edge_event

                self.tl_cfg_add.value = 0x02
                # start vf
                # num vfs
                val = (func.pcie_cap.current_link_speed & 0xf) << 12
                # ats
                val |= bool(func.pcie_cap.ari_forwarding_enable) << 5
                val |= bool(func.pcie_cap.atomic_op_requester_enable) << 4
                # tph
                # vf en
                self.tl_cfg_ctl.value = val
                await clock_edge_event

                self.tl_cfg_add.value = 0x03
                self.tl_cfg_ctl.value = func.msi_cap.msi_message_address & 0xffffffff
                await clock_edge_event

                self.tl_cfg_add.value = 0x04
                self.tl_cfg_ctl.value = (func.msi_cap.msi_message_address >> 32) & 0xffffffff
                await clock_edge_event

                self.tl_cfg_add.value = 0x05
                self.tl_cfg_ctl.value = func.msi_cap.msi_mask_bits
                await clock_edge_event

                self.tl_cfg_add.value = 0x06
                val = (func.msi_cap.msi_message_data & 0xffff) << 16
                val |= bool(func.msix_cap.msix_function_mask) << 6
                val |= bool(func.msix_cap.msix_enable) << 5
                val |= (func.msi_cap.msi_multiple_message_enable & 0x7) << 2
                val |= bool(func.msi_cap.msi_64bit_address_capable) << 1
                val |= bool(func.msi_cap.msi_enable)
                self.tl_cfg_ctl.value = val
                await clock_edge_event

                self.tl_cfg_add.value = 0x07
                val = (func.pcie_cap.current_link_speed & 0xf) << 6
                val |= func.pcie_cap.negotiated_link_width & 0x3f
                self.tl_cfg_ctl.value = val
                await clock_edge_event

    # Configuration extension bus
    # ceb_req
    # ceb_ack
    # ceb_addr
    # ceb_din
    # ceb_dout
    # ceb_wr
    # ceb_cdm_convert_data
    # ceb_func_num
    # ceb_vf_num
    # ceb_vf_active

    # Hard IP reconfiguration interface
    # hip_reconfig_clk
    # hip_reconfig_rst_n
    # hip_reconfig_address
    # hip_reconfig_read
    # hip_reconfig_readdata
    # hip_reconfig_readdatavalid
    # hip_reconfig_write
    # hip_reconfig_writedata
    # hip_reconfig_waitrequest



================================================
FILE: cocotbext/pcie/xilinx/us/__init__.py
================================================
"""

Copyright (c) 2020 Alex Forencich

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

"""

from .us_model import UltraScalePcieDevice, UltraScalePcieFunction
from .usp_model import UltraScalePlusPcieDevice, UltraScalePlusPcieFunction



================================================
FILE: cocotbext/pcie/xilinx/us/interface.py
================================================
"""

Copyright (c) 2020 Alex Forencich

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

"""

import logging

import cocotb
from cocotb.queue import Queue, QueueFull
from cocotb.triggers import RisingEdge, Timer, First, Event


def dword_parity(d):
    d ^= d >> 4
    d ^= d >> 2
    d ^= d >> 1
    p = d & 0x1
    if d & 0x100:
        p |= 0x2
    if d & 0x10000:
        p |= 0x4
    if d & 0x1000000:
        p |= 0x8
    return p


class UsPcieFrame:
    def __init__(self, frame=None):
        self.data = []
        self.byte_en = []
        self.parity = []
        self.first_be = 0
        self.last_be = 0
        self.discontinue = False
        self.seq_num = 0

        if isinstance(frame, UsPcieFrame):
            self.data = list(frame.data)
            self.byte_en = list(frame.byte_en)
            self.parity = list(frame.parity)
            self.first_be = frame.first_be
            self.last_be = frame.last_be
            self.discontinue = frame.discontinue
            self.seq_num = frame.seq_num

    def update_parity(self):
        self.parity = [dword_parity(d) ^ 0xf for d in self.data]

    def check_parity(self):
        return self.parity == [dword_parity(d) ^ 0xf for d in self.data]

    def __eq__(self, other):
        if isinstance(other, UsPcieFrame):
            return (
                self.data == other.data and
                self.byte_en == other.byte_en and
                self.parity == other.parity and
                self.first_be == other.first_be and
                self.last_be == other.last_be and
                self.discontinue == other.discontinue and
                self.seq_num == other.seq_num
            )
        return False

    def __repr__(self):
        return (
            f"{type(self).__name__}(data=[{', '.join(f'{x:#010x}' for x in self.data)}], "
            f"byte_en=[{', '.join(hex(x) for x in self.byte_en)}], "
            f"parity=[{', '.join(hex(x) for x in self.parity)}], "
            f"first_be={self.first_be:#x}, "
            f"last_be={self.last_be:#x}, "
            f"discontinue={self.discontinue}, "
            f"seq_num={self.seq_num})"
        )

    def __len__(self):
        return len(self.data)


class UsPcieTransaction:

    _signals = ["tdata", "tlast", "tkeep", "tuser"]

    def __init__(self, *args, **kwargs):
        for sig in self._signals:
            if sig in kwargs:
                setattr(self, sig, kwargs[sig])
                del kwargs[sig]
            else:
                setattr(self, sig, 0)

        super().__init__(*args, **kwargs)

    def __repr__(self):
        return f"{type(self).__name__}({', '.join(f'{s}={int(getattr(self, s))}' for s in self._signals)})"


class UsPcieBase:

    _signal_widths = {"tvalid": 1, "tready": 1}

    _valid_signal = "tvalid"
    _ready_signal = "tready"

    _transaction_obj = UsPcieTransaction
    _frame_obj = UsPcieFrame

    def __init__(self, bus, clock, reset=None, segments=1, *args, **kwargs):
        self.bus = bus
        self.clock = clock
        self.reset = reset
        if bus._name:
            self.log = logging.getLogger(f"cocotb.{bus._entity._name}.{bus._name}")
        else:
            self.log = logging.getLogger(f"cocotb.{bus._entity._name}")

        super().__init__(*args, **kwargs)

        self.active = False
        self.queue = Queue()
        self.dequeue_event = Event()
        self.idle_event = Event()
        self.idle_event.set()
        self.active_event = Event()
        self.bus_active_event = Event()
        self.wake_event = Event()

        self._pause = False
        self._pause_generator = None
        self._pause_cr = None

        self.queue_occupancy_bytes = 0
        self.queue_occupancy_frames = 0

        self.width = len(self.bus.tdata)
        self.byte_lanes = len(self.bus.tkeep)

        self.byte_size = self.width // self.byte_lanes
        self.byte_mask = 2**self.byte_size-1

        self.seg_count = segments
        self.seg_width = self.width // self.seg_count
        self.seg_mask = 2**self.seg_width-1
        self.seg_byte_lanes = self.byte_lanes // self.seg_count
        self.seg_par_width = self.seg_width // 8
        self.seg_par_mask = 2**self.seg_par_width-1

        assert self.width in {64, 128, 256, 512}
        assert self.byte_size == 32

    def _init(self):
        pass

    def count(self):
        return self.queue.qsize()

    def empty(self):
        return self.queue.empty()

    def clear(self):
        while not self.queue.empty():
            self.queue.get_nowait()
        self.idle_event.set()
        self.active_event.clear()

    def idle(self):
        raise NotImplementedError()

    async def wait(self):
        raise NotImplementedError()

    def _pause_update(self, val):
        pass

    @property
    def pause(self):
        return self._pause

    @pause.setter
    def pause(self, val):
        if self._pause != val:
            self._pause_update(val)
        self._pause = val

    def set_pause_generator(self, generator=None):
        if self._pause_cr is not None:
            self._pause_cr.kill()
            self._pause_cr = None

        self._pause_generator = generator

        if self._pause_generator is not None:
            self._pause_cr = cocotb.start_soon(self._run_pause())

    def clear_pause_generator(self):
        self.set_pause_generator(None)

    async def _run_pause(self):
        clock_edge_event = RisingEdge(self.clock)

        for val in self._pause_generator:
            self.pause = val
            await clock_edge_event


class UsPcieSource(UsPcieBase):

    _signal_widths = {"tvalid": 1, "tready": 1}

    _valid_signal = "tvalid"
    _ready_signal = "tready"

    _transaction_obj = UsPcieTransaction
    _frame_obj = UsPcieFrame

    def __init__(self, bus, clock, reset=None, segments=1, *args, **kwargs):
        super().__init__(bus, clock, reset, segments, *args, **kwargs)

        self.drive_obj = None
        self.drive_sync = Event()

        self.queue_occupancy_limit_bytes = -1
        self.queue_occupancy_limit_frames = -1

        self.bus.tdata.setimmediatevalue(0)
        self.bus.tvalid.setimmediatevalue(0)
        self.bus.tlast.setimmediatevalue(0)
        self.bus.tkeep.setimmediatevalue(0)
        self.bus.tuser.setimmediatevalue(0)

        self._init()

        cocotb.start_soon(self._run_source())
        cocotb.start_soon(self._run())

    async def _drive(self, obj):
        if self.drive_obj is not None:
            self.drive_sync.clear()
            await self.drive_sync.wait()

        self.drive_obj = obj
        self.bus_active_event.set()

    async def send(self, frame):
        while self.full():
            self.dequeue_event.clear()
            await self.dequeue_event.wait()
        frame = UsPcieFrame(frame)
        await self.queue.put(frame)
        self.idle_event.clear()
        self.queue_occupancy_bytes += len(frame)
        self.queue_occupancy_frames += 1

    def send_nowait(self, frame):
        if self.full():
            raise QueueFull()
        frame = UsPcieFrame(frame)
        self.queue.put_nowait(frame)
        self.idle_event.clear()
        self.queue_occupancy_bytes += len(frame)
        self.queue_occupancy_frames += 1

    def full(self):
        if self.queue_occupancy_limit_bytes > 0 and self.queue_occupancy_bytes > self.queue_occupancy_limit_bytes:
            return True
        elif self.queue_occupancy_limit_frames > 0 and self.queue_occupancy_frames > self.queue_occupancy_limit_frames:
            return True
        else:
            return False

    def idle(self):
        return self.empty() and not self.active

    async def wait(self):
        await self.idle_event.wait()

    async def _run_source(self):
        self.active = False

        clock_edge_event = RisingEdge(self.clock)

        while True:
            await clock_edge_event

            # read handshake signals
            tready_sample = self.bus.tready.value
            tvalid_sample = self.bus.tvalid.value

            if self.reset is not None and self.reset.value:
                self.active = False
                self.bus.tvalid.value = 0
                continue

            if (tready_sample and tvalid_sample) or not tvalid_sample:
                if self.drive_obj and not self.pause:
                    self.bus.drive(self.drive_obj)
                    self.drive_obj = None
                    self.drive_sync.set()
                    self.bus.tvalid.value = 1
                    self.active = True
                else:
                    self.bus.tvalid.value = 0
                    self.active = bool(self.drive_obj)
                    if not self.drive_obj:
                        self.idle_event.set()
                        self.bus_active_event.clear()

                        await self.bus_active_event.wait()

    async def _run(self):
        raise NotImplementedError

    async def _get_frame(self):
        frame = await self.queue.get()
        self.dequeue_event.set()
        self.queue_occupancy_bytes -= len(frame)
        self.queue_occupancy_frames -= 1
        return frame

    def _get_frame_nowait(self):
        frame = self.queue.get_nowait()
        self.dequeue_event.set()
        self.queue_occupancy_bytes -= len(frame)
        self.queue_occupancy_frames -= 1
        return frame


class UsPcieSink(UsPcieBase):

    _signal_widths = {"tvalid": 1, "tready": 1}

    _valid_signal = "tvalid"
    _ready_signal = "tready"

    _transaction_obj = UsPcieTransaction
    _frame_obj = UsPcieFrame

    def __init__(self, bus, clock, reset=None, segments=1, *args, **kwargs):
        super().__init__(bus, clock, reset, segments, *args, **kwargs)

        self.sample_obj = None
        self.sample_sync = Event()

        self.queue_occupancy_limit_bytes = -1
        self.queue_occupancy_limit_frames = -1

        self.bus.tready.setimmediatevalue(0)

        self._init()

        cocotb.start_soon(self._run_sink())
        cocotb.start_soon(self._run())

        if hasattr(self.bus, "tvalid"):
            cocotb.start_soon(self._run_tvalid_monitor())
        if hasattr(self.bus, "tready"):
            cocotb.start_soon(self._run_tready_monitor())

    def _pause_update(self, val):
        self.wake_event.set()

    def _dequeue(self, frame):
        self.wake_event.set()

    def _recv(self, frame):
        if self.queue.empty():
            self.active_event.clear()
        self.queue_occupancy_bytes -= len(frame)
        self.queue_occupancy_frames -= 1
        self._dequeue(frame)
        return frame

    async def recv(self):
        frame = await self.queue.get()
        return self._recv(frame)

    def recv_nowait(self):
        frame = self.queue.get_nowait()
        return self._recv(frame)

    def full(self):
        if self.queue_occupancy_limit_bytes > 0 and self.queue_occupancy_bytes > self.queue_occupancy_limit_bytes:
            return True
        elif self.queue_occupancy_limit_frames > 0 and self.queue_occupancy_frames > self.queue_occupancy_limit_frames:
            return True
        else:
            return False

    def idle(self):
        return not self.active

    async def wait(self, timeout=0, timeout_unit='ns'):
        if not self.empty():
            return
        if timeout:
            await First(self.active_event.wait(), Timer(timeout, timeout_unit))
        else:
            await self.active_event.wait()

    async def _run_tvalid_monitor(self):
        event = RisingEdge(self.bus.tvalid)

        while True:
            await event
            self.wake_event.set()

    async def _run_tready_monitor(self):
        event = RisingEdge(self.bus.tready)

        while True:
            await event
            self.wake_event.set()

    async def _run_sink(self):
        clock_edge_event = RisingEdge(self.clock)

        wake_event = self.wake_event.wait()

        while True:
            pause_sample = bool(self.pause)

            await clock_edge_event

            # read handshake signals
            tready_sample = self.bus.tready.value
            tvalid_sample = self.bus.tvalid.value

            if self.reset is not None and self.reset.value:
                self.bus.tready.value = 0
                continue

            if tready_sample and tvalid_sample:
                self.sample_obj = self._transaction_obj()
                self.bus.sample(self.sample_obj)
                self.sample_sync.set()

            paused = self.full() or pause_sample

            self.bus.tready.value = not paused

            if (not tvalid_sample or paused) and (pause_sample == bool(self.pause)):
                self.wake_event.clear()
                await wake_event

    async def _run(self):
        raise NotImplementedError()

    def _sink_frame(self, frame):
        self.queue_occupancy_bytes += len(frame)
        self.queue_occupancy_frames += 1

        self.queue.put_nowait(frame)
        self.active_event.set()


class RqSource(UsPcieSource):
    def _init(self):

        if self.width == 512:
            assert len(self.bus.tuser) == 137
            assert self.seg_count in {1, 2}
            self.discontinue_offset = 36
            self.parity_offset = 73
        else:
            assert len(self.bus.tuser) in [60, 62]
            assert self.seg_count == 1
            self.discontinue_offset = 11
            self.parity_offset = 28

    async def _run(self):
        while True:
            frame = await self._get_frame()
            frame_offset = 0
            self.log.info("TX RQ frame: %r", frame)
            first = True

            while frame is not None:
                transaction = self._transaction_obj()
                sop_cnt = 0
                eop_cnt = 0

                for seg in range(self.seg_count):
                    if frame is None:
                        if not self.empty():
                            frame = self._get_frame_nowait()
                            frame_offset = 0
                            self.log.info("TX RQ frame: %r", frame)
                            first = True
                        else:
                            break

                    if first:
                        first = False

                        if self.width == 512:
                            transaction.tuser |= (frame.first_be & 0xf) << (sop_cnt*4)
                            transaction.tuser |= (frame.last_be & 0xf) << (sop_cnt*4+8)
                            # addr_offset
                            transaction.tuser |= (frame.seq_num & 0x3f) << (sop_cnt*6+61)

                            # is_sop
                            transaction.tuser |= 1 << 20+sop_cnt
                            # is_sop_ptr
                            transaction.tuser |= (seg*self.seg_byte_lanes//4) << 22+sop_cnt*2
                        else:
                            transaction.tuser |= (frame.first_be & 0xf)
                            transaction.tuser |= (frame.last_be & 0xf) << 4
                            # addr_offset
                            transaction.tuser |= (frame.seq_num & 0xf) << 24

                            if len(self.bus.tuser) == 62:
                                transaction.tuser |= ((frame.seq_num >> 4) & 0x3) << 60

                        sop_cnt += 1

                    if frame.discontinue:
                        transaction.tuser |= 1 << self.discontinue_offset

                    last_lane = 0
                    for k in range(self.seg_byte_lanes):
                        lane = k+seg*self.seg_byte_lanes
                        if frame_offset < len(frame.data):
                            transaction.tdata |= frame.data[frame_offset] << lane*32
                            transaction.tkeep |= 1 << lane
                            transaction.tuser |= frame.parity[frame_offset] << lane*4+self.parity_offset
                            frame_offset += 1
                            last_lane = lane
                        else:
                            transaction.tuser |= 0xf << lane*4+self.parity_offset

                    if frame_offset >= len(frame.data):
                        # eop
                        if self.width == 512:
                            # is_eop
                            transaction.tuser |= 1 << 26+eop_cnt
                            # is_eop_ptr
                            transaction.tuser |= last_lane << 28+eop_cnt*4

                        eop_cnt += 1

                        if self.seg_count == 1:
                            transaction.tlast = 1

                        frame = None

                await self._drive(transaction)


class RqSink(UsPcieSink):
    def _init(self):

        if self.width == 512:
            assert len(self.bus.tuser) == 137
            assert self.seg_count in {1, 2}
            self.discontinue_offset = 36
            self.parity_offset = 73
        else:
            assert len(self.bus.tuser) in [60, 62]
            assert self.seg_count == 1
            self.discontinue_offset = 11
            self.parity_offset = 28

    async def _run(self):
        self.active = False
        frame = UsPcieFrame()

        while True:
            while not self.sample_obj:
                self.sample_sync.clear()
                await self.sample_sync.wait()

            self.active = True
            sample = self.sample_obj
            self.sample_obj = None

            lane_valid = 2**self.byte_lanes-1
            seg_valid = 2**self.seg_count-1
            seg_sop = 0
            seg_eop = 0
            sop_cnt = 0

            if self.seg_count == 1:
                lane_valid = sample.tkeep
                seg_valid = 1

                if not frame:
                    seg_sop = 1

                if sample.tlast:
                    seg_eop = 1
            elif self.width == 512:
                sop_byte_lane = 0
                eop_byte_lane = 0
                for k in range(self.seg_count):
                    if sample.tuser & (1 << (20+k)):
                        offset = (sample.tuser >> (22+k*2)) & 0x3
                        sop_byte_lane |= 1 << (offset*4)
                    if sample.tuser & (1 << (26+k)):
                        offset = (sample.tuser >> (28+k*4)) & 0xf
                        eop_byte_lane |= 1 << offset
                lane_valid = 0
                seg_valid = 0
                state = 1
                for k in range(self.byte_lanes):
                    mask = 1 << k
                    seg_mask = 1 << (k // self.seg_byte_lanes)
                    if sop_byte_lane & mask:
                        state = 1
                        seg_sop |= seg_mask
                    if state:
                        lane_valid |= mask
                        seg_valid |= seg_mask
                    if eop_byte_lane & mask:
                        state = 0
                        seg_eop |= seg_mask

            for seg in range(self.seg_count):
                if not seg_valid & (1 << seg):
                    continue

                if seg_sop & (1 << seg):
                    frame = UsPcieFrame()

                    if self.width == 512:
                        frame.first_be = (sample.tuser >> (sop_cnt*4)) & 0xf
                        frame.last_be = (sample.tuser >> (sop_cnt*4+8)) & 0xf
                        # addr_offset
                        frame.seq_num = (sample.tuser >> (sop_cnt*6+61)) & 0x3f
                    else:
                        frame.first_be = sample.tuser & 0xf
                        frame.last_be = (sample.tuser >> 4) & 0xf
                        # addr_offset
                        frame.seq_num = (sample.tuser >> 24) & 0xf

                        if len(self.bus.tuser) == 62:
                            frame.seq_num |= ((sample.tuser >> 60) & 0x3) << 4

                    sop_cnt += 1

                if sample.tuser & (1 << self.discontinue_offset):
                    frame.discontinue = True

                for k in range(self.seg_byte_lanes):
                    lane = k+seg*self.seg_byte_lanes
                    if lane_valid & (1 << lane):
                        frame.data.append((sample.tdata >> lane*32) & 0xffffffff)
                        frame.parity.append((sample.tuser >> (lane*4+self.parity_offset)) & 0xf)

                if seg_eop & (1 << seg):
                    self.log.info("RX RQ frame: %r", frame)
                    self._sink_frame(frame)
                    self.active = False
                    frame = None


class RcSource(UsPcieSource):
    def _init(self):

        if self.width == 512:
            assert len(self.bus.tuser) == 161
            assert self.seg_count in {1, 2, 4}
            self.discontinue_offset = 96
            self.parity_offset = 97
        else:
            assert len(self.bus.tuser) == 75
            assert self.seg_count in {1, 2}
            self.discontinue_offset = 42
            self.parity_offset = 43

    async def _run(self):
        while True:
            frame = await self._get_frame()
            frame_offset = 0
            self.log.info("TX RC frame: %r", frame)
            first = True

            while frame is not None:
                transaction = self._transaction_obj()
                sop_cnt = 0
                eop_cnt = 0

                for seg in range(self.seg_count):
                    if frame is None:
                        if not self.empty():
                            frame = self._get_frame_nowait()
                            frame_offset = 0
                            self.log.info("TX RC frame: %r", frame)
                            first = True
                        else:
                            break

                    if first:
                        first = False

                        if self.width == 512:
                            # is_sop
                            transaction.tuser |= 1 << 64+sop_cnt
                            # is_sop_ptr
                            transaction.tuser |= (seg*self.seg_byte_lanes//4) << 68+sop_cnt*2
                        else:
                            # is_sop
                            transaction.tuser |= 1 << 32+sop_cnt

                        sop_cnt += 1

                    if frame.discontinue:
                        transaction.tuser |= 1 << self.discontinue_offset

                    last_lane = 0
                    for k in range(self.seg_byte_lanes):
                        lane = k+seg*self.seg_byte_lanes
                        if frame_offset < len(frame.data):
                            transaction.tdata |= frame.data[frame_offset] << lane*32
                            transaction.tkeep |= 1 << lane
                            transaction.tuser |= frame.byte_en[frame_offset] << lane*4
                            transaction.tuser |= frame.parity[frame_offset] << lane*4+self.parity_offset
                            frame_offset += 1
                            last_lane = lane
                        else:
                            transaction.tuser |= 0xf << lane*4+self.parity_offset

                    if frame_offset >= len(frame.data):
                        if self.width == 512:
                            # is_eop
                            transaction.tuser |= 1 << 76+eop_cnt
                            # is_eop_ptr
                            transaction.tuser |= last_lane << 80+eop_cnt*4
                        else:
                            # is_eop
                            transaction.tuser |= 1 << 34+eop_cnt*4
                            transaction.tuser |= last_lane << 35+eop_cnt*4

                        eop_cnt += 1

                        if self.seg_count == 1:
                            transaction.tlast = 1

                        frame = None

                await self._drive(transaction)


class RcSink(UsPcieSink):
    def _init(self):

        if self.width == 512:
            assert len(self.bus.tuser) == 161
            assert self.seg_count in {1, 2, 4}
            self.discontinue_offset = 96
            self.parity_offset = 97
        else:
            assert len(self.bus.tuser) == 75
            assert self.seg_count in {1, 2}
            self.discontinue_offset = 42
            self.parity_offset = 43

    async def _run(self):
        self.active = False
        frame = None

        while True:
            while not self.sample_obj:
                self.sample_sync.clear()
                await self.sample_sync.wait()

            self.active = True
            sample = self.sample_obj
            self.sample_obj = None

            lane_valid = 2**self.byte_lanes-1
            seg_valid = 2**self.seg_count-1
            seg_sop = 0
            seg_eop = 0

            if self.seg_count == 1:
                lane_valid = sample.tkeep
                seg_valid = 1

                if not frame:
                    seg_sop = 1

                if sample.tlast:
                    seg_eop = 1
            elif self.width >= 256:
                sop_byte_lane = 0
                eop_byte_lane = 0
                if self.width == 256:
                    if self.seg_count == 1:
                        if sample.tuser & (1 << 32):
                            sop_byte_lane |= 1 << 0
                    else:
                        if sample.tuser & (1 << 32):
                            sop_byte_lane |= 1 << (4 if frame is not None else 0)
                        if sample.tuser & (2 << 32):
                            sop_byte_lane |= 1 << 4
                    for k in range(self.seg_count):
                        if sample.tuser & (1 << (34+k*4)):
                            offset = ((sample.tuser >> (35+k*4)) & 0x7)
                            eop_byte_lane |= 1 << offset
                elif self.width == 512:
                    for k in range(self.seg_count):
                        if sample.tuser & (1 << (64+k)):
                            offset = ((sample.tuser >> (68+k*2)) & 0x3)
                            sop_byte_lane |= 1 << (offset * 4)
                        if sample.tuser & (1 << (76+k)):
                            offset = ((sample.tuser >> (80+k*4)) & 0xf)
                            eop_byte_lane |= 1 << offset
                lane_valid = 0
                seg_valid = 0
                state = 1
                for k in range(self.byte_lanes):
                    mask = 1 << k
                    seg_mask = 1 << (k // self.seg_byte_lanes)
                    if sop_byte_lane & mask:
                        state = 1
                        seg_sop |= seg_mask
                    if state:
                        lane_valid |= mask
                        seg_valid |= seg_mask
                    if eop_byte_lane & mask:
                        state = 0
                        seg_eop |= seg_mask

            for seg in range(self.seg_count):
                if not seg_valid & (1 << seg):
                    continue

                if seg_sop & (1 << seg):
                    frame = UsPcieFrame()

                if sample.tuser & (1 << self.discontinue_offset):
                    frame.discontinue = True

                for k in range(self.seg_byte_lanes):
                    lane = k+seg*self.seg_byte_lanes
                    if lane_valid & (1 << lane):
                        frame.data.append((sample.tdata >> lane*32) & 0xffffffff)
                        frame.byte_en.append((sample.tuser >> (lane*4)) & 0xf)
                        frame.parity.append((sample.tuser >> (lane*4+self.parity_offset)) & 0xf)

                if seg_eop & (1 << seg):
                    self.log.info("RX RC frame: %r", frame)
                    self._sink_frame(frame)
                    self.active = False
                    frame = None


class CqSource(UsPcieSource):
    def _init(self):

        if self.width == 512:
            assert len(self.bus.tuser) == 183
            assert self.seg_count in {1, 2}
            self.byte_en_offset = 16
            self.discontinue_offset = 96
            self.parity_offset = 119
        else:
            assert len(self.bus.tuser) in [85, 88]
            assert self.seg_count == 1
            self.byte_en_offset = 8
            self.discontinue_offset = 41
            self.parity_offset = 53

    async def _run(self):
        while True:
            frame = await self._get_frame()
            frame_offset = 0
            self.log.info("TX CQ frame: %r", frame)
            first = True

            while frame is not None:
                transaction = self._transaction_obj()
                sop_cnt = 0
                eop_cnt = 0

                for seg in range(self.seg_count):
                    if frame is None:
                        if not self.empty():
                            frame = self._get_frame_nowait()
                            frame_offset = 0
                            self.log.info("TX CQ frame: %r", frame)
                            first = True
                        else:
                            break

                    if first:
                        first = False

                        if self.width == 512:
                            transaction.tuser |= (frame.first_be & 0xf) << (seg*4)
                            transaction.tuser |= (frame.last_be & 0xf) << (seg*4+8)

                            # is_sop
                            transaction.tuser |= 1 << 80+sop_cnt
                            # is_sop_ptr
                            transaction.tuser |= (seg*self.seg_byte_lanes//4) << 82+sop_cnt*2
                        else:
                            transaction.tuser |= (frame.first_be & 0xf)
                            transaction.tuser |= (frame.last_be & 0xf) << 4

                            # sop
                            transaction.tuser |= 1 << 40

                        sop_cnt += 1

                    if frame.discontinue:
                        transaction.tuser |= 1 << self.discontinue_offset

                    last_lane = 0
                    for k in range(self.seg_byte_lanes):
                        lane = k+seg*self.seg_byte_lanes
                        if frame_offset < len(frame.data):
                            transaction.tdata |= frame.data[frame_offset] << lane*32
                            transaction.tkeep |= 1 << lane
                            transaction.tuser |= frame.byte_en[frame_offset] << lane*4+self.byte_en_offset
                            transaction.tuser |= frame.parity[frame_offset] << lane*4+self.parity_offset
                            frame_offset += 1
                            last_lane = lane
                        else:
                            transaction.tuser |= 0xf << lane*4+self.parity_offset

                    if frame_offset >= len(frame.data):
                        # eop
                        if self.width == 512:
                            # is_eop
                            transaction.tuser |= 1 << 86+eop_cnt
                            # is_eop_ptr
                            transaction.tuser |= last_lane << 88+eop_cnt*4

                        eop_cnt += 1

                        if self.seg_count == 1:
                            transaction.tlast = 1

                        frame = None

                await self._drive(transaction)


class CqSink(UsPcieSink):
    def _init(self):

        if self.width == 512:
            assert len(self.bus.tuser) == 183
            assert self.seg_count in {1, 2}
            self.byte_en_offset = 16
            self.discontinue_offset = 96
            self.parity_offset = 119
        else:
            assert len(self.bus.tuser) in [85, 88]
            assert self.seg_count == 1
            self.byte_en_offset = 8
            self.discontinue_offset = 41
            self.parity_offset = 53

    async def _run(self):
        self.active = False
        frame = UsPcieFrame()

        while True:
            while not self.sample_obj:
                self.sample_sync.clear()
                await self.sample_sync.wait()

            self.active = True
            sample = self.sample_obj
            self.sample_obj = None

            lane_valid = 2**self.byte_lanes-1
            seg_valid = 2**self.seg_count-1
            seg_sop = 0
            seg_eop = 0

            if self.seg_count == 1:
                lane_valid = sample.tkeep
                seg_valid = 1

                if not frame:
                    seg_sop = 1

                if sample.tlast:
                    seg_eop = 1
            elif self.width == 512:
                sop_byte_lane = 0
                eop_byte_lane = 0
                for k in range(self.seg_count):
                    if sample.tuser & (1 << (80+k)):
                        offset = (sample.tuser >> (82+k*2)) & 0x3
                        sop_byte_lane |= 1 << (offset*4)
                    if sample.tuser & (1 << (86+k)):
                        offset = (sample.tuser >> (88+k*4)) & 0xf
                        eop_byte_lane |= 1 << offset
                lane_valid = 0
                seg_valid = 0
                state = 1
                for k in range(self.byte_lanes):
                    mask = 1 << k
                    seg_mask = 1 << (k // self.seg_byte_lanes)
                    if sop_byte_lane & mask:
                        state = 1
                        seg_sop |= seg_mask
                    if state:
                        lane_valid |= mask
                        seg_valid |= seg_mask
                    if eop_byte_lane & mask:
                        state = 0
                        seg_eop |= seg_mask

            for seg in range(self.seg_count):
                if not seg_valid & (1 << seg):
                    continue

                if seg_sop & (1 << seg):
                    frame = UsPcieFrame()

                    if self.width == 512:
                        frame.first_be = (sample.tuser >> (seg*4)) & 0xf
                        frame.last_be = (sample.tuser >> (seg*4+8)) & 0xf
                    else:
                        frame.first_be = sample.tuser & 0xf
                        frame.last_be = (sample.tuser >> 4) & 0xf

                if sample.tuser & (1 << self.discontinue_offset):
                    frame.discontinue = True

                for k in range(self.seg_byte_lanes):
                    lane = k+seg*self.seg_byte_lanes
                    if lane_valid & (1 << lane):
                        frame.data.append((sample.tdata >> lane*32) & 0xffffffff)
                        frame.byte_en.append((sample.tuser >> (lane*4+self.byte_en_offset)) & 0xf)
                        frame.parity.append((sample.tuser >> (lane*4+self.parity_offset)) & 0xf)

                if seg_eop & (1 << seg):
                    self.log.info("RX CQ frame: %r", frame)
                    self._sink_frame(frame)
                    self.active = False
                    frame = None


class CcSource(UsPcieSource):
    def _init(self):

        if self.width == 512:
            assert len(self.bus.tuser) == 81
            assert self.seg_count in {1, 2}
            self.discontinue_offset = 16
            self.parity_offset = 17
        else:
            assert len(self.bus.tuser) == 33
            assert self.seg_count == 1
            self.discontinue_offset = 0
            self.parity_offset = 1

    async def _run(self):
        while True:
            frame = await self._get_frame()
            frame_offset = 0
            self.log.info("TX CC frame: %r", frame)
            first = True

            while frame is not None:
                transaction = self._transaction_obj()
                sop_cnt = 0
                eop_cnt = 0

                for seg in range(self.seg_count):
                    if frame is None:
                        if not self.empty():
                            frame = self._get_frame_nowait()
                            frame_offset = 0
                            self.log.info("TX CC frame: %r", frame)
                            first = True
                        else:
                            break

                    if first:
                        first = False

                        if self.width == 512:
                            # is_sop
                            transaction.tuser |= 1 << 0+sop_cnt
                            # is_sop_ptr
                            transaction.tuser |= (seg*self.seg_byte_lanes//4) << 2+sop_cnt*2

                        sop_cnt += 1

                    if frame.discontinue:
                        transaction.tuser |= 1 << self.discontinue_offset

                    last_lane = 0
                    for k in range(self.seg_byte_lanes):
                        lane = k+seg*self.seg_byte_lanes
                        if frame_offset < len(frame.data):
                            transaction.tdata |= frame.data[frame_offset] << lane*32
                            transaction.tkeep |= 1 << lane
                            transaction.tuser |= frame.parity[frame_offset] << lane*4+self.parity_offset
                            frame_offset += 1
                            last_lane = lane
                        else:
                            transaction.tuser |= 0xf << lane*4+self.parity_offset

                    if frame_offset >= len(frame.data):
                        # eop
                        if self.width == 512:
                            # is_eop
                            transaction.tuser |= 1 << 6+eop_cnt
                            # is_eop_ptr
                            transaction.tuser |= last_lane << 8+eop_cnt*4

                        eop_cnt += 1

                        if self.seg_count == 1:
                            transaction.tlast = 1

                        frame = None

                await self._drive(transaction)


class CcSink(UsPcieSink):
    def _init(self):

        if self.width == 512:
            assert len(self.bus.tuser) == 81
            assert self.seg_count in {1, 2}
            self.discontinue_offset = 16
            self.parity_offset = 17
        else:
            assert len(self.bus.tuser) == 33
            assert self.seg_count == 1
            self.discontinue_offset = 0
            self.parity_offset = 1

    async def _run(self):
        self.active = False
        frame = UsPcieFrame()

        while True:
            while not self.sample_obj:
                self.sample_sync.clear()
                await self.sample_sync.wait()

            self.active = True
            sample = self.sample_obj
            self.sample_obj = None

            lane_valid = 2**self.byte_lanes-1
            seg_valid = 2**self.seg_count-1
            seg_sop = 0
            seg_eop = 0

            if self.seg_count == 1:
                lane_valid = sample.tkeep
                seg_valid = 1

                if not frame:
                    seg_sop = 1

                if sample.tlast:
                    seg_eop = 1
            elif self.width == 512:
                sop_byte_lane = 0
                eop_byte_lane = 0
                for k in range(self.seg_count):
                    if sample.tuser & (1 << (0+k)):
                        offset = (sample.tuser >> (2+k*2)) & 0x3
                        sop_byte_lane |= 1 << (offset*4)
                    if sample.tuser & (1 << (6+k)):
                        offset = (sample.tuser >> (8+k*4)) & 0xf
                        eop_byte_lane |= 1 << offset
                lane_valid = 0
                seg_valid = 0
                state = 1
                for k in range(self.byte_lanes):
                    mask = 1 << k
                    seg_mask = 1 << (k // self.seg_byte_lanes)
                    if sop_byte_lane & mask:
                        state = 1
                        seg_sop |= seg_mask
                    if state:
                        lane_valid |= mask
                        seg_valid |= seg_mask
                    if eop_byte_lane & mask:
                        state = 0
                        seg_eop |= seg_mask

            for seg in range(self.seg_count):
                if not seg_valid & (1 << seg):
                    continue

                if seg_sop & (1 << seg):
                    frame = UsPcieFrame()

                if sample.tuser & (1 << self.discontinue_offset):
                    frame.discontinue = True

                for k in range(self.seg_byte_lanes):
                    lane = k+seg*self.seg_byte_lanes
                    if lane_valid & (1 << lane):
                        frame.data.append((sample.tdata >> lane*32) & 0xffffffff)
                        frame.parity.append((sample.tuser >> (lane*4+self.parity_offset)) & 0xf)

                if seg_eop & (1 << seg):
                    self.log.info("RX CC frame: %r", frame)
                    self._sink_frame(frame)
                    self.active = False
                    frame = None



================================================
FILE: cocotbext/pcie/xilinx/us/tlp.py
================================================
"""

Copyright (c) 2020 Alex Forencich

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

"""

import enum
import struct

from cocotbext.pcie.core.tlp import Tlp, TlpFmt, TlpType, TlpAt, TlpAttr, TlpTc, CplStatus
from cocotbext.pcie.core.utils import PcieId
from .interface import UsPcieFrame


# req_type field
class ReqType(enum.IntEnum):
    MEM_READ        = 0b0000
    MEM_WRITE       = 0b0001
    IO_READ         = 0b0010
    IO_WRITE        = 0b0011
    MEM_FETCH_ADD   = 0b0100
    MEM_SWAP        = 0b0101
    MEM_CAS         = 0b0110
    MEM_READ_LOCKED = 0b0111
    CFG_READ_0      = 0b1000
    CFG_READ_1      = 0b1001
    CFG_WRITE_0     = 0b1010
    CFG_WRITE_1     = 0b1011
    MSG             = 0b1100
    MSG_VENDOR      = 0b1101
    MSG_ATS         = 0b1110


# error_code field
class ErrorCode(enum.IntEnum):
    NORMAL_TERMINATION = 0b0000
    POISONED           = 0b0001
    BAD_STATUS         = 0b0010
    INVALID_LENGTH     = 0b0011
    MISMATCH           = 0b0100
    INVALID_ADDRESS    = 0b0101
    INVALID_TAG        = 0b0110
    TIMEOUT            = 0b1001
    FLR                = 0b1000


tlp_type_to_req_type = {
    TlpType.MEM_READ:            ReqType.MEM_READ,
    TlpType.MEM_READ_64:         ReqType.MEM_READ,
    TlpType.MEM_READ_LOCKED:     ReqType.MEM_READ_LOCKED,
    TlpType.MEM_READ_LOCKED_64:  ReqType.MEM_READ_LOCKED,
    TlpType.MEM_WRITE:           ReqType.MEM_WRITE,
    TlpType.MEM_WRITE_64:        ReqType.MEM_WRITE,
    TlpType.IO_READ:             ReqType.IO_READ,
    TlpType.IO_WRITE:            ReqType.IO_WRITE,
    TlpType.CFG_READ_0:          ReqType.CFG_READ_0,
    TlpType.CFG_WRITE_0:         ReqType.CFG_WRITE_0,
    TlpType.CFG_READ_1:          ReqType.CFG_READ_1,
    TlpType.CFG_WRITE_1:         ReqType.CFG_WRITE_1,
    TlpType.FETCH_ADD:           ReqType.MEM_FETCH_ADD,
    TlpType.FETCH_ADD_64:        ReqType.MEM_FETCH_ADD,
    TlpType.SWAP:                ReqType.MEM_SWAP,
    TlpType.SWAP_64:             ReqType.MEM_SWAP,
    TlpType.CAS:                 ReqType.MEM_CAS,
    TlpType.CAS_64:              ReqType.MEM_CAS,
}


req_type_to_tlp_type = {
    ReqType.MEM_READ:        TlpType.MEM_READ,
    ReqType.MEM_WRITE:       TlpType.MEM_WRITE,
    ReqType.IO_READ:         TlpType.IO_READ,
    ReqType.IO_WRITE:        TlpType.IO_WRITE,
    ReqType.MEM_FETCH_ADD:   TlpType.FETCH_ADD,
    ReqType.MEM_SWAP:        TlpType.SWAP,
    ReqType.MEM_CAS:         TlpType.CAS,
    ReqType.MEM_READ_LOCKED: TlpType.MEM_READ_LOCKED,
    ReqType.CFG_READ_0:      TlpType.CFG_READ_0,
    ReqType.CFG_READ_1:      TlpType.CFG_READ_1,
    ReqType.CFG_WRITE_0:     TlpType.CFG_WRITE_0,
    ReqType.CFG_WRITE_1:     TlpType.CFG_WRITE_1,
}


class Tlp_us(Tlp):
    def __init__(self, tlp=None):
        super().__init__(tlp)
        self.bar_id = 0
        self.bar_aperture = 0
        self.completer_id_enable = False
        self.requester_id_enable = False
        self.discontinue = False
        self.seq_num = 0
        self.error_code = ErrorCode.NORMAL_TERMINATION
        self.request_completed = False

        if isinstance(tlp, Tlp_us):
            self.bar_id = tlp.bar_id
            self.bar_aperture = tlp.bar_aperture
            self.completer_id_enable = tlp.completer_id_enable
            self.requester_id_enable = tlp.requester_id_enable
            self.discontinue = tlp.discontinue
            self.seq_num = tlp.seq_num
            self.error_code = tlp.error_code
            self.request_completed == tlp.request_completed

    def pack_us_cq(self):
        pkt = UsPcieFrame()

        if self.fmt_type in {TlpType.MEM_READ, TlpType.MEM_READ_64, TlpType.MEM_READ_LOCKED, TlpType.MEM_READ_LOCKED_64,
                TlpType.MEM_WRITE, TlpType.MEM_WRITE_64, TlpType.IO_READ, TlpType.IO_WRITE, TlpType.FETCH_ADD,
                TlpType.FETCH_ADD_64, TlpType.SWAP, TlpType.SWAP_64, TlpType.CAS, TlpType.CAS_64}:
            # Completer Request descriptor
            dw = self.at & 0x3
            dw |= self.address & 0xfffffffc
            pkt.data.append(dw)
            dw = (self.address & 0xffffffff00000000) >> 32
            pkt.data.append(dw)
            dw = self.length & 0x7ff
            dw |= tlp_type_to_req_type[self.fmt_type] << 11
            dw |= int(self.requester_id) << 16
            pkt.data.append(dw)
            dw = (self.tag & 0xff)
            dw |= (self.completer_id.function & 0xff) << 8
            dw |= (self.bar_id & 0x7) << 16
            dw |= (self.bar_aperture & 0x3f) << 19
            dw |= (self.tc & 0x7) << 25
            dw |= (self.attr & 0x7) << 28
            pkt.data.append(dw)

            pkt.first_be = self.first_be
            pkt.last_be = self.last_be

            pkt.discontinue = self.discontinue

            # payload data
            for k in range(0, len(self.data), 4):
                pkt.data.extend(struct.unpack_from('<L', self.data, k))

            # compute byte enables
            pkt.byte_en = [0]*4

            if self.get_payload_size_dw() >= 1:
                pkt.byte_en += [self.first_be]
            if self.get_payload_size_dw() > 2:
                pkt.byte_en += [0xf] * (self.get_payload_size_dw()-2)
            if self.get_payload_size_dw() > 1:
                pkt.byte_en += [self.last_be]

            # compute parity
            pkt.update_parity()
        else:
            raise Exception(f"Invalid TLP type for interface ({self.fmt_type})")

        return pkt

    @classmethod
    def unpack_us_cq(cls, pkt, check_parity=False):
        tlp = cls()

        req_type = (pkt.data[2] >> 11) & 0xf

        tlp.fmt_type = req_type_to_tlp_type[req_type]

        tlp.length = pkt.data[2] & 0x7ff
        tlp.requester_id = PcieId.from_int(pkt.data[2] >> 16)
        tlp.tag = pkt.data[3] & 0xff
        tlp.tc = TlpTc((pkt.data[3] >> 25) & 0x7)
        tlp.attr = TlpAttr((pkt.data[3] >> 28) & 0x7)

        if req_type & 8 == 0:
            # memory, IO, or atomic operation
            tlp.at = TlpAt(pkt.data[0] & 3)
            tlp.address = (pkt.data[1] << 32) | (pkt.data[0] & 0xfffffffc)
            if tlp.address > 0xffffffff:
                if tlp.fmt == TlpFmt.THREE_DW:
                    tlp.fmt = TlpFmt.FOUR_DW
                elif tlp.fmt == TlpFmt.THREE_DW_DATA:
                    tlp.fmt = TlpFmt.FOUR_DW_DATA
            tlp.completer_id = PcieId(0, 0, (pkt.data[3] >> 8) & 0xff)
            tlp.bar_id = (pkt.data[3] >> 16) & 7
            tlp.bar_aperture = (pkt.data[3] >> 19) & 0x3f

            tlp.first_be = pkt.first_be
            tlp.last_be = pkt.last_be

            tlp.discontinue = pkt.discontinue

            for dw in pkt.data[4:]:
                tlp.data.extend(struct.pack('<L', dw))

            # compute byte enables
            byte_en = [0]*4

            if tlp.get_payload_size_dw() >= 1:
                byte_en += [tlp.first_be]
            if tlp.get_payload_size_dw() > 2:
                byte_en += [0xf] * (tlp.get_payload_size_dw()-2)
            if tlp.get_payload_size_dw() > 1:
                byte_en += [tlp.last_be]

            # check byte enables
            assert byte_en == pkt.byte_en

            # check parity
            if check_parity:
                assert pkt.check_parity()

        return tlp

    def pack_us_cc(self):
        pkt = UsPcieFrame()

        if self.fmt_type in {TlpType.CPL, TlpType.CPL_DATA, TlpType.CPL_LOCKED, TlpType.CPL_LOCKED_DATA}:
            # Requester Completion descriptor
            dw = self.lower_address & 0x7f
            dw |= (self.at & 3) << 8
            dw |= (self.byte_count & 0x1fff) << 16
            if self.fmt_type in {TlpType.CPL_LOCKED, TlpType.CPL_LOCKED_DATA}:
                dw |= 1 << 29
            # TODO request completed
            pkt.data.append(dw)
            dw = self.length & 0x7ff
            dw |= (self.status & 0x7) << 11
            dw |= bool(self.ep) << 14
            dw |= int(self.requester_id) << 16
            pkt.data.append(dw)
            dw = (self.tag & 0xff)
            dw |= int(self.completer_id) << 8
            dw |= bool(self.completer_id_enable) << 24
            dw |= (self.tc & 0x7) << 25
            dw |= (self.attr & 0x7) << 28
            pkt.data.append(dw)

            pkt.discontinue = self.discontinue

            # payload data
            for k in range(0, len(self.data), 4):
                pkt.data.extend(struct.unpack_from('<L', self.data, k))

            # compute parity
            pkt.update_parity()
        else:
            raise Exception(f"Invalid TLP type for interface ({self.fmt_type})")

        return pkt

    @classmethod
    def unpack_us_cc(cls, pkt, check_parity=False):
        tlp = cls()

        tlp.fmt_type = TlpType.CPL

        tlp.lower_address = pkt.data[0] & 0x7f
        tlp.at = TlpAt((pkt.data[0] >> 8) & 3)
        tlp.byte_count = (pkt.data[0] >> 16) & 0x1fff
        if pkt.data[0] & (1 << 29):
            tlp.fmt_type = TlpType.CPL_LOCKED

        tlp.length = pkt.data[1] & 0x7ff
        if tlp.length > 0:
            tlp.fmt = TlpFmt.THREE_DW_DATA
        tlp.status = CplStatus((pkt.data[1] >> 11) & 7)
        tlp.ep = bool(pkt.data[1] & 1 << 14)
        tlp.requester_id = PcieId.from_int(pkt.data[1] >> 16)
        tlp.completer_id = PcieId.from_int(pkt.data[2] >> 8)
        tlp.tag = pkt.data[2] & 0xff
        tlp.completer_id_enable = bool(pkt.data[2] & (1 << 24))
        tlp.tc = TlpTc((pkt.data[2] >> 25) & 0x7)
        tlp.attr = TlpAttr((pkt.data[2] >> 28) & 0x7)

        tlp.discontinue = pkt.discontinue

        if tlp.length > 0:
            for dw in pkt.data[3:3+tlp.length]:
                tlp.data.extend(struct.pack('<L', dw))

        # check parity
        if check_parity:
            assert pkt.check_parity()

        return tlp

    def pack_us_rq(self):
        pkt = UsPcieFrame()

        if self.fmt_type in {TlpType.CFG_READ_0, TlpType.CFG_WRITE_0, TlpType.CFG_READ_1, TlpType.CFG_WRITE_1,
                TlpType.MEM_READ, TlpType.MEM_READ_64, TlpType.MEM_READ_LOCKED, TlpType.MEM_READ_LOCKED_64,
                TlpType.MEM_WRITE, TlpType.MEM_WRITE_64, TlpType.IO_READ, TlpType.IO_WRITE, TlpType.FETCH_ADD,
                TlpType.FETCH_ADD_64, TlpType.SWAP, TlpType.SWAP_64, TlpType.CAS, TlpType.CAS_64}:
            # Completer Request descriptor
            if self.fmt_type in {TlpType.CFG_READ_0, TlpType.CFG_WRITE_0, TlpType.CFG_READ_1, TlpType.CFG_WRITE_1}:
                # configuration
                dw = self.address & 0xffc
                pkt.data.append(dw)
                pkt.data.append(0)
            else:
                # memory, IO, or atomic operation
                dw = self.at & 0x3
                dw |= self.address & 0xfffffffc
                pkt.data.append(dw)
                dw = (self.address & 0xffffffff00000000) >> 32
                pkt.data.append(dw)
            dw = self.length & 0x7ff
            dw |= (tlp_type_to_req_type[self.fmt_type] & 0xf) << 11
            dw |= bool(self.ep) << 15
            dw |= int(self.requester_id) << 16
            pkt.data.append(dw)
            dw = (self.tag & 0xff)
            dw |= int(self.completer_id) << 8
            dw |= bool(self.requester_id_enable) << 24
            dw |= (self.tc & 0x7) << 25
            dw |= (self.attr & 0x7) << 28
            # TODO force ecrc
            pkt.data.append(dw)

            pkt.first_be = self.first_be
            pkt.last_be = self.last_be

            pkt.discontinue = self.discontinue

            pkt.seq_num = self.seq_num

            # payload data
            for k in range(0, len(self.data), 4):
                pkt.data.extend(struct.unpack_from('<L', self.data, k))

            # compute parity
            pkt.update_parity()
        else:
            raise Exception(f"Invalid TLP type for interface ({self.fmt_type})")

        return pkt

    @classmethod
    def unpack_us_rq(cls, pkt, check_parity=False):
        tlp = cls()

        req_type = (pkt.data[2] >> 11) & 0xf

        tlp.fmt_type = req_type_to_tlp_type[req_type]

        tlp.length = pkt.data[2] & 0x7ff
        tlp.ep = bool(pkt.data[2] & 1 << 15)
        tlp.requester_id = PcieId.from_int(pkt.data[2] >> 16)
        tlp.tag = pkt.data[3] & 0xff
        tlp.tc = TlpTc((pkt.data[3] >> 25) & 0x7)
        tlp.attr = TlpAttr((pkt.data[3] >> 28) & 0x7)

        if req_type < 12:
            if req_type < 8:
                # memory, IO, or atomic operation
                tlp.at = TlpAt(pkt.data[0] & 3)
                tlp.address = (pkt.data[1] << 32) | (pkt.data[0] & 0xfffffffc)
                if tlp.address > 0xffffffff:
                    if tlp.fmt == TlpFmt.THREE_DW:
                        tlp.fmt = TlpFmt.FOUR_DW
                    elif tlp.fmt == TlpFmt.THREE_DW_DATA:
                        tlp.fmt = TlpFmt.FOUR_DW_DATA
            else:
                # configuration
                tlp.address = pkt.data[0] & 0xffc
            tlp.completer_id = PcieId.from_int(pkt.data[3] >> 8)
            tlp.requester_id_enable = bool(pkt.data[3] & (1 << 24))

            tlp.first_be = pkt.first_be
            tlp.last_be = pkt.last_be

            tlp.discontinue = pkt.discontinue

            tlp.seq_num = pkt.seq_num

            for dw in pkt.data[4:]:
                tlp.data.extend(struct.pack('<L', dw))

            # check parity
            if check_parity:
                assert pkt.check_parity()
        else:
            raise Exception("TODO")

        return tlp

    def pack_us_rc(self):
        pkt = UsPcieFrame()

        if self.fmt_type in {TlpType.CPL, TlpType.CPL_DATA, TlpType.CPL_LOCKED, TlpType.CPL_LOCKED_DATA}:
            # Requester Completion descriptor
            dw = self.lower_address & 0xfff
            dw |= (self.error_code & 0xf) << 12
            dw |= (self.byte_count & 0x1fff) << 16
            if self.fmt_type in {TlpType.CPL_LOCKED, TlpType.CPL_LOCKED_DATA}:
                dw |= 1 << 29
            dw |= bool(self.request_completed) << 30
            pkt.data.append(dw)
            dw = self.length & 0x7ff
            dw |= (self.status & 0x7) << 11
            dw |= bool(self.ep) << 14
            dw |= int(self.requester_id) << 16
            pkt.data.append(dw)
            dw = (self.tag & 0xff)
            dw |= int(self.completer_id) << 8
            dw |= (self.tc & 0x7) << 25
            dw |= (self.attr & 0x7) << 28
            pkt.data.append(dw)

            pkt.discontinue = self.discontinue

            # payload data
            for k in range(0, len(self.data), 4):
                pkt.data.extend(struct.unpack_from('<L', self.data, k))

            # compute byte enables
            pkt.byte_en = [0]*3

            first_be = (0xf << (self.lower_address & 3)) & 0xf
            if self.byte_count+(self.lower_address & 3) > self.length*4:
                last_be = 0xf
            else:
                last_be = 0xf >> ((4-self.byte_count-self.lower_address) & 3)

            if self.get_payload_size_dw() == 1:
                first_be = first_be & last_be
                last_be = 0

            if self.get_payload_size_dw() >= 1:
                pkt.byte_en += [first_be]
            if self.get_payload_size_dw() > 2:
                pkt.byte_en += [0xf] * (self.get_payload_size_dw()-2)
            if self.get_payload_size_dw() > 1:
                pkt.byte_en += [last_be]

            # compute parity
            pkt.update_parity()
        else:
            raise Exception(f"Invalid TLP type for interface ({self.fmt_type})")

        return pkt

    @classmethod
    def unpack_us_rc(cls, pkt, check_parity=False):
        tlp = cls()

        tlp.fmt_type = TlpType.CPL

        tlp.lower_address = pkt.data[0] & 0xfff
        tlp.error_code = (pkt.data[0] >> 12) & 0xf
        tlp.byte_count = (pkt.data[0] >> 16) & 0x1fff
        if pkt.data[0] & (1 << 29):
            tlp.fmt_type = TlpType.CPL_LOCKED
        tlp.request_completed = pkt.data[0] & (1 << 30)

        tlp.length = pkt.data[1] & 0x7ff
        if tlp.length > 0:
            tlp.fmt = TlpFmt.THREE_DW_DATA
        tlp.status = CplStatus((pkt.data[1] >> 11) & 7)
        tlp.ep = bool(pkt.data[1] & 1 << 14)
        tlp.requester_id = PcieId.from_int(pkt.data[1] >> 16)
        tlp.completer_id = PcieId.from_int(pkt.data[2] >> 8)
        tlp.tag = pkt.data[2] & 0xff
        tlp.tc = TlpTc((pkt.data[2] >> 25) & 0x7)
        tlp.attr = TlpAttr((pkt.data[2] >> 28) & 0x7)

        tlp.discontinue = pkt.discontinue

        if tlp.length > 0:
            for dw in pkt.data[3:3+tlp.length]:
                tlp.data.extend(struct.pack('<L', dw))

        # compute byte enables
        byte_en = [0]*3

        first_be = (0xf << (tlp.lower_address & 3)) & 0xf
        if tlp.byte_count+(tlp.lower_address & 3) > tlp.length*4:
            last_be = 0xf
        else:
            last_be = 0xf >> ((4-tlp.byte_count-tlp.lower_address) & 3)

        if tlp.get_payload_size_dw() == 1:
            first_be = first_be & last_be
            last_be = 0

        if tlp.get_payload_size_dw() >= 1:
            byte_en += [first_be]
        if tlp.get_payload_size_dw() > 2:
            byte_en += [0xf] * (tlp.get_payload_size_dw()-2)
        if tlp.get_payload_size_dw() > 1:
            byte_en += [last_be]

        # check byte enables
        assert byte_en == pkt.byte_en

        # check parity
        if check_parity:
            assert pkt.check_parity()

        return tlp

    def __eq__(self, other):
        if isinstance(other, Tlp_us):
            return (
                self.data == other.data and
                self.fmt == other.fmt and
                self.type == other.type and
                self.tc == other.tc and
                self.ln == other.ln and
                self.td == other.td and
                self.ep == other.ep and
                self.attr == other.attr and
                self.at == other.at and
                self.length == other.length and
                self.completer_id == other.completer_id and
                self.status == other.status and
                self.bcm == other.bcm and
                self.byte_count == other.byte_count and
                self.requester_id == other.requester_id and
                self.tag == other.tag and
                self.first_be == other.first_be and
                self.last_be == other.last_be and
                self.lower_address == other.lower_address and
                self.address == other.address and
                self.ph == other.ph
            )
        return False

    def __repr__(self):
        return (
            f"{type(self).__name__}(data={self.data}, "
            f"fmt_type={self.fmt_type}, "
            f"tc={self.tc!s}, "
            f"ln={self.ln}, "
            f"th={self.th}, "
            f"td={self.td}, "
            f"ep={self.ep}, "
            f"attr={self.attr!s}, "
            f"at={self.at!s}, "
            f"length={self.length}, "
            f"completer_id={self.completer_id!r}, "
            f"status={self.status!s}, "
            f"bcm={self.bcm}, "
            f"byte_count={self.byte_count}, "
            f"requester_id={self.requester_id!r}, "
            f"tag={self.tag}, "
            f"first_be={self.first_be:#x}, "
            f"last_be={self.last_be:#x}, "
            f"lower_address={self.lower_address:#x}, "
            f"address={self.address:#x}, "
            f"ph={self.ph})"
        )



================================================
FILE: cocotbext/pcie/xilinx/us/us_model.py
================================================
"""

Copyright (c) 2020 Alex Forencich

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

"""

import cocotb
from cocotb.clock import Clock
from cocotb.queue import Queue
from cocotb.triggers import RisingEdge, FallingEdge, Timer, First, Event

from cocotbext.pcie.core import Device, Endpoint, __version__
from cocotbext.pcie.core.caps import MsiCapability, MsixCapability
from cocotbext.pcie.core.caps import AerExtendedCapability, PcieExtendedCapability
from cocotbext.pcie.core.utils import PcieId
from cocotbext.pcie.core.tlp import Tlp, TlpType, TlpAttr, CplStatus

from .interface import RqSink, RcSource, CqSource, CcSink
from .tlp import Tlp_us, ErrorCode


valid_configs = [
    # speed, links, width, freq
    (1,  1,  64,  62.5e6),
    (1,  1,  64, 125.0e6),
    (1,  1,  64, 250.0e6),
    (1,  2,  64,  62.5e6),
    (1,  2,  64, 125.0e6),
    (1,  2,  64, 250.0e6),
    (1,  4,  64, 125.0e6),
    (1,  4,  64, 250.0e6),
    (1,  8,  64, 250.0e6),
    (1,  8, 128, 125.0e6),
    (2,  1,  64,  62.5e6),
    (2,  1,  64, 125.0e6),
    (2,  1,  64, 250.0e6),
    (2,  2,  64, 125.0e6),
    (2,  2,  64, 250.0e6),
    (2,  4,  64, 250.0e6),
    (2,  4, 128, 125.0e6),
    (2,  8, 128, 250.0e6),
    (2,  8, 256, 125.0e6),
    (3,  1,  64, 125.0e6),
    (3,  1,  64, 250.0e6),
    (3,  2,  64, 250.0e6),
    (3,  2, 128, 125.0e6),
    (3,  4, 128, 250.0e6),
    (3,  4, 256, 125.0e6),
    (3,  8, 256, 250.0e6),
]


class UltraScalePcieFunction(Endpoint):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.register_capability(self.pm_cap, offset=0x20)

        # PCIe capabilities
        self.msi_cap = MsiCapability()
        self.msi_cap.msi_64bit_address_capable = 1
        self.msi_cap.msi_per_vector_mask_capable = 0
        self.register_capability(self.msi_cap, offset=0x24)

        self.msix_cap = MsixCapability()
        self.register_capability(self.msix_cap, offset=0x2c)

        self.register_capability(self.pcie_cap, offset=0x30)

        # PCIe extended capabilities
        self.aer_ext_cap = AerExtendedCapability()
        self.register_capability(self.aer_ext_cap, offset=0x40)

        # ARI 0x50
        # DSN 0x54
        # PWR 0x58
        # LTR 0x6e
        # DPA 0x70
        # SRIOV 0x80
        # TPH 0x9d

        self.pcie_ext_cap = PcieExtendedCapability()
        self.register_capability(self.pcie_ext_cap, offset=0xC0)

        # VSEC 0xd0 (MCAP)
        # VC 0xf0


def init_signal(sig, width=None, initval=None):
    if sig is None:
        return None
    if width is not None:
        assert len(sig) == width
    if initval is not None:
        sig.setimmediatevalue(initval)
    return sig


class UltraScalePcieDevice(Device):
    def __init__(self,
            # configuration options
            pcie_generation=None,
            pcie_link_width=None,
            user_clk_frequency=None,
            alignment="dword",
            rc_straddle=False,
            pf_count=1,
            max_payload_size=128,
            enable_client_tag=True,
            enable_extended_tag=False,
            enable_parity=False,
            enable_rx_msg_interface=False,
            enable_sriov=False,
            enable_extended_configuration=False,

            pf0_msi_enable=False,
            pf0_msi_count=1,
            pf1_msi_enable=False,
            pf1_msi_count=1,
            pf0_msix_enable=False,
            pf0_msix_table_size=0,
            pf0_msix_table_bir=0,
            pf0_msix_table_offset=0x00000000,
            pf0_msix_pba_bir=0,
            pf0_msix_pba_offset=0x00000000,
            pf1_msix_enable=False,
            pf1_msix_table_size=0,
            pf1_msix_table_bir=0,
            pf1_msix_table_offset=0x00000000,
            pf1_msix_pba_bir=0,
            pf1_msix_pba_offset=0x00000000,

            # signals
            # Clock and Reset Interface
            user_clk=None,
            user_reset=None,
            user_lnk_up=None,
            sys_clk=None,
            sys_clk_gt=None,
            sys_reset=None,
            pcie_perstn1_in=None,
            pcie_perstn0_out=None,
            pcie_perstn1_out=None,
            phy_rdy_out=None,

            # Requester reQuest Interface
            rq_bus=None,
            pcie_rq_seq_num=None,
            pcie_rq_seq_num_vld=None,
            pcie_rq_tag=None,
            pcie_rq_tag_av=None,
            pcie_rq_tag_vld=None,

            # Requester Completion Interface
            rc_bus=None,

            # Completer reQuest Interface
            cq_bus=None,
            pcie_cq_np_req=None,
            pcie_cq_np_req_count=None,

            # Completer Completion Interface
            cc_bus=None,

            # Transmit Flow Control Interface
            pcie_tfc_nph_av=None,
            pcie_tfc_npd_av=None,

            # Configuration Management Interface
            cfg_mgmt_addr=None,
            cfg_mgmt_function_number=None,
            cfg_mgmt_write=None,
            cfg_mgmt_write_data=None,
            cfg_mgmt_byte_enable=None,
            cfg_mgmt_read=None,
            cfg_mgmt_read_data=None,
            cfg_mgmt_read_write_done=None,
            cfg_mgmt_type1_cfg_reg_access=None,

            # Configuration Status Interface
            cfg_phy_link_down=None,
            cfg_phy_link_status=None,
            cfg_negotiated_width=None,
            cfg_current_speed=None,
            cfg_max_payload=None,
            cfg_max_read_req=None,
            cfg_function_status=None,
            cfg_vf_status=None,
            cfg_function_power_state=None,
            cfg_vf_power_state=None,
            cfg_link_power_state=None,
            cfg_err_cor_out=None,
            cfg_err_nonfatal_out=None,
            cfg_err_fatal_out=None,
            cfg_local_error=None,
            cfg_ltr_enable=None,
            cfg_ltssm_state=None,
            cfg_rcb_status=None,
            cfg_dpa_substate_change=None,
            cfg_obff_enable=None,
            cfg_pl_status_change=None,
            cfg_tph_requester_enable=None,
            cfg_tph_st_mode=None,
            cfg_vf_tph_requester_enable=None,
            cfg_vf_tph_st_mode=None,

            # Configuration Received Message Interface
            cfg_msg_received=None,
            cfg_msg_received_data=None,
            cfg_msg_received_type=None,

            # Configuration Transmit Message Interface
            cfg_msg_transmit=None,
            cfg_msg_transmit_type=None,
            cfg_msg_transmit_data=None,
            cfg_msg_transmit_done=None,

            # Configuration Flow Control Interface
            cfg_fc_ph=None,
            cfg_fc_pd=None,
            cfg_fc_nph=None,
            cfg_fc_npd=None,
            cfg_fc_cplh=None,
            cfg_fc_cpld=None,
            cfg_fc_sel=None,

            # Per-Function Status Interface
            cfg_per_func_status_control=None,
            cfg_per_func_status_data=None,
            cfg_per_function_number=None,
            cfg_per_function_output_request=None,
            cfg_per_function_update_done=None,

            # Configuration Control Interface
            cfg_hot_reset_in=None,
            cfg_hot_reset_out=None,
            cfg_config_space_enable=None,
            cfg_dsn=None,
            cfg_ds_port_number=None,
            cfg_ds_bus_number=None,
            cfg_ds_device_number=None,
            cfg_ds_function_number=None,
            cfg_subsys_vend_id=None,
            cfg_power_state_change_ack=None,
            cfg_power_state_change_interrupt=None,
            cfg_err_cor_in=None,
            cfg_err_uncor_in=None,
            cfg_flr_done=None,
            cfg_vf_flr_done=None,
            cfg_flr_in_process=None,
            cfg_vf_flr_in_process=None,
            cfg_req_pm_transition_l23_ready=None,
            cfg_link_training_enable=None,

            # Configuration Interrupt Controller Interface
            cfg_interrupt_int=None,
            cfg_interrupt_sent=None,
            cfg_interrupt_pending=None,
            cfg_interrupt_msi_enable=None,
            cfg_interrupt_msi_vf_enable=None,
            cfg_interrupt_msi_mmenable=None,
            cfg_interrupt_msi_mask_update=None,
            cfg_interrupt_msi_data=None,
            cfg_interrupt_msi_select=None,
            cfg_interrupt_msi_int=None,
            cfg_interrupt_msi_pending_status=None,
            cfg_interrupt_msi_pending_status_data_enable=None,
            cfg_interrupt_msi_pending_status_function_num=None,
            cfg_interrupt_msi_sent=None,
            cfg_interrupt_msi_fail=None,
            cfg_interrupt_msix_enable=None,
            cfg_interrupt_msix_mask=None,
            cfg_interrupt_msix_vf_enable=None,
            cfg_interrupt_msix_vf_mask=None,
            cfg_interrupt_msix_address=None,
            cfg_interrupt_msix_data=None,
            cfg_interrupt_msix_int=None,
            cfg_interrupt_msix_vec_pending=None,
            cfg_interrupt_msix_vec_pending_status=None,
            cfg_interrupt_msix_sent=None,
            cfg_interrupt_msix_fail=None,
            cfg_interrupt_msi_attr=None,
            cfg_interrupt_msi_tph_present=None,
            cfg_interrupt_msi_tph_type=None,
            cfg_interrupt_msi_tph_st_tag=None,
            cfg_interrupt_msi_function_number=None,

            # Configuration Extend Interface
            cfg_ext_read_received=None,
            cfg_ext_write_received=None,
            cfg_ext_register_number=None,
            cfg_ext_function_number=None,
            cfg_ext_write_data=None,
            cfg_ext_write_byte_enable=None,
            cfg_ext_read_data=None,
            cfg_ext_read_data_valid=None,

            *args, **kwargs):

        super().__init__(*args, **kwargs)

        self.log.info("Xilinx UltraScale PCIe hard IP core model")
        self.log.info("cocotbext-pcie version %s", __version__)
        self.log.info("Copyright (c) 2020 Alex Forencich")
        self.log.info("https://github.com/alexforencich/cocotbext-pcie")

        self.default_function = UltraScalePcieFunction

        self.dw = None

        self.rq_seq_num = Queue()
        self.rq_tag = Queue()
        self.rc_queue = Queue()
        self.cq_queue = Queue()
        self.cq_np_queue = Queue()
        self.cq_np_req_count = 0
        self.msg_queue = Queue()

        self.rq_np_queue = Queue()
        self.rq_np_queue_dequeue = Event()
        self.rq_np_limit = 16

        # PG156 lists 64 CPLH and "15872B CPLD"
        # Tests confirm 64 CPLH and ~16KB combined header + data
        self.rx_buf_cplh_fc_limit = 64
        self.rx_buf_cpld_fc_limit = 16384 // 16
        self.rx_buf_cplh_fc_count = 0
        self.rx_buf_cpld_fc_count = 0

        self.cpld_credit_limit = self.rx_buf_cpld_fc_limit
        self.cpld_credit_count = 0
        self.cpld_credit_released = Event()

        self.active_request = [None for x in range(256)]
        self.tag_release = Event()
        self.tag_available_count = 32
        self.tag_count = 64
        self.current_tag = 0

        self.local_error = False

        self.config_space_enable = False

        # configuration options
        self.pcie_generation = pcie_generation
        self.pcie_link_width = pcie_link_width
        self.user_clk_frequency = user_clk_frequency
        self.alignment = alignment
        self.rc_straddle = rc_straddle
        self.pf_count = pf_count
        self.max_payload_size = max_payload_size
        self.enable_client_tag = enable_client_tag
        self.enable_extended_tag = enable_extended_tag
        self.enable_parity = enable_parity
        self.enable_rx_msg_interface = enable_rx_msg_interface
        self.enable_sriov = enable_sriov
        self.enable_extended_configuration = enable_extended_configuration

        self.pf0_msi_enable = pf0_msi_enable
        self.pf0_msi_count = pf0_msi_count
        self.pf1_msi_enable = pf1_msi_enable
        self.pf1_msi_count = pf1_msi_count
        self.pf0_msix_enable = pf0_msix_enable
        self.pf0_msix_table_size = pf0_msix_table_size
        self.pf0_msix_table_bir = pf0_msix_table_bir
        self.pf0_msix_table_offset = pf0_msix_table_offset
        self.pf0_msix_pba_bir = pf0_msix_pba_bir
        self.pf0_msix_pba_offset = pf0_msix_pba_offset
        self.pf1_msix_enable = pf1_msix_enable
        self.pf1_msix_table_size = pf1_msix_table_size
        self.pf1_msix_table_bir = pf1_msix_table_bir
        self.pf1_msix_table_offset = pf1_msix_table_offset
        self.pf1_msix_pba_bir = pf1_msix_pba_bir
        self.pf1_msix_pba_offset = pf1_msix_pba_offset

        # signals

        # Clock and Reset Interface
        self.user_clk = init_signal(user_clk, 1, 0)
        self.user_reset = init_signal(user_reset, 1, 0)
        self.user_lnk_up = init_signal(user_lnk_up, 1, 0)
        self.sys_clk = init_signal(sys_clk, 1)
        self.sys_clk_gt = init_signal(sys_clk_gt, 1)
        self.sys_reset = init_signal(sys_reset, 1)
        self.pcie_perstn1_in = init_signal(pcie_perstn1_in, 1)
        self.pcie_perstn0_out = init_signal(pcie_perstn0_out, 1, 0)
        self.pcie_perstn1_out = init_signal(pcie_perstn1_out, 1, 0)
        self.phy_rdy_out = init_signal(phy_rdy_out, 1, 0)

        # Requester reQuest Interface
        self.rq_sink = None
        self.pcie_rq_seq_num = init_signal(pcie_rq_seq_num, 4, 0)
        self.pcie_rq_seq_num_vld = init_signal(pcie_rq_seq_num_vld, 1, 0)
        self.pcie_rq_tag = init_signal(pcie_rq_tag, 6, 0)
        self.pcie_rq_tag_av = init_signal(pcie_rq_tag_av, 2, 0)
        self.pcie_rq_tag_vld = init_signal(pcie_rq_tag_vld, 1, 0)

        if rq_bus is not None:
            self.rq_sink = RqSink(rq_bus, self.user_clk, self.user_reset)
            self.rq_sink.queue_occupancy_limit_frames = 2
            self.dw = self.rq_sink.width

        # Requester Completion Interface
        self.rc_source = None

        if rc_bus is not None:
            rc_segments = 1
            if len(rc_bus.tdata) >= 256 and self.rc_straddle:
                rc_segments = 2
            self.rc_source = RcSource(rc_bus, self.user_clk, self.user_reset, segments=rc_segments)
            self.rc_source.queue_occupancy_limit_frames = 2
            self.dw = self.rc_source.width

        # Completer reQuest Interface
        self.cq_source = None
        self.pcie_cq_np_req = init_signal(pcie_cq_np_req, 1)
        self.pcie_cq_np_req_count = init_signal(pcie_cq_np_req_count, 6, 0)

        if cq_bus is not None:
            self.cq_source = CqSource(cq_bus, self.user_clk, self.user_reset)
            self.cq_source.queue_occupancy_limit_frames = 2
            self.dw = self.cq_source.width

        # Completer Completion Interface
        self.cc_sink = None

        if cc_bus is not None:
            self.cc_sink = CcSink(cc_bus, self.user_clk, self.user_reset)
            self.cc_sink.queue_occupancy_limit_frames = 2
            self.dw = self.cc_sink.width

        # Transmit Flow Control Interface
        self.pcie_tfc_nph_av = init_signal(pcie_tfc_nph_av, 2, 0)
        self.pcie_tfc_npd_av = init_signal(pcie_tfc_npd_av, 2, 0)

        # Configuration Management Interface
        self.cfg_mgmt_addr = init_signal(cfg_mgmt_addr, 19)
        self.cfg_mgmt_write = init_signal(cfg_mgmt_write, 1)
        self.cfg_mgmt_write_data = init_signal(cfg_mgmt_write_data, 32)
        self.cfg_mgmt_byte_enable = init_signal(cfg_mgmt_byte_enable, 4)
        self.cfg_mgmt_read = init_signal(cfg_mgmt_read, 1)
        self.cfg_mgmt_read_data = init_signal(cfg_mgmt_read_data, 32, 0)
        self.cfg_mgmt_read_write_done = init_signal(cfg_mgmt_read_write_done, 1, 0)
        self.cfg_mgmt_type1_cfg_reg_access = init_signal(cfg_mgmt_type1_cfg_reg_access, 1)

        # Configuration Status Interface
        self.cfg_phy_link_down = init_signal(cfg_phy_link_down, 1, 0)
        self.cfg_phy_link_status = init_signal(cfg_phy_link_status, 2, 0)
        self.cfg_negotiated_width = init_signal(cfg_negotiated_width, 4, 0)
        self.cfg_current_speed = init_signal(cfg_current_speed, 3, 0)
        self.cfg_max_payload = init_signal(cfg_max_payload, 3, 0)
        self.cfg_max_read_req = init_signal(cfg_max_read_req, 3, 0)
        self.cfg_function_status = init_signal(cfg_function_status, 16, 0)
        self.cfg_vf_status = init_signal(cfg_vf_status, 16, 0)
        self.cfg_function_power_state = init_signal(cfg_function_power_state, 12, 0)
        self.cfg_vf_power_state = init_signal(cfg_vf_power_state, 24, 0)
        self.cfg_link_power_state = init_signal(cfg_link_power_state, 2, 0)
        self.cfg_err_cor_out = init_signal(cfg_err_cor_out, 1, 0)
        self.cfg_err_nonfatal_out = init_signal(cfg_err_nonfatal_out, 1, 0)
        self.cfg_err_fatal_out = init_signal(cfg_err_fatal_out, 1, 0)
        self.cfg_local_error = init_signal(cfg_local_error, 1, 0)
        self.cfg_ltr_enable = init_signal(cfg_ltr_enable, 1, 0)
        self.cfg_ltssm_state = init_signal(cfg_ltssm_state, 6, 0)
        self.cfg_rcb_status = init_signal(cfg_rcb_status, 4, 0)
        self.cfg_dpa_substate_change = init_signal(cfg_dpa_substate_change, 4, 0)
        self.cfg_obff_enable = init_signal(cfg_obff_enable, 2, 0)
        self.cfg_pl_status_change = init_signal(cfg_pl_status_change, 1, 0)
        self.cfg_tph_requester_enable = init_signal(cfg_tph_requester_enable, 4, 0)
        self.cfg_tph_st_mode = init_signal(cfg_tph_st_mode, 12, 0)
        self.cfg_vf_tph_requester_enable = init_signal(cfg_vf_tph_requester_enable, 8, 0)
        self.cfg_vf_tph_st_mode = init_signal(cfg_vf_tph_st_mode, 24, 0)

        # Configuration Received Message Interface
        self.cfg_msg_received = init_signal(cfg_msg_received, 1, 0)
        self.cfg_msg_received_data = init_signal(cfg_msg_received_data, 8, 0)
        self.cfg_msg_received_type = init_signal(cfg_msg_received_type, 5, 0)

        # Configuration Transmit Message Interface
        self.cfg_msg_transmit = init_signal(cfg_msg_transmit, 1)
        self.cfg_msg_transmit_type = init_signal(cfg_msg_transmit_type, 3)
        self.cfg_msg_transmit_data = init_signal(cfg_msg_transmit_data, 32)
        self.cfg_msg_transmit_done = init_signal(cfg_msg_transmit_done, 1, 0)

        # Configuration Flow Control Interface
        self.cfg_fc_ph = init_signal(cfg_fc_ph, 8, 0)
        self.cfg_fc_pd = init_signal(cfg_fc_pd, 12, 0)
        self.cfg_fc_nph = init_signal(cfg_fc_nph, 8, 0)
        self.cfg_fc_npd = init_signal(cfg_fc_npd, 12, 0)
        self.cfg_fc_cplh = init_signal(cfg_fc_cplh, 8, 0)
        self.cfg_fc_cpld = init_signal(cfg_fc_cpld, 12, 0)
        if isinstance(cfg_fc_sel, int):
            assert 0 <= cfg_fc_sel < 8
            self.cfg_fc_sel = cfg_fc_sel
        else:
            self.cfg_fc_sel = init_signal(cfg_fc_sel, 3)

        # Per-Function Status Interface
        self.cfg_per_func_status_control = init_signal(cfg_per_func_status_control, 3)
        self.cfg_per_func_status_data = init_signal(cfg_per_func_status_data, 16, 0)
        self.cfg_per_function_number = init_signal(cfg_per_function_number, 4)
        self.cfg_per_function_output_request = init_signal(cfg_per_function_output_request, 1)
        self.cfg_per_function_update_done = init_signal(cfg_per_function_update_done, 1, 0)

        # Configuration Control Interface
        self.cfg_hot_reset_in = init_signal(cfg_hot_reset_in, 1)
        self.cfg_hot_reset_out = init_signal(cfg_hot_reset_out, 1, 0)
        self.cfg_config_space_enable = init_signal(cfg_config_space_enable, 1)
        self.cfg_dsn = init_signal(cfg_dsn, 64)
        self.cfg_ds_port_number = init_signal(cfg_ds_port_number, 8)
        self.cfg_ds_bus_number = init_signal(cfg_ds_bus_number, 8)
        self.cfg_ds_device_number = init_signal(cfg_ds_device_number, 5)
        self.cfg_ds_function_number = init_signal(cfg_ds_function_number, 3)
        self.cfg_subsys_vend_id = init_signal(cfg_subsys_vend_id, 16)
        self.cfg_power_state_change_ack = init_signal(cfg_power_state_change_ack, 1)
        self.cfg_power_state_change_interrupt = init_signal(cfg_power_state_change_interrupt, 1, 0)
        self.cfg_err_cor_in = init_signal(cfg_err_cor_in, 1)
        self.cfg_err_uncor_in = init_signal(cfg_err_uncor_in, 1)
        self.cfg_flr_done = init_signal(cfg_flr_done, 4)
        self.cfg_vf_flr_done = init_signal(cfg_vf_flr_done, 8)
        self.cfg_flr_in_process = init_signal(cfg_flr_in_process, 4, 0)
        self.cfg_vf_flr_in_process = init_signal(cfg_vf_flr_in_process, 8, 0)
        self.cfg_req_pm_transition_l23_ready = init_signal(cfg_req_pm_transition_l23_ready, 1)
        self.cfg_link_training_enable = init_signal(cfg_link_training_enable, 1)

        # Configuration Interrupt Controller Interface
        self.cfg_interrupt_int = init_signal(cfg_interrupt_int, 4)
        self.cfg_interrupt_sent = init_signal(cfg_interrupt_sent, 1, 0)
        self.cfg_interrupt_pending = init_signal(cfg_interrupt_pending, 4)
        self.cfg_interrupt_msi_enable = init_signal(cfg_interrupt_msi_enable, 4, 0)
        self.cfg_interrupt_msi_vf_enable = init_signal(cfg_interrupt_msi_vf_enable, 8, 0)
        self.cfg_interrupt_msi_mmenable = init_signal(cfg_interrupt_msi_mmenable, 12, 0)
        self.cfg_interrupt_msi_mask_update = init_signal(cfg_interrupt_msi_mask_update, 1, 0)
        self.cfg_interrupt_msi_data = init_signal(cfg_interrupt_msi_data, 32, 0)
        self.cfg_interrupt_msi_select = init_signal(cfg_interrupt_msi_select, 4)
        self.cfg_interrupt_msi_int = init_signal(cfg_interrupt_msi_int, 32)
        self.cfg_interrupt_msi_pending_status = init_signal(cfg_interrupt_msi_pending_status, 32)
        self.cfg_interrupt_msi_pending_status_data_enable = init_signal(cfg_interrupt_msi_pending_status_data_enable, 1)
        self.cfg_interrupt_msi_pending_status_function_num = init_signal(cfg_interrupt_msi_pending_status_function_num, 4)
        self.cfg_interrupt_msi_sent = init_signal(cfg_interrupt_msi_sent, 1, 0)
        self.cfg_interrupt_msi_fail = init_signal(cfg_interrupt_msi_fail, 1, 0)
        self.cfg_interrupt_msix_enable = init_signal(cfg_interrupt_msix_enable, 2, 0)
        self.cfg_interrupt_msix_mask = init_signal(cfg_interrupt_msix_mask, 2, 0)
        self.cfg_interrupt_msix_vf_enable = init_signal(cfg_interrupt_msix_vf_enable, 8, 0)
        self.cfg_interrupt_msix_vf_mask = init_signal(cfg_interrupt_msix_vf_mask, 8)
        self.cfg_interrupt_msix_address = init_signal(cfg_interrupt_msix_address, 64)
        self.cfg_interrupt_msix_data = init_signal(cfg_interrupt_msix_data, 32)
        self.cfg_interrupt_msix_int = init_signal(cfg_interrupt_msix_int, 1)
        self.cfg_interrupt_msix_vec_pending = init_signal(cfg_interrupt_msix_vec_pending, 2)
        self.cfg_interrupt_msix_vec_pending_status = init_signal(cfg_interrupt_msix_vec_pending_status, 1)
        self.cfg_interrupt_msix_sent = init_signal(cfg_interrupt_msix_sent, 1, 0)
        self.cfg_interrupt_msix_fail = init_signal(cfg_interrupt_msix_fail, 1, 0)
        self.cfg_interrupt_msi_attr = init_signal(cfg_interrupt_msi_attr, 3)
        self.cfg_interrupt_msi_tph_present = init_signal(cfg_interrupt_msi_tph_present, 1)
        self.cfg_interrupt_msi_tph_type = init_signal(cfg_interrupt_msi_tph_type, 2)
        self.cfg_interrupt_msi_tph_st_tag = init_signal(cfg_interrupt_msi_tph_st_tag, 9)
        self.cfg_interrupt_msi_function_number = init_signal(cfg_interrupt_msi_function_number, 4)

        # Configuration Extend Interface
        self.cfg_ext_read_received = init_signal(cfg_ext_read_received, 1, 0)
        self.cfg_ext_write_received = init_signal(cfg_ext_write_received, 1, 0)
        self.cfg_ext_register_number = init_signal(cfg_ext_register_number, 10, 0)
        self.cfg_ext_function_number = init_signal(cfg_ext_function_number, 8, 0)
        self.cfg_ext_write_data = init_signal(cfg_ext_write_data, 32, 0)
        self.cfg_ext_write_byte_enable = init_signal(cfg_ext_write_byte_enable, 4, 0)
        self.cfg_ext_read_data = init_signal(cfg_ext_read_data, 32)
        self.cfg_ext_read_data_valid = init_signal(cfg_ext_read_data_valid, 1)

        # validate parameters
        assert self.dw in {64, 128, 256}

        # rescale clock frequency
        if self.user_clk_frequency is not None and self.user_clk_frequency < 1e6:
            self.user_clk_frequency *= 1e6

        if not self.pcie_generation or not self.pcie_link_width or not self.user_clk_frequency:
            self.log.info("Incomplete configuration specified, attempting to select reasonable options")
            # guess some reasonable values for unspecified parameters
            for config in reversed(valid_configs):
                # find configuration matching specified parameters
                if self.pcie_generation is not None and self.pcie_generation != config[0]:
                    continue
                if self.pcie_link_width is not None and self.pcie_link_width != config[1]:
                    continue
                if self.dw != config[2]:
                    continue
                if self.user_clk_frequency is not None and self.user_clk_frequency != config[3]:
                    continue

                # set the unspecified parameters
                if self.pcie_generation is None:
                    self.log.info("Setting PCIe speed to gen %d", config[0])
                    self.pcie_generation = config[0]
                if self.pcie_link_width is None:
                    self.log.info("Setting PCIe link width to x%d", config[1])
                    self.pcie_link_width = config[1]
                if self.user_clk_frequency is None:
                    self.log.info("Setting user clock frequency to %d MHz", config[3]/1e6)
                    self.user_clk_frequency = config[3]
                break

        self.log.info("Xilinx UltraScale PCIe hard IP core configuration:")
        self.log.info("  PCIe speed: gen %d", self.pcie_generation)
        self.log.info("  PCIe link width: x%d", self.pcie_link_width)
        self.log.info("  User clock frequency: %d MHz", self.user_clk_frequency/1e6)
        self.log.info("  Alignment: %s", self.alignment)
        self.log.info("  Enable RC straddling: %s", self.rc_straddle)
        self.log.info("  PF count: %d", self.pf_count)
        self.log.info("  Max payload size: %d", self.max_payload_size)
        self.log.info("  Enable client tag: %s", self.enable_client_tag)
        self.log.info("  Enable extended tag: %s", self.enable_extended_tag)
        self.log.info("  Enable parity: %s", self.enable_parity)
        self.log.info("  Enable RX message interface: %s", self.enable_rx_msg_interface)
        self.log.info("  Enable SR-IOV: %s", self.enable_sriov)
        self.log.info("  Enable extended configuration: %s", self.enable_extended_configuration)
        self.log.info("  Enable PF0 MSI: %s", self.pf0_msi_enable)
        self.log.info("  PF0 MSI vector count: %d", self.pf0_msi_count)
        self.log.info("  Enable PF1 MSI: %s", self.pf1_msi_enable)
        self.log.info("  PF1 MSI vector count: %d", self.pf1_msi_count)
        self.log.info("  Enable PF0 MSIX: %s", self.pf0_msix_enable)
        self.log.info("  PF0 MSIX table size: %d", self.pf0_msix_table_size)
        self.log.info("  PF0 MSIX table BIR: %d", self.pf0_msix_table_bir)
        self.log.info("  PF0 MSIX table offset: 0x%08x", self.pf0_msix_table_offset)
        self.log.info("  PF0 MSIX PBA BIR: %d", self.pf0_msix_pba_bir)
        self.log.info("  PF0 MSIX PBA offset: 0x%08x", self.pf0_msix_pba_offset)
        self.log.info("  Enable PF1 MSIX: %s", self.pf1_msix_enable)
        self.log.info("  PF1 MSIX table size: %d", self.pf1_msix_table_size)
        self.log.info("  PF1 MSIX table BIR: %d", self.pf1_msix_table_bir)
        self.log.info("  PF1 MSIX table offset: 0x%08x", self.pf1_msix_table_offset)
        self.log.info("  PF1 MSIX PBA BIR: %d", self.pf1_msix_pba_bir)
        self.log.info("  PF1 MSIX PBA offset: 0x%08x", self.pf1_msix_pba_offset)

        assert self.pcie_generation in {1, 2, 3}
        assert self.pcie_link_width in {1, 2, 4, 8, 16}
        assert self.user_clk_frequency in {62.5e6, 125e6, 250e6}
        assert self.alignment in {"address", "dword"}

        if self.dw < 256 or self.alignment != "dword":
            assert not self.rc_straddle, "RC straddling only supported with 256-bit, DWORD-aligned interface"

        # TODO change this when support added
        assert self.alignment == 'dword', "only dword alignment currently supported"

        # check for valid configuration
        config_valid = False
        for config in valid_configs:
            if self.pcie_generation != config[0]:
                continue
            if self.pcie_link_width != config[1]:
                continue
            if self.dw != config[2]:
                continue
            if self.user_clk_frequency != config[3]:
                continue

            config_valid = True
            break

        assert config_valid, "link speed/link width/clock speed/interface width setting combination not valid"

        # configure port
        self.upstream_port.max_link_speed = self.pcie_generation
        self.upstream_port.max_link_width = self.pcie_link_width

        # configure functions

        self.make_function()

        if self.pf0_msi_enable:
            self.functions[0].msi_cap.msi_multiple_message_capable = (self.pf0_msi_count-1).bit_length()
        else:
            self.functions[0].deregister_capability(self.functions[0].msi_cap)

        if self.pf0_msix_enable:
            self.functions[0].msix_cap.msix_table_size = self.pf0_msix_table_size
            self.functions[0].msix_cap.msix_table_bar_indicator_register = self.pf0_msix_table_bir
            self.functions[0].msix_cap.msix_table_offset = self.pf0_msix_table_offset
            self.functions[0].msix_cap.msix_pba_bar_indicator_register = self.pf0_msix_pba_bir
            self.functions[0].msix_cap.msix_pba_offset = self.pf0_msix_pba_offset
        else:
            self.functions[0].deregister_capability(self.functions[0].msix_cap)

        if self.pf_count > 1:
            self.make_function()

            if self.pf1_msi_enable:
                self.functions[1].msi_cap.msi_multiple_message_capable = (self.pf1_msi_count-1).bit_length()
            else:
                self.functions[1].deregister_capability(self.functions[1].msi_cap)

            if self.pf1_msix_enable:
                self.functions[1].msix_cap.msix_table_size = self.pf1_msix_table_size
                self.functions[1].msix_cap.msix_table_bar_indicator_register = self.pf1_msix_table_bir
                self.functions[1].msix_cap.msix_table_offset = self.pf1_msix_table_offset
                self.functions[1].msix_cap.msix_pba_bar_indicator_register = self.pf1_msix_pba_bir
                self.functions[1].msix_cap.msix_pba_offset = self.pf1_msix_pba_offset
            else:
                self.functions[1].deregister_capability(self.functions[1].msix_cap)

        for f in self.functions:
            f.pcie_cap.max_payload_size_supported = (self.max_payload_size//128-1).bit_length()
            f.pcie_cap.extended_tag_supported = self.enable_extended_tag

        if self.cfg_config_space_enable is None:
            self.config_space_enable = True

        # fork coroutines

        if self.user_clk is not None:
            cocotb.start_soon(Clock(self.user_clk, int(1e9/self.user_clk_frequency), units="ns").start())

        if self.rq_sink:
            cocotb.start_soon(self._run_rq_logic())
            cocotb.start_soon(self._run_rq_np_queue_logic())
            cocotb.start_soon(self._run_rq_seq_num_logic())
            if not self.enable_client_tag:
                cocotb.start_soon(self._run_rq_tag_logic())
        if self.rc_source:
            cocotb.start_soon(self._run_rc_logic())
        if self.cq_source:
            cocotb.start_soon(self._run_cq_logic())
        if self.cc_sink:
            cocotb.start_soon(self._run_cc_logic())
        if self.cfg_mgmt_addr is not None:
            cocotb.start_soon(self._run_cfg_mgmt_logic())
        cocotb.start_soon(self._run_cfg_status_logic())
        if self.cfg_fc_sel is not None:
            cocotb.start_soon(self._run_cfg_fc_logic())
        cocotb.start_soon(self._run_cfg_ctrl_logic())
        cocotb.start_soon(self._run_cfg_int_logic())

        cocotb.start_soon(self._run_reset())

    def get_free_tag(self):
        tag_count = min(256 if self.functions[0].pcie_cap.extended_tag_field_enable else 32, self.tag_count)

        tag = self.current_tag
        for k in range(tag_count):
            tag = (tag + 1) % tag_count
            if self.active_request[tag] is None:
                self.current_tag = tag
                return tag

        return None

    def get_available_tag_count(self):
        if self.functions[0].pcie_cap.extended_tag_field_enable:
            return self.active_request.count(None)
        else:
            return self.active_request[0:32].count(None)

    async def upstream_recv(self, tlp):
        self.log.debug("Got downstream TLP: %r", tlp)

        if tlp.fmt_type in {TlpType.CFG_READ_0, TlpType.CFG_WRITE_0}:
            # config type 0

            if not self.config_space_enable:
                self.log.warning("Configuration space disabled")

                tlp.release_fc()

                cpl = Tlp.create_crs_completion_for_tlp(tlp, PcieId(self.bus_num, 0, 0))
                self.log.debug("CRS Completion: %r", cpl)
                await self.upstream_send(cpl)
                return
            else:
                # capture address information
                self.bus_num = tlp.completer_id.bus

                # pass TLP to function
                for f in self.functions:
                    if f.pcie_id == tlp.completer_id:
                        await f.upstream_recv(tlp)
                        return

                tlp.release_fc()

                self.log.warning("Function not found: failed to route config type 0 TLP: %r", tlp)

        elif tlp.fmt_type in {TlpType.CFG_READ_1, TlpType.CFG_WRITE_1}:
            # config type 1

            tlp.release_fc()

            self.log.warning("Malformed TLP: endpoint received config type 1 TLP: %r", tlp)
        elif tlp.fmt_type in {TlpType.CPL, TlpType.CPL_DATA, TlpType.CPL_LOCKED, TlpType.CPL_LOCKED_DATA}:
            # Completion

            for f in self.functions:
                if f.pcie_id == tlp.requester_id:

                    tlp.release_fc()

                    tlp = Tlp_us(tlp)

                    tlp.error_code = ErrorCode.NORMAL_TERMINATION

                    if tlp.ep:
                        # poisoned
                        self.log.warning("Poisoned TLP: %r", tlp)
                        tlp.error_code = ErrorCode.POISONED

                    req = self.active_request[tlp.tag]

                    if not req:
                        # tag not active
                        self.log.warning("Invalid tag: %r", tlp)
                        tlp.error_code = ErrorCode.INVALID_TAG
                    elif tlp.requester_id != req.requester_id or tlp.attr != req.attr or tlp.tc != req.tc:
                        # requester ID, ATTR, or TC field mismatch
                        self.log.warning("Mismatched fields: %r", tlp)
                        tlp.error_code = ErrorCode.MISMATCH
                    elif tlp.status != CplStatus.SC:
                        # bad status
                        self.log.warning("Bad status: %r", tlp)
                        tlp.error_code = ErrorCode.BAD_STATUS
                        tlp.request_completed = True
                        self.active_request[tlp.tag] = None
                    elif req.fmt_type in {TlpType.MEM_READ, TlpType.MEM_READ_64}:
                        # completion for memory read request

                        # reconstruct lower address MSBs
                        lower_address = req.address + req.get_first_be_offset() + req.get_be_byte_count() - tlp.byte_count

                        if tlp.lower_address != lower_address & 0x7f:
                            self.log.warning("Lower address mismatch: %r", tlp)
                            tlp.error_code = ErrorCode.INVALID_ADDRESS
                        else:
                            tlp.lower_address = lower_address & 0xfff

                        # mark request completed
                        if tlp.byte_count <= tlp.length*4 - (tlp.lower_address & 0x3):
                            tlp.request_completed = True
                            self.active_request[tlp.tag] = None

                        # completion for read request has SC status but no data
                        if tlp.fmt_type in {TlpType.CPL, TlpType.CPL_LOCKED}:
                            tlp.error_code = ErrorCode.INVALID_LENGTH
                            tlp.request_completed = True
                            self.active_request[tlp.tag] = None

                    else:
                        # completion for other request
                        tlp.request_completed = True
                        self.active_request[tlp.tag] = None

                    # TODO track individual operations
                    self.cpld_credit_count = max(self.cpld_credit_count-tlp.get_data_credits(), 0)
                    self.cpld_credit_released.set()

                    # check and track buffer occupancy
                    data_fc = tlp.get_data_credits()

                    if self.rx_buf_cplh_fc_count+1 <= self.rx_buf_cplh_fc_limit and self.rx_buf_cpld_fc_count+data_fc+1 <= self.rx_buf_cpld_fc_limit:
                        self.rx_buf_cplh_fc_count += 1
                        self.rx_buf_cpld_fc_count += data_fc+1
                        self.rc_queue.put_nowait(tlp)
                    else:
                        self.log.warning("No space in RX completion buffer, dropping TLP: CPLH %d (limit %d), CPLD %d (limit %d)",
                            self.rx_buf_cplh_fc_count, self.rx_buf_cplh_fc_limit, self.rx_buf_cpld_fc_count, self.rx_buf_cpld_fc_limit)
                        self.local_error = True

                    self.tag_available_count = self.get_available_tag_count()

                    return

            tlp.release_fc()

            self.log.warning("Unexpected completion: failed to route completion to function: %r", tlp)
            return  # no UR response for completion
        elif tlp.fmt_type in {TlpType.IO_READ, TlpType.IO_WRITE}:
            # IO read/write

            for f in self.functions:
                bar = f.match_bar(tlp.address, True)
                if bar:

                    tlp.release_fc()

                    tlp = Tlp_us(tlp)
                    tlp.bar_id = bar[0]
                    tlp.bar_aperture = (~self.functions[0].bar_mask[bar[0]] & 0xffffffff).bit_length()
                    tlp.completer_id = f.pcie_id
                    self.cq_queue.put_nowait(tlp)

                    return

            tlp.release_fc()

            self.log.warning("No BAR match: IO request did not match any BARs: %r", tlp)
        elif tlp.fmt_type in {TlpType.MEM_READ, TlpType.MEM_READ_64, TlpType.MEM_WRITE, TlpType.MEM_WRITE_64}:
            # Memory read/write

            for f in self.functions:
                bar = f.match_bar(tlp.address)
                if bar:

                    tlp.release_fc()

                    tlp = Tlp_us(tlp)
                    tlp.bar_id = bar[0]
                    if self.functions[0].bar[bar[0]] & 4:
                        tlp.bar_aperture = (~(self.functions[0].bar_mask[bar[0]] |
                            (self.functions[0].bar_mask[bar[0]+1] << 32)) & 0xffffffffffffffff).bit_length()
                    else:
                        tlp.bar_aperture = (~self.functions[0].bar_mask[bar[0]] & 0xffffffff).bit_length()
                    tlp.completer_id = tlp.completer_id._replace(bus=self.bus_num)
                    self.cq_queue.put_nowait(tlp)

                    return

            tlp.release_fc()

            if tlp.fmt_type in {TlpType.MEM_WRITE, TlpType.MEM_WRITE_64}:
                self.log.warning("No BAR match: memory write request did not match any BARs: %r", tlp)
                return  # no UR response for write request
            else:
                self.log.warning("No BAR match: memory read request did not match any BARs: %r", tlp)
        else:
            raise Exception("TODO")

        # Unsupported request
        cpl = Tlp.create_ur_completion_for_tlp(tlp, PcieId(self.bus_num, 0, 0))
        self.log.debug("UR Completion: %r", cpl)
        await self.upstream_send(cpl)

    async def _run_reset(self):
        clock_edge_event = RisingEdge(self.user_clk)

        while True:
            await clock_edge_event
            await clock_edge_event

            if self.user_reset is not None:
                self.user_reset.value = 1

            if self.sys_reset is not None:
                if not self.sys_reset.value:
                    await RisingEdge(self.sys_reset)
                await First(FallingEdge(self.sys_reset), Timer(100, 'ns'))
                await First(FallingEdge(self.sys_reset), RisingEdge(self.user_clk))
                if not self.sys_reset.value:
                    continue
            else:
                await Timer(100, 'ns')
                await RisingEdge(self.user_clk)

            if self.user_reset is not None:
                self.user_reset.value = 0

            if self.sys_reset is not None:
                await FallingEdge(self.sys_reset)
            else:
                return

            # pcie_perstn1_in
            # pcie_perstn0_out
            # pcie_perstn1_out

    async def _run_cq_logic(self):
        clock_edge_event = RisingEdge(self.user_clk)

        while True:
            await clock_edge_event

            # increment cq_np_req_count and saturate at 32
            if self.pcie_cq_np_req is None or self.pcie_cq_np_req.value:
                self.cq_np_req_count = min(self.cq_np_req_count+1, 32)

            # handle completer requests
            # send any queued non-posted requests first
            while not self.cq_np_queue.empty() and self.cq_np_req_count > 0:
                tlp = self.cq_np_queue.get_nowait()
                self.cq_np_req_count -= 1
                await self.cq_source.send(tlp.pack_us_cq())

            # handle new requests
            while not self.cq_queue.empty():
                tlp = self.cq_queue.get_nowait()

                if tlp.fmt_type in {TlpType.IO_READ, TlpType.IO_WRITE, TlpType.MEM_READ, TlpType.MEM_READ_64}:
                    # non-posted request
                    if self.cq_np_req_count > 0:
                        # have credit, can forward
                        self.cq_np_req_count -= 1
                        await self.cq_source.send(tlp.pack_us_cq())
                    else:
                        # no credits, put it in the queue
                        self.cq_np_queue.put_nowait(tlp)
                else:
                    # posted request
                    await self.cq_source.send(tlp.pack_us_cq())

            # output new cq_np_req_count
            if self.pcie_cq_np_req_count is not None:
                self.pcie_cq_np_req_count.value = self.cq_np_req_count

    async def _run_cc_logic(self):
        while True:
            tlp = Tlp_us.unpack_us_cc(await self.cc_sink.recv(), self.enable_parity)

            if not tlp.completer_id_enable:
                tlp.completer_id = tlp.completer_id._replace(bus=self.bus_num)

            if not tlp.discontinue:
                await self.send(Tlp(tlp))

    async def _run_rq_logic(self):
        while True:
            tlp = Tlp_us.unpack_us_rq(await self.rq_sink.recv(), self.enable_parity)

            if tlp.discontinue:
                self.log.warning("Discontinue bit set, discarding TLP: %r", tlp)
                continue

            if not tlp.requester_id_enable:
                tlp.requester_id = tlp.requester_id._replace(bus=self.bus_num)

            if tlp.is_nonposted():
                # non-posted request

                if self.rq_np_queue.empty() and self.cpld_credit_count+tlp.get_data_credits() <= self.cpld_credit_limit and (self.enable_client_tag or self.tag_available_count > 0):
                    # queue empty and have data credits; skip queue and send immediately to preserve ordering

                    if not self.functions[tlp.requester_id.function].bus_master_enable:
                        self.log.warning("Bus mastering disabled, dropping TLP: %r", tlp)
                        # TODO: internal response
                        continue

                    if self.functions[0].pcie_cap.extended_tag_field_enable:
                        assert tlp.tag < 64, "tag out of range (extended tags enabled)"
                    else:
                        assert tlp.tag < 32, "tag out of range (extended tags disabled)"

                    if not self.enable_client_tag:
                        tlp.tag = self.get_free_tag()
                        self.rq_tag.put_nowait(tlp.tag)

                    assert not self.active_request[tlp.tag], "active tag reused"
                    self.active_request[tlp.tag] = tlp
                    self.tag_available_count = self.get_available_tag_count()

                    self.cpld_credit_count += tlp.get_data_credits()

                    await self.send(Tlp(tlp))
                    self.rq_seq_num.put_nowait(tlp.seq_num)

                else:
                    # queue not empty or insufficient data credits; enqueue

                    # block to wait for space in queue
                    while self.rq_np_queue.qsize() >= self.rq_np_limit:
                        self.rq_np_queue_dequeue.clear()
                        await self.rq_np_queue_dequeue.wait()

                    self.rq_np_queue.put_nowait(tlp)
            else:
                # posted request; send immediately

                if not self.functions[tlp.requester_id.function].bus_master_enable:
                    self.log.warning("Bus mastering disabled, dropping TLP: %r", tlp)
                    # TODO: internal response
                    continue

                await self.send(Tlp(tlp))
                self.rq_seq_num.put_nowait(tlp.seq_num)

    async def _run_rq_np_queue_logic(self):
        while True:
            tlp = await self.rq_np_queue.get()
            self.rq_np_queue_dequeue.set()

            while True:
                # wait for data credits
                if self.cpld_credit_count+tlp.get_data_credits() > self.cpld_credit_limit:
                    self.cpld_credit_released.clear()
                    await self.cpld_credit_released.wait()
                    continue

                # wait for tags
                if not self.enable_client_tag and self.tag_available_count <= 0:
                    self.tag_release.clear()
                    await self.tag_release.wait()
                    continue

                break

            if not self.functions[tlp.requester_id.function].bus_master_enable:
                self.log.warning("Bus mastering disabled, dropping TLP: %r", tlp)
                # TODO: internal response
                continue

            self.cpld_credit_count += tlp.get_data_credits()

            if not self.enable_client_tag:
                tlp.tag = self.get_free_tag()
                self.rq_tag.put_nowait(tlp.tag)

            assert not self.active_request[tlp.tag], "active tag reused"
            self.active_request[tlp.tag] = tlp
            self.tag_available_count = self.get_available_tag_count()

            await self.send(Tlp(tlp))
            self.rq_seq_num.put_nowait(tlp.seq_num)

    async def _run_rq_seq_num_logic(self):
        clock_edge_event = RisingEdge(self.user_clk)

        while True:
            await clock_edge_event

            if self.pcie_rq_seq_num is not None:
                self.pcie_rq_seq_num_vld.value = 0
                if not self.rq_seq_num.empty():
                    self.pcie_rq_seq_num.value = self.rq_seq_num.get_nowait()
                    self.pcie_rq_seq_num_vld.value = 1
            elif not self.rq_seq_num.empty():
                self.rq_seq_num.get_nowait()

    async def _run_rq_tag_logic(self):
        clock_edge_event = RisingEdge(self.user_clk)

        while True:
            await clock_edge_event

            if self.pcie_rq_tag_av is not None:
                self.pcie_rq_tag_av.value = min(0x3, self.tag_available_count)

            if self.pcie_rq_tag is not None:
                self.pcie_rq_tag_vld.value = 0
                if not self.rq_tag.empty():
                    self.pcie_rq_tag.value = self.rq_tag.get_nowait()
                    self.pcie_rq_tag_vld.value = 1
            elif not self.rq_tag.empty():
                self.rq_tag.get_nowait()

    async def _run_rc_logic(self):
        while True:
            tlp = await self.rc_queue.get()
            await self.rc_source.send(tlp.pack_us_rc())

            self.rx_buf_cplh_fc_count = max(self.rx_buf_cplh_fc_count-1, 0)
            self.rx_buf_cpld_fc_count = max(self.rx_buf_cpld_fc_count-(tlp.get_data_credits()+1), 0)

    async def _run_tx_fc_logic(self):
        clock_edge_event = RisingEdge(self.user_clk)

        while True:
            await clock_edge_event

            # transmit flow control
            # TODO
            if self.pcie_tfc_nph_av is not None:
                self.pcie_tfc_nph_av.value = 0x3
            if self.pcie_tfc_npd_av is not None:
                self.pcie_tfc_npd_av.value = 0x3

    async def _run_cfg_mgmt_logic(self):
        clock_edge_event = RisingEdge(self.user_clk)

        while True:
            await clock_edge_event

            # configuration management
            cfg_mgmt_addr = self.cfg_mgmt_addr.value.integer
            function = (cfg_mgmt_addr >> 10) & 0x7f
            reg_num = cfg_mgmt_addr & 0x3ff
            write_data = self.cfg_mgmt_write_data.value.integer
            byte_enable = self.cfg_mgmt_byte_enable.value.integer
            cfg_mgmt_read = self.cfg_mgmt_read.value.integer
            cfg_mgmt_write = self.cfg_mgmt_write.value.integer

            if self.cfg_mgmt_read_write_done.value:
                self.cfg_mgmt_read_write_done.value = 0
            elif cfg_mgmt_read or cfg_mgmt_write:
                for k in range(3):
                    await RisingEdge(self.user_clk)
                if cfg_mgmt_read:
                    if cfg_mgmt_addr & (1 << 18):
                        # internal register access
                        pass
                    else:
                        self.cfg_mgmt_read_data.value = await self.functions[function].read_config_register(reg_num)
                else:
                    if cfg_mgmt_addr & (1 << 18):
                        # internal register access
                        pass
                    else:
                        await self.functions[function].write_config_register(reg_num, write_data, byte_enable)
                self.cfg_mgmt_read_write_done.value = 1
            # cfg_mgmt_type1_cfg_reg_access

    async def _run_cfg_status_logic(self):
        clock_edge_event = RisingEdge(self.user_clk)

        while True:
            await clock_edge_event

            # configuration status
            if self.sys_reset is not None and not self.sys_reset.value:
                if self.cfg_phy_link_down is not None:
                    self.cfg_phy_link_down.value = 1
                if self.user_lnk_up is not None:
                    self.user_lnk_up.value = 0
            else:
                if self.cfg_phy_link_down is not None:
                    self.cfg_phy_link_down.value = 0  # TODO
                if self.user_lnk_up is not None:
                    self.user_lnk_up.value = 1  # TODO

            # cfg_phy_link_status
            if self.cfg_negotiated_width is not None:
                self.cfg_negotiated_width.value = self.functions[0].pcie_cap.negotiated_link_width
            if self.cfg_current_speed is not None:
                self.cfg_current_speed.value = (1 << (self.functions[0].pcie_cap.current_link_speed & 3)) >> 1
            if self.cfg_max_payload is not None:
                self.cfg_max_payload.value = self.functions[0].pcie_cap.max_payload_size
            if self.cfg_max_read_req is not None:
                self.cfg_max_read_req.value = self.functions[0].pcie_cap.max_read_request_size

            if self.cfg_function_status is not None:
                status = 0
                for k in range(len(self.functions)):
                    if self.functions[k].bus_master_enable:
                        status |= 0x07 << k*4
                    if self.functions[k].interrupt_disable:
                        status |= 0x08 << k*4
                self.cfg_function_status.value = status

            # cfg_vf_status
            # cfg_function_power_state
            # cfg_vf_power_state
            # cfg_link_power_state
            # cfg_err_cor_out
            # cfg_err_nonfatal_out
            # cfg_err_fatal_out

            if self.cfg_local_error is not None:
                self.cfg_local_error.value = self.local_error
                self.local_error = False

            # cfg_ltr_enable
            # cfg_ltssm_state

            if self.cfg_rcb_status is not None:
                status = 0
                for k in range(len(self.functions)):
                    if self.functions[k].pcie_cap.read_completion_boundary:
                        status |= 1 << k
                self.cfg_rcb_status.value = status

            # cfg_dpa_substate_change
            # cfg_obff_enable
            # cfg_pl_status_change
            # cfg_tph_requester_enable
            # cfg_tph_st_mode
            # cfg_vf_tph_requester_enable
            # cfg_vf_tph_st_mode

            # cfg_per_func_status_control
            # cfg_per_func_status_data
            # cfg_per_function_number
            # cfg_per_function_output_request
            # cfg_per_function_update_done

    async def _run_cfg_msg_rx_logic(self):
        clock_edge_event = RisingEdge(self.user_clk)

        while True:
            await clock_edge_event

            # cfg_msg_received
            # cfg_msg_received_data
            # cfg_msg_received_type

    async def _run_cfg_msg_tx_logic(self):
        clock_edge_event = RisingEdge(self.user_clk)

        while True:
            await clock_edge_event

            # cfg_msg_transmit
            # cfg_msg_transmit_type
            # cfg_msg_transmit_data
            # cfg_msg_transmit_done

    async def _run_cfg_fc_logic(self):
        clock_edge_event = RisingEdge(self.user_clk)

        while True:
            await clock_edge_event

            if isinstance(self.cfg_fc_sel, int):
                sel = self.cfg_fc_sel
            else:
                sel = self.cfg_fc_sel.value.integer

            if (sel == 0b000):
                # Receive credits at link partner
                cfg_fc_ph = self.upstream_port.fc_state[0].ph.rx_credits_available
                cfg_fc_pd = self.upstream_port.fc_state[0].pd.rx_credits_available
                cfg_fc_nph = self.upstream_port.fc_state[0].nph.rx_credits_available
                cfg_fc_npd = self.upstream_port.fc_state[0].npd.rx_credits_available
                cfg_fc_cplh = self.upstream_port.fc_state[0].cplh.rx_credits_available
                cfg_fc_cpld = self.upstream_port.fc_state[0].cpld.rx_credits_available
            elif (sel == 0b001):
                # Receive credit limit
                cfg_fc_ph = self.upstream_port.fc_state[0].ph.rx_credits_allocated
                cfg_fc_pd = self.upstream_port.fc_state[0].pd.rx_credits_allocated
                cfg_fc_nph = self.upstream_port.fc_state[0].nph.rx_credits_allocated
                cfg_fc_npd = self.upstream_port.fc_state[0].npd.rx_credits_allocated
                cfg_fc_cplh = self.upstream_port.fc_state[0].cplh.rx_credits_allocated
                cfg_fc_cpld = self.upstream_port.fc_state[0].cpld.rx_credits_allocated
            elif (sel == 0b010):
                # Receive credits consumed
                cfg_fc_ph = self.upstream_port.fc_state[0].ph.rx_credits_received
                cfg_fc_pd = self.upstream_port.fc_state[0].pd.rx_credits_received
                cfg_fc_nph = self.upstream_port.fc_state[0].nph.rx_credits_received
                cfg_fc_npd = self.upstream_port.fc_state[0].npd.rx_credits_received
                cfg_fc_cplh = self.upstream_port.fc_state[0].cplh.rx_credits_received
                cfg_fc_cpld = self.upstream_port.fc_state[0].cpld.rx_credits_received
            elif (sel == 0b011):
                # Available space in receive buffer
                # TODO
                cfg_fc_ph = 0
                cfg_fc_pd = 0
                cfg_fc_nph = 0
                cfg_fc_npd = 0
                cfg_fc_cplh = 0
                cfg_fc_cpld = 0
            elif (sel == 0b100):
                # Transmit credits available
                cfg_fc_ph = self.upstream_port.fc_state[0].ph.tx_credits_available
                cfg_fc_pd = self.upstream_port.fc_state[0].pd.tx_credits_available
                cfg_fc_nph = self.upstream_port.fc_state[0].nph.tx_credits_available
                cfg_fc_npd = self.upstream_port.fc_state[0].npd.tx_credits_available
                cfg_fc_cplh = self.upstream_port.fc_state[0].cplh.tx_credits_available
                cfg_fc_cpld = self.upstream_port.fc_state[0].cpld.tx_credits_available
            elif (sel == 0b101):
                # Transmit credit limit
                cfg_fc_ph = self.upstream_port.fc_state[0].ph.tx_credit_limit
                cfg_fc_pd = self.upstream_port.fc_state[0].pd.tx_credit_limit
                cfg_fc_nph = self.upstream_port.fc_state[0].nph.tx_credit_limit
                cfg_fc_npd = self.upstream_port.fc_state[0].npd.tx_credit_limit
                cfg_fc_cplh = self.upstream_port.fc_state[0].cplh.tx_credit_limit
                cfg_fc_cpld = self.upstream_port.fc_state[0].cpld.tx_credit_limit
            elif (sel == 0b110):
                # Transmit credits consumed
                cfg_fc_ph = self.upstream_port.fc_state[0].ph.tx_credits_consumed
                cfg_fc_pd = self.upstream_port.fc_state[0].pd.tx_credits_consumed
                cfg_fc_nph = self.upstream_port.fc_state[0].nph.tx_credits_consumed
                cfg_fc_npd = self.upstream_port.fc_state[0].npd.tx_credits_consumed
                cfg_fc_cplh = self.upstream_port.fc_state[0].cplh.tx_credits_consumed
                cfg_fc_cpld = self.upstream_port.fc_state[0].cpld.tx_credits_consumed
            else:
                # Reserved
                cfg_fc_ph = 0
                cfg_fc_pd = 0
                cfg_fc_nph = 0
                cfg_fc_npd = 0
                cfg_fc_cplh = 0
                cfg_fc_cpld = 0

            if self.cfg_fc_ph is not None:
                self.cfg_fc_ph.value = cfg_fc_ph & 0xff
            if self.cfg_fc_pd is not None:
                self.cfg_fc_pd.value = cfg_fc_pd & 0xfff
            if self.cfg_fc_nph is not None:
                self.cfg_fc_nph.value = cfg_fc_nph & 0xff
            if self.cfg_fc_npd is not None:
                self.cfg_fc_npd.value = cfg_fc_npd & 0xfff
            if self.cfg_fc_cplh is not None:
                self.cfg_fc_cplh.value = cfg_fc_cplh & 0xff
            if self.cfg_fc_cpld is not None:
                self.cfg_fc_cpld.value = cfg_fc_cpld & 0xfff

    async def _run_cfg_ctrl_logic(self):
        clock_edge_event = RisingEdge(self.user_clk)

        while True:
            await clock_edge_event

            if self.sys_reset is not None and not self.sys_reset.value:
                self.config_space_enable = False
            else:
                if self.cfg_config_space_enable is not None:
                    self.config_space_enable = bool(self.cfg_config_space_enable.value)
                else:
                    self.config_space_enable = True

            # cfg_hot_reset_in
            # cfg_hot_reset_out
            # cfg_dsn
            # cfg_ds_port_number
            # cfg_ds_bus_number
            # cfg_ds_device_number
            # cfg_ds_function_number
            # cfg_subsys_vend_id
            # cfg_power_state_change_ack
            # cfg_power_state_change_interrupt
            # cfg_err_cor_in
            # cfg_err_uncor_in
            # cfg_flr_done
            # cfg_vf_flr_done
            # cfg_flr_in_process
            # cfg_vf_flr_in_process
            # cfg_req_pm_transition_l23_ready
            # cfg_link_training_enable

    async def _run_cfg_int_logic(self):
        clock_edge_event = RisingEdge(self.user_clk)

        while True:
            await clock_edge_event

            msi_int = 0
            msi_function_number = 0
            msi_attr = TlpAttr(0)
            msi_select = 0
            msi_pending_status_data_enable = 0
            msi_pending_status_function_num = 0
            msi_pending_status = 0
            msix_int = 0
            msix_address = 0
            msix_data = 0

            if self.cfg_interrupt_msi_int is not None:
                msi_int = self.cfg_interrupt_msi_int.value.integer
            if self.cfg_interrupt_msi_function_number is not None:
                msi_function_number = self.cfg_interrupt_msi_function_number.value.integer
            if self.cfg_interrupt_msi_attr is not None:
                msi_attr = TlpAttr(self.cfg_interrupt_msi_attr.value.integer)
            if self.cfg_interrupt_msi_select is not None:
                msi_select = self.cfg_interrupt_msi_select.value.integer
            if self.cfg_interrupt_msi_pending_status_data_enable is not None:
                msi_pending_status_data_enable = self.cfg_interrupt_msi_pending_status_data_enable.value.integer
            if self.cfg_interrupt_msi_pending_status_function_num is not None:
                msi_pending_status_function_num = self.cfg_interrupt_msi_pending_status_function_num.value.integer
            if self.cfg_interrupt_msi_pending_status is not None:
                msi_pending_status = self.cfg_interrupt_msi_pending_status.value.integer
            if self.cfg_interrupt_msix_int is not None:
                msix_int = self.cfg_interrupt_msix_int.value.integer
            if self.cfg_interrupt_msix_address is not None:
                msix_address = self.cfg_interrupt_msix_address.value.integer
            if self.cfg_interrupt_msix_data is not None:
                msix_data = self.cfg_interrupt_msix_data.value.integer

            # INTx
            # cfg_interrupt_int
            # cfg_interrupt_sent
            # cfg_interrupt_pending

            # MSI
            if self.cfg_interrupt_msi_enable is not None:
                val = 0
                for k in range(min(len(self.functions), 2)):
                    if self.functions[k].msi_cap.msi_enable:
                        val |= 1 << k
                self.cfg_interrupt_msi_enable.value = val

            # cfg_interrupt_msi_vf_enable

            if self.cfg_interrupt_msi_sent is not None:
                self.cfg_interrupt_msi_sent.value = 0
            if self.cfg_interrupt_msi_fail is not None:
                self.cfg_interrupt_msi_fail.value = 0
            if msi_int:
                bits = [i for i in range(32) if msi_int >> i & 1]
                if len(bits) == 1 and msi_function_number < len(self.functions):
                    self.log.info("Issue MSI interrupt (index %d)", bits[0])
                    await self.functions[msi_function_number].msi_cap.issue_msi_interrupt(bits[0], attr=msi_attr)
                    if self.cfg_interrupt_msi_sent is not None:
                        self.cfg_interrupt_msi_sent.value = 1

            if self.cfg_interrupt_msi_mmenable is not None:
                val = 0
                for k in range(min(len(self.functions), 2)):
                    val |= (self.functions[k].msi_cap.msi_multiple_message_enable & 0x7) << k*3
                self.cfg_interrupt_msi_mmenable.value = val

            # cfg_interrupt_msi_mask_update

            if self.cfg_interrupt_msi_data is not None:
                if msi_select == 0b1111:
                    self.cfg_interrupt_msi_data.value = 0
                else:
                    if msi_select < len(self.functions):
                        self.cfg_interrupt_msi_data.value = self.functions[msi_select].msi_cap.msi_mask_bits
                    else:
                        self.cfg_interrupt_msi_data.value = 0
            if msi_pending_status_data_enable:
                if msi_pending_status_function_num < len(self.functions):
                    self.functions[msi_pending_status_function_num].msi_cap.msi_pending_bits = msi_pending_status

            # MSI-X
            if self.cfg_interrupt_msix_enable is not None:
                val = 0
                for k in range(min(len(self.functions), 2)):
                    if self.functions[k].msix_cap.msix_enable:
                        val |= 1 << k
                self.cfg_interrupt_msix_enable.value = val
            if self.cfg_interrupt_msix_mask is not None:
                val = 0
                for k in range(min(len(self.functions), 2)):
                    if self.functions[k].msix_cap.msix_function_mask:
                        val |= 1 << k
                self.cfg_interrupt_msix_mask.value = val
            # cfg_interrupt_msix_vf_enable
            # cfg_interrupt_msix_vf_mask

            if self.cfg_interrupt_msix_sent is not None:
                self.cfg_interrupt_msix_sent.value = 0
            if self.cfg_interrupt_msix_fail is not None:
                self.cfg_interrupt_msix_fail.value = 0
            if msix_int:
                if msi_function_number < len(self.functions):
                    self.log.info("Issue MSI-X interrupt (addr 0x%08x, data 0x%08x)", msix_address, msix_data)
                    await self.functions[msi_function_number].msix_cap.issue_msix_interrupt(msix_address, msix_data, attr=msi_attr)
                    if self.cfg_interrupt_msix_sent is not None:
                        self.cfg_interrupt_msix_sent.value = 1

            # MSI/MSI-X
            # cfg_interrupt_msi_tph_present
            # cfg_interrupt_msi_tph_type
            # cfg_interrupt_msi_tph_st_tag

    async def _run_cfg_extend_logic(self):
        clock_edge_event = RisingEdge(self.user_clk)

        while True:
            await clock_edge_event

            # cfg_ext_read_received
            # cfg_ext_write_received
            # cfg_ext_register_number
            # cfg_ext_function_number
            # cfg_ext_write_data
            # cfg_ext_write_byte_enable
            # cfg_ext_read_data
            # cfg_ext_read_data_valid



================================================
FILE: cocotbext/pcie/xilinx/us/usp_model.py
================================================
"""

Copyright (c) 2020 Alex Forencich

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

"""

import enum

import cocotb
from cocotb.clock import Clock
from cocotb.queue import Queue
from cocotb.triggers import RisingEdge, FallingEdge, Timer, First, Event

from cocotbext.pcie.core import Device, Endpoint, __version__
from cocotbext.pcie.core.caps import MsiCapability, MsixCapability
from cocotbext.pcie.core.caps import AerExtendedCapability, PcieExtendedCapability
from cocotbext.pcie.core.utils import PcieId
from cocotbext.pcie.core.tlp import Tlp, TlpType, TlpAttr, CplStatus

from .interface import RqSink, RcSource, CqSource, CcSink
from .tlp import Tlp_us, ErrorCode


valid_configs = [
    # speed, links, width, freq
    (1,  1,  64,  62.5e6),
    (1,  1,  64, 125.0e6),
    (1,  1,  64, 250.0e6),
    (1,  2,  64,  62.5e6),
    (1,  2,  64, 125.0e6),
    (1,  2,  64, 250.0e6),
    (1,  4,  64, 125.0e6),
    (1,  4,  64, 250.0e6),
    (1,  8,  64, 250.0e6),
    (1,  8, 128, 125.0e6),
    (1, 16, 128, 250.0e6),
    (2,  1,  64,  62.5e6),
    (2,  1,  64, 125.0e6),
    (2,  1,  64, 250.0e6),
    (2,  2,  64, 125.0e6),
    (2,  2,  64, 250.0e6),
    (2,  4,  64, 250.0e6),
    (2,  4, 128, 125.0e6),
    (2,  8, 128, 250.0e6),
    (2,  8, 256, 125.0e6),
    (2, 16, 256, 250.0e6),
    (3,  1,  64, 125.0e6),
    (3,  1,  64, 250.0e6),
    (3,  2,  64, 250.0e6),
    (3,  2, 128, 125.0e6),
    (3,  4, 128, 250.0e6),
    (3,  4, 256, 125.0e6),
    (3,  8, 256, 250.0e6),
    (3, 16, 512, 250.0e6),
    (4,  1,  64, 250.0e6),
    (4,  1, 128, 125.0e6),
    (4,  2, 128, 250.0e6),
    (4,  2, 256, 125.0e6),
    (4,  4, 256, 250.0e6),
    (4,  8, 512, 250.0e6),
]


class LocalError(enum.IntEnum):
    PHY_LAYER_ERROR_DETECTED    = 0b00001
    LINK_REPLAY_TIMEOUT         = 0b00010
    LINK_REPLAY_ROLLOVER        = 0b00011
    LINK_RX_BAD_TLP             = 0b00100
    LINK_RX_BAD_DLLP            = 0b00101
    LINK_PROTOCOL_ERR           = 0b00110
    REPLAY_BUF_COR_ECC_ERR      = 0b00111
    REPLAY_BUF_UNCOR_ECC_ERR    = 0b01000
    RX_P_REQ_BUF_COR_ECC_ERR    = 0b01001
    RX_P_REQ_BUF_UNCOR_ECC_ERR  = 0b01010
    RX_CPL_BUF_COR_ECC_ERR      = 0b01011
    RX_CPL_BUF_UNCOR_ECC_ERR    = 0b01100
    RX_P_REQ_BUF_OVF_ERR        = 0b01101
    RX_NP_REQ_BUF_OVF_ERR       = 0b01110
    RX_CPL_BUF_OVF_ERR          = 0b01111
    FC_PROTOCOL_ERR             = 0b10000
    TX_PAR_ERR                  = 0b10001
    RX_UNEXPECTED_CPL           = 0b10010
    CPL_TIMEOUT                 = 0b10011
    AXI4ST_RQ_INTFC_PKT_DROP    = 0b10100
    AXI4ST_CC_INTFC_PKT_DROP    = 0b10101
    AXI4ST_CQ_EP_DROP           = 0b10110
    USER_SIG_INT_COR_ERR        = 0b10111
    USER_SIG_INT_UNCOR_ERR      = 0b11000


class UltraScalePlusPcieFunction(Endpoint):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        # PCIe capabilities
        self.register_capability(self.pm_cap, offset=0x10)

        self.msi_cap = MsiCapability()
        self.msi_cap.msi_64bit_address_capable = 1
        self.msi_cap.msi_per_vector_mask_capable = 0
        self.register_capability(self.msi_cap, offset=0x12)

        self.msix_cap = MsixCapability()
        self.register_capability(self.msix_cap, offset=0x18)

        self.register_capability(self.pcie_cap, offset=0x1c)

        # PCIe extended capabilities
        self.aer_ext_cap = AerExtendedCapability()
        self.register_capability(self.aer_ext_cap, offset=0x40)

        # SRIOV 0x50
        # ARI 0x60
        # DSN 0x68

        self.pcie_ext_cap = PcieExtendedCapability()
        self.register_capability(self.pcie_ext_cap, offset=0x70)

        # VC 0x80
        # TPH 0x88
        # VSEC 0xd4 (MCAP)


def init_signal(sig, width=None, initval=None):
    if sig is None:
        return None
    if width is not None:
        assert len(sig) == width
    if initval is not None:
        sig.setimmediatevalue(initval)
    return sig


class UltraScalePlusPcieDevice(Device):
    def __init__(self,
            # configuration options
            pcie_generation=None,
            pcie_link_width=None,
            user_clk_frequency=None,
            alignment="dword",
            cq_straddle=False,
            cc_straddle=False,
            rq_straddle=False,
            rc_straddle=False,
            rc_4tlp_straddle=False,
            pf_count=1,
            max_payload_size=128,
            enable_client_tag=True,
            enable_extended_tag=False,
            enable_parity=False,
            enable_rx_msg_interface=False,
            enable_sriov=False,
            enable_extended_configuration=False,

            pf0_msi_enable=False,
            pf0_msi_count=1,
            pf1_msi_enable=False,
            pf1_msi_count=1,
            pf2_msi_enable=False,
            pf2_msi_count=1,
            pf3_msi_enable=False,
            pf3_msi_count=1,
            pf0_msix_enable=False,
            pf0_msix_table_size=0,
            pf0_msix_table_bir=0,
            pf0_msix_table_offset=0x00000000,
            pf0_msix_pba_bir=0,
            pf0_msix_pba_offset=0x00000000,
            pf1_msix_enable=False,
            pf1_msix_table_size=0,
            pf1_msix_table_bir=0,
            pf1_msix_table_offset=0x00000000,
            pf1_msix_pba_bir=0,
            pf1_msix_pba_offset=0x00000000,
            pf2_msix_enable=False,
            pf2_msix_table_size=0,
            pf2_msix_table_bir=0,
            pf2_msix_table_offset=0x00000000,
            pf2_msix_pba_bir=0,
            pf2_msix_pba_offset=0x00000000,
            pf3_msix_enable=False,
            pf3_msix_table_size=0,
            pf3_msix_table_bir=0,
            pf3_msix_table_offset=0x00000000,
            pf3_msix_pba_bir=0,
            pf3_msix_pba_offset=0x00000000,

            # signals
            # Clock and Reset Interface
            user_clk=None,
            user_reset=None,
            user_lnk_up=None,
            sys_clk=None,
            sys_clk_gt=None,
            sys_reset=None,
            phy_rdy_out=None,

            # Requester reQuest Interface
            rq_bus=None,
            pcie_rq_seq_num0=None,
            pcie_rq_seq_num_vld0=None,
            pcie_rq_seq_num1=None,
            pcie_rq_seq_num_vld1=None,
            pcie_rq_tag0=None,
            pcie_rq_tag1=None,
            pcie_rq_tag_av=None,
            pcie_rq_tag_vld0=None,
            pcie_rq_tag_vld1=None,

            # Requester Completion Interface
            rc_bus=None,

            # Completer reQuest Interface
            cq_bus=None,
            pcie_cq_np_req=None,
            pcie_cq_np_req_count=None,

            # Completer Completion Interface
            cc_bus=None,

            # Transmit Flow Control Interface
            pcie_tfc_nph_av=None,
            pcie_tfc_npd_av=None,

            # Configuration Management Interface
            cfg_mgmt_addr=None,
            cfg_mgmt_function_number=None,
            cfg_mgmt_write=None,
            cfg_mgmt_write_data=None,
            cfg_mgmt_byte_enable=None,
            cfg_mgmt_read=None,
            cfg_mgmt_read_data=None,
            cfg_mgmt_read_write_done=None,
            cfg_mgmt_debug_access=None,

            # Configuration Status Interface
            cfg_phy_link_down=None,
            cfg_phy_link_status=None,
            cfg_negotiated_width=None,
            cfg_current_speed=None,
            cfg_max_payload=None,
            cfg_max_read_req=None,
            cfg_function_status=None,
            cfg_vf_status=None,
            cfg_function_power_state=None,
            cfg_vf_power_state=None,
            cfg_link_power_state=None,
            cfg_err_cor_out=None,
            cfg_err_nonfatal_out=None,
            cfg_err_fatal_out=None,
            cfg_local_error_out=None,
            cfg_local_error_valid=None,
            cfg_rx_pm_state=None,
            cfg_tx_pm_state=None,
            cfg_ltssm_state=None,
            cfg_rcb_status=None,
            cfg_obff_enable=None,
            cfg_pl_status_change=None,
            cfg_tph_requester_enable=None,
            cfg_tph_st_mode=None,
            cfg_vf_tph_requester_enable=None,
            cfg_vf_tph_st_mode=None,

            # Configuration Received Message Interface
            cfg_msg_received=None,
            cfg_msg_received_data=None,
            cfg_msg_received_type=None,

            # Configuration Transmit Message Interface
            cfg_msg_transmit=None,
            cfg_msg_transmit_type=None,
            cfg_msg_transmit_data=None,
            cfg_msg_transmit_done=None,

            # Configuration Flow Control Interface
            cfg_fc_ph=None,
            cfg_fc_pd=None,
            cfg_fc_nph=None,
            cfg_fc_npd=None,
            cfg_fc_cplh=None,
            cfg_fc_cpld=None,
            cfg_fc_sel=None,

            # Configuration Control Interface
            cfg_hot_reset_in=None,
            cfg_hot_reset_out=None,
            cfg_config_space_enable=None,
            cfg_dsn=None,
            cfg_bus_number=None,
            cfg_ds_port_number=None,
            cfg_ds_bus_number=None,
            cfg_ds_device_number=None,
            cfg_ds_function_number=None,
            cfg_power_state_change_ack=None,
            cfg_power_state_change_interrupt=None,
            cfg_err_cor_in=None,
            cfg_err_uncor_in=None,
            cfg_flr_in_process=None,
            cfg_flr_done=None,
            cfg_vf_flr_in_process=None,
            cfg_vf_flr_func_num=None,
            cfg_vf_flr_done=None,
            cfg_pm_aspm_l1_entry_reject=None,
            cfg_pm_aspm_tx_l0s_entry_disable=None,
            cfg_req_pm_transition_l23_ready=None,
            cfg_link_training_enable=None,

            # Configuration Interrupt Controller Interface
            cfg_interrupt_int=None,
            cfg_interrupt_sent=None,
            cfg_interrupt_pending=None,
            cfg_interrupt_msi_enable=None,
            cfg_interrupt_msi_mmenable=None,
            cfg_interrupt_msi_mask_update=None,
            cfg_interrupt_msi_data=None,
            cfg_interrupt_msi_select=None,
            cfg_interrupt_msi_int=None,
            cfg_interrupt_msi_pending_status=None,
            cfg_interrupt_msi_pending_status_data_enable=None,
            cfg_interrupt_msi_pending_status_function_num=None,
            cfg_interrupt_msi_sent=None,
            cfg_interrupt_msi_fail=None,
            cfg_interrupt_msix_enable=None,
            cfg_interrupt_msix_mask=None,
            cfg_interrupt_msix_vf_enable=None,
            cfg_interrupt_msix_vf_mask=None,
            cfg_interrupt_msix_address=None,
            cfg_interrupt_msix_data=None,
            cfg_interrupt_msix_int=None,
            cfg_interrupt_msix_vec_pending=None,
            cfg_interrupt_msix_vec_pending_status=None,
            cfg_interrupt_msix_sent=None,
            cfg_interrupt_msix_fail=None,
            cfg_interrupt_msi_attr=None,
            cfg_interrupt_msi_tph_present=None,
            cfg_interrupt_msi_tph_type=None,
            cfg_interrupt_msi_tph_st_tag=None,
            cfg_interrupt_msi_function_number=None,

            # Configuration Extend Interface
            cfg_ext_read_received=None,
            cfg_ext_write_received=None,
            cfg_ext_register_number=None,
            cfg_ext_function_number=None,
            cfg_ext_write_data=None,
            cfg_ext_write_byte_enable=None,
            cfg_ext_read_data=None,
            cfg_ext_read_data_valid=None,

            *args, **kwargs):

        super().__init__(*args, **kwargs)

        self.log.info("Xilinx UltraScale+ PCIe hard IP core model")
        self.log.info("cocotbext-pcie version %s", __version__)
        self.log.info("Copyright (c) 2020 Alex Forencich")
        self.log.info("https://github.com/alexforencich/cocotbext-pcie")

        self.default_function = UltraScalePlusPcieFunction

        self.dw = None

        self.rq_seq_num = Queue()
        self.rq_tag = Queue()
        self.rc_queue = Queue()
        self.cq_queue = Queue()
        self.cq_np_queue = Queue()
        self.cq_np_req_count = 0
        self.msg_queue = Queue()

        self.rq_np_queue = Queue()
        self.rq_np_queue_dequeue = Event()
        self.rq_np_limit = 16

        # PG213 lists 128 CPLH and "32768B CPLD"
        # Tests confirm 256 CPLH and ~32KB combined header + data
        self.rx_buf_cplh_fc_limit = 256
        self.rx_buf_cpld_fc_limit = 32768 // 16
        self.rx_buf_cplh_fc_count = 0
        self.rx_buf_cpld_fc_count = 0

        self.cpld_credit_limit = self.rx_buf_cpld_fc_limit
        self.cpld_credit_count = 0
        self.cpld_credit_released = Event()

        self.active_request = [None for x in range(256)]
        self.tag_release = Event()
        self.tag_available_count = 32
        self.tag_count = 256
        self.current_tag = 0

        self.local_error = Queue()

        self.config_space_enable = False

        # configuration options
        self.pcie_generation = pcie_generation
        self.pcie_link_width = pcie_link_width
        self.user_clk_frequency = user_clk_frequency
        self.alignment = alignment
        self.cq_straddle = cq_straddle
        self.cc_straddle = cc_straddle
        self.rq_straddle = rq_straddle
        self.rc_straddle = rc_straddle
        self.rc_4tlp_straddle = rc_4tlp_straddle
        self.pf_count = pf_count
        self.max_payload_size = max_payload_size
        self.enable_client_tag = enable_client_tag
        self.enable_extended_tag = enable_extended_tag
        self.enable_parity = enable_parity
        self.enable_rx_msg_interface = enable_rx_msg_interface
        self.enable_sriov = enable_sriov
        self.enable_extended_configuration = enable_extended_configuration

        self.pf0_msi_enable = pf0_msi_enable
        self.pf0_msi_count = pf0_msi_count
        self.pf1_msi_enable = pf1_msi_enable
        self.pf1_msi_count = pf1_msi_count
        self.pf2_msi_enable = pf2_msi_enable
        self.pf2_msi_count = pf2_msi_count
        self.pf3_msi_enable = pf3_msi_enable
        self.pf3_msi_count = pf3_msi_count
        self.pf0_msix_enable = pf0_msix_enable
        self.pf0_msix_table_size = pf0_msix_table_size
        self.pf0_msix_table_bir = pf0_msix_table_bir
        self.pf0_msix_table_offset = pf0_msix_table_offset
        self.pf0_msix_pba_bir = pf0_msix_pba_bir
        self.pf0_msix_pba_offset = pf0_msix_pba_offset
        self.pf1_msix_enable = pf1_msix_enable
        self.pf1_msix_table_size = pf1_msix_table_size
        self.pf1_msix_table_bir = pf1_msix_table_bir
        self.pf1_msix_table_offset = pf1_msix_table_offset
        self.pf1_msix_pba_bir = pf1_msix_pba_bir
        self.pf1_msix_pba_offset = pf1_msix_pba_offset
        self.pf2_msix_enable = pf2_msix_enable
        self.pf2_msix_table_size = pf2_msix_table_size
        self.pf2_msix_table_bir = pf2_msix_table_bir
        self.pf2_msix_table_offset = pf2_msix_table_offset
        self.pf2_msix_pba_bir = pf2_msix_pba_bir
        self.pf2_msix_pba_offset = pf2_msix_pba_offset
        self.pf3_msix_enable = pf3_msix_enable
        self.pf3_msix_table_size = pf3_msix_table_size
        self.pf3_msix_table_bir = pf3_msix_table_bir
        self.pf3_msix_table_offset = pf3_msix_table_offset
        self.pf3_msix_pba_bir = pf3_msix_pba_bir
        self.pf3_msix_pba_offset = pf3_msix_pba_offset

        # signals

        # Clock and Reset Interface
        self.user_clk = init_signal(user_clk, 1, 0)
        self.user_reset = init_signal(user_reset, 1, 0)
        self.user_lnk_up = init_signal(user_lnk_up, 1, 0)
        self.sys_clk = init_signal(sys_clk, 1)
        self.sys_clk_gt = init_signal(sys_clk_gt, 1)
        self.sys_reset = init_signal(sys_reset, 1)
        self.phy_rdy_out = init_signal(phy_rdy_out, 1, 0)

        # Requester reQuest Interface
        self.rq_sink = None
        self.pcie_rq_seq_num0 = init_signal(pcie_rq_seq_num0, 6, 0)
        self.pcie_rq_seq_num_vld0 = init_signal(pcie_rq_seq_num_vld0, 1, 0)
        self.pcie_rq_seq_num1 = init_signal(pcie_rq_seq_num1, 6, 0)
        self.pcie_rq_seq_num_vld1 = init_signal(pcie_rq_seq_num_vld1, 1, 0)
        self.pcie_rq_tag0 = init_signal(pcie_rq_tag0, 8, 0)
        self.pcie_rq_tag1 = init_signal(pcie_rq_tag1, 8, 0)
        self.pcie_rq_tag_av = init_signal(pcie_rq_tag_av, 4, 0)
        self.pcie_rq_tag_vld0 = init_signal(pcie_rq_tag_vld0, 1, 0)
        self.pcie_rq_tag_vld1 = init_signal(pcie_rq_tag_vld1, 1, 0)

        if rq_bus is not None:
            rq_segments = 1
            if len(rq_bus.tdata) == 512 and self.rq_straddle:
                rq_segments = 2
            self.rq_sink = RqSink(rq_bus, self.user_clk, self.user_reset, segments=rq_segments)
            self.rq_sink.queue_occupancy_limit_frames = 2
            self.dw = self.rq_sink.width

        # Requester Completion Interface
        self.rc_source = None

        if rc_bus is not None:
            rc_segments = 1
            if len(rc_bus.tdata) == 512 and self.rc_4tlp_straddle:
                rc_segments = 4
            elif len(rc_bus.tdata) >= 256 and self.rc_straddle:
                rc_segments = 2
            self.rc_source = RcSource(rc_bus, self.user_clk, self.user_reset, segments=rc_segments)
            self.rc_source.queue_occupancy_limit_frames = 2
            self.dw = self.rc_source.width

        # Completer reQuest Interface
        self.cq_source = None
        self.pcie_cq_np_req = init_signal(pcie_cq_np_req, 2)
        self.pcie_cq_np_req_count = init_signal(pcie_cq_np_req_count, 6, 0)

        if cq_bus is not None:
            cq_segments = 1
            if len(cq_bus.tdata) == 512 and self.cq_straddle:
                cq_segments = 2
            self.cq_source = CqSource(cq_bus, self.user_clk, self.user_reset, segments=cq_segments)
            self.cq_source.queue_occupancy_limit_frames = 2
            self.dw = self.cq_source.width

        # Completer Completion Interface
        self.cc_sink = None

        if cc_bus is not None:
            cc_segments = 1
            if len(cc_bus.tdata) == 512 and self.cc_straddle:
                cc_segments = 2
            self.cc_sink = CcSink(cc_bus, self.user_clk, self.user_reset, segments=cc_segments)
            self.cc_sink.queue_occupancy_limit_frames = 2
            self.dw = self.cc_sink.width

        # Transmit Flow Control Interface
        self.pcie_tfc_nph_av = init_signal(pcie_tfc_nph_av, 4, 0)
        self.pcie_tfc_npd_av = init_signal(pcie_tfc_npd_av, 4, 0)

        # Configuration Management Interface
        self.cfg_mgmt_addr = init_signal(cfg_mgmt_addr, 10)
        self.cfg_mgmt_function_number = init_signal(cfg_mgmt_function_number, 8)
        self.cfg_mgmt_write = init_signal(cfg_mgmt_write, 1)
        self.cfg_mgmt_write_data = init_signal(cfg_mgmt_write_data, 32)
        self.cfg_mgmt_byte_enable = init_signal(cfg_mgmt_byte_enable, 4)
        self.cfg_mgmt_read = init_signal(cfg_mgmt_read, 1)
        self.cfg_mgmt_read_data = init_signal(cfg_mgmt_read_data, 32, 0)
        self.cfg_mgmt_read_write_done = init_signal(cfg_mgmt_read_write_done, 1, 0)
        self.cfg_mgmt_debug_access = init_signal(cfg_mgmt_debug_access, 1)

        # Configuration Status Interface
        self.cfg_phy_link_down = init_signal(cfg_phy_link_down, 1, 0)
        self.cfg_phy_link_status = init_signal(cfg_phy_link_status, 2, 0)
        self.cfg_negotiated_width = init_signal(cfg_negotiated_width, 3, 0)
        self.cfg_current_speed = init_signal(cfg_current_speed, 2, 0)
        self.cfg_max_payload = cfg_max_payload
        if self.cfg_max_payload is not None:
            assert len(self.cfg_max_payload) in {2, 3}
            self.cfg_max_payload.setimmediatevalue(0)
        self.cfg_max_read_req = init_signal(cfg_max_read_req, 3, 0)
        self.cfg_function_status = init_signal(cfg_function_status, 16, 0)
        self.cfg_vf_status = init_signal(cfg_vf_status, 504, 0)
        self.cfg_function_power_state = init_signal(cfg_function_power_state, 12, 0)
        self.cfg_vf_power_state = init_signal(cfg_vf_power_state, 756, 0)
        self.cfg_link_power_state = init_signal(cfg_link_power_state, 2, 0)
        self.cfg_err_cor_out = init_signal(cfg_err_cor_out, 1, 0)
        self.cfg_err_nonfatal_out = init_signal(cfg_err_nonfatal_out, 1, 0)
        self.cfg_err_fatal_out = init_signal(cfg_err_fatal_out, 1, 0)
        self.cfg_local_error_out = init_signal(cfg_local_error_out, 5, 0)
        self.cfg_local_error_valid = init_signal(cfg_local_error_valid, 1, 0)
        self.cfg_rx_pm_state = init_signal(cfg_rx_pm_state, 2, 0)
        self.cfg_tx_pm_state = init_signal(cfg_tx_pm_state, 2, 0)
        self.cfg_ltssm_state = init_signal(cfg_ltssm_state, 6, 0)
        self.cfg_rcb_status = init_signal(cfg_rcb_status, 4, 0)
        self.cfg_obff_enable = init_signal(cfg_obff_enable, 2, 0)
        self.cfg_pl_status_change = init_signal(cfg_pl_status_change, 1, 0)
        self.cfg_tph_requester_enable = init_signal(cfg_tph_requester_enable, 4, 0)
        self.cfg_tph_st_mode = init_signal(cfg_tph_st_mode, 12, 0)
        self.cfg_vf_tph_requester_enable = init_signal(cfg_vf_tph_requester_enable, 252, 0)
        self.cfg_vf_tph_st_mode = init_signal(cfg_vf_tph_st_mode, 756, 0)

        # Configuration Received Message Interface
        self.cfg_msg_received = init_signal(cfg_msg_received, 1, 0)
        self.cfg_msg_received_data = init_signal(cfg_msg_received_data, 8, 0)
        self.cfg_msg_received_type = init_signal(cfg_msg_received_type, 5, 0)

        # Configuration Transmit Message Interface
        self.cfg_msg_transmit = init_signal(cfg_msg_transmit, 1)
        self.cfg_msg_transmit_type = init_signal(cfg_msg_transmit_type, 3)
        self.cfg_msg_transmit_data = init_signal(cfg_msg_transmit_data, 32)
        self.cfg_msg_transmit_done = init_signal(cfg_msg_transmit_done, 1, 0)

        # Configuration Flow Control Interface
        self.cfg_fc_ph = init_signal(cfg_fc_ph, 8, 0)
        self.cfg_fc_pd = init_signal(cfg_fc_pd, 12, 0)
        self.cfg_fc_nph = init_signal(cfg_fc_nph, 8, 0)
        self.cfg_fc_npd = init_signal(cfg_fc_npd, 12, 0)
        self.cfg_fc_cplh = init_signal(cfg_fc_cplh, 8, 0)
        self.cfg_fc_cpld = init_signal(cfg_fc_cpld, 12, 0)
        if isinstance(cfg_fc_sel, int):
            assert 0 <= cfg_fc_sel < 8
            self.cfg_fc_sel = cfg_fc_sel
        else:
            self.cfg_fc_sel = init_signal(cfg_fc_sel, 3)

        # Configuration Control Interface
        self.cfg_hot_reset_in = init_signal(cfg_hot_reset_in, 1)
        self.cfg_hot_reset_out = init_signal(cfg_hot_reset_out, 1, 0)
        self.cfg_config_space_enable = init_signal(cfg_config_space_enable, 1)
        self.cfg_dsn = init_signal(cfg_dsn, 64)
        self.cfg_bus_number = init_signal(cfg_bus_number, 8, 0)
        self.cfg_ds_port_number = init_signal(cfg_ds_port_number, 8)
        self.cfg_ds_bus_number = init_signal(cfg_ds_bus_number, 8)
        self.cfg_ds_device_number = init_signal(cfg_ds_device_number, 5)
        self.cfg_ds_function_number = init_signal(cfg_ds_function_number, 3)
        self.cfg_power_state_change_ack = init_signal(cfg_power_state_change_ack, 1)
        self.cfg_power_state_change_interrupt = init_signal(cfg_power_state_change_interrupt, 1, 0)
        self.cfg_err_cor_in = init_signal(cfg_err_cor_in, 1)
        self.cfg_err_uncor_in = init_signal(cfg_err_uncor_in, 1)
        self.cfg_flr_in_process = init_signal(cfg_flr_in_process, 4)
        self.cfg_flr_done = init_signal(cfg_flr_done, 4)
        self.cfg_vf_flr_in_process = init_signal(cfg_vf_flr_in_process, 252)
        self.cfg_vf_flr_func_num = init_signal(cfg_vf_flr_func_num, 8)
        self.cfg_vf_flr_done = init_signal(cfg_vf_flr_done, 1)
        self.cfg_pm_aspm_l1_entry_reject = init_signal(cfg_pm_aspm_l1_entry_reject, 1)
        self.cfg_pm_aspm_tx_l0s_entry_disable = init_signal(cfg_pm_aspm_tx_l0s_entry_disable, 1)
        self.cfg_req_pm_transition_l23_ready = init_signal(cfg_req_pm_transition_l23_ready, 1)
        self.cfg_link_training_enable = init_signal(cfg_link_training_enable, 1)

        # Configuration Interrupt Controller Interface
        self.cfg_interrupt_int = init_signal(cfg_interrupt_int, 4)
        self.cfg_interrupt_sent = init_signal(cfg_interrupt_sent, 1, 0)
        self.cfg_interrupt_pending = init_signal(cfg_interrupt_pending, 4)
        self.cfg_interrupt_msi_enable = init_signal(cfg_interrupt_msi_enable, 4, 0)
        self.cfg_interrupt_msi_mmenable = init_signal(cfg_interrupt_msi_mmenable, 12, 0)
        self.cfg_interrupt_msi_mask_update = init_signal(cfg_interrupt_msi_mask_update, 1, 0)
        self.cfg_interrupt_msi_data = init_signal(cfg_interrupt_msi_data, 32, 0)
        self.cfg_interrupt_msi_select = init_signal(cfg_interrupt_msi_select, 2)
        self.cfg_interrupt_msi_int = init_signal(cfg_interrupt_msi_int, 32)
        self.cfg_interrupt_msi_pending_status = init_signal(cfg_interrupt_msi_pending_status, 32)
        self.cfg_interrupt_msi_pending_status_data_enable = init_signal(cfg_interrupt_msi_pending_status_data_enable, 1)
        self.cfg_interrupt_msi_pending_status_function_num = init_signal(cfg_interrupt_msi_pending_status_function_num, 2)
        self.cfg_interrupt_msi_fail = init_signal(cfg_interrupt_msi_fail, 1, 0)
        self.cfg_interrupt_msi_sent = init_signal(cfg_interrupt_msi_sent, 1, 0)
        self.cfg_interrupt_msix_enable = init_signal(cfg_interrupt_msix_enable, 4, 0)
        self.cfg_interrupt_msix_mask = init_signal(cfg_interrupt_msix_mask, 4)
        self.cfg_interrupt_msix_vf_enable = init_signal(cfg_interrupt_msix_vf_enable, 252, 0)
        self.cfg_interrupt_msix_vf_mask = init_signal(cfg_interrupt_msix_vf_mask, 252)
        self.cfg_interrupt_msix_address = init_signal(cfg_interrupt_msix_address, 64)
        self.cfg_interrupt_msix_data = init_signal(cfg_interrupt_msix_data, 32)
        self.cfg_interrupt_msix_int = init_signal(cfg_interrupt_msix_int, 1)
        self.cfg_interrupt_msix_vec_pending = init_signal(cfg_interrupt_msix_vec_pending, 2)
        self.cfg_interrupt_msix_vec_pending_status = init_signal(cfg_interrupt_msix_vec_pending_status, 1)
        self.cfg_interrupt_msix_sent = init_signal(cfg_interrupt_msix_sent, 1, 0)
        self.cfg_interrupt_msix_fail = init_signal(cfg_interrupt_msix_fail, 1, 0)
        self.cfg_interrupt_msi_attr = init_signal(cfg_interrupt_msi_attr, 3)
        self.cfg_interrupt_msi_tph_present = init_signal(cfg_interrupt_msi_tph_present, 1)
        self.cfg_interrupt_msi_tph_type = init_signal(cfg_interrupt_msi_tph_type, 2)
        self.cfg_interrupt_msi_tph_st_tag = init_signal(cfg_interrupt_msi_tph_st_tag, 8)
        self.cfg_interrupt_msi_function_number = init_signal(cfg_interrupt_msi_function_number, 8)

        # Configuration Extend Interface
        self.cfg_ext_read_received = init_signal(cfg_ext_read_received, 1, 0)
        self.cfg_ext_write_received = init_signal(cfg_ext_write_received, 1, 0)
        self.cfg_ext_register_number = init_signal(cfg_ext_register_number, 10, 0)
        self.cfg_ext_function_number = init_signal(cfg_ext_function_number, 8, 0)
        self.cfg_ext_write_data = init_signal(cfg_ext_write_data, 32, 0)
        self.cfg_ext_write_byte_enable = init_signal(cfg_ext_write_byte_enable, 4, 0)
        self.cfg_ext_read_data = init_signal(cfg_ext_read_data, 32)
        self.cfg_ext_read_data_valid = init_signal(cfg_ext_read_data_valid, 1)

        # validate parameters
        assert self.dw in {64, 128, 256, 512}

        # rescale clock frequency
        if self.user_clk_frequency is not None and self.user_clk_frequency < 1e6:
            self.user_clk_frequency *= 1e6

        if not self.pcie_generation or not self.pcie_link_width or not self.user_clk_frequency:
            self.log.info("Incomplete configuration specified, attempting to select reasonable options")
            # guess some reasonable values for unspecified parameters
            for config in reversed(valid_configs):
                # find configuration matching specified parameters
                if self.pcie_generation is not None and self.pcie_generation != config[0]:
                    continue
                if self.pcie_link_width is not None and self.pcie_link_width != config[1]:
                    continue
                if self.dw != config[2]:
                    continue
                if self.user_clk_frequency is not None and self.user_clk_frequency != config[3]:
                    continue

                # set the unspecified parameters
                if self.pcie_generation is None:
                    self.log.info("Setting PCIe speed to gen %d", config[0])
                    self.pcie_generation = config[0]
                if self.pcie_link_width is None:
                    self.log.info("Setting PCIe link width to x%d", config[1])
                    self.pcie_link_width = config[1]
                if self.user_clk_frequency is None:
                    self.log.info("Setting user clock frequency to %d MHz", config[3]/1e6)
                    self.user_clk_frequency = config[3]
                break

        self.log.info("Xilinx UltraScale+ PCIe hard IP core configuration:")
        self.log.info("  PCIe speed: gen %d", self.pcie_generation)
        self.log.info("  PCIe link width: x%d", self.pcie_link_width)
        self.log.info("  User clock frequency: %d MHz", self.user_clk_frequency/1e6)
        self.log.info("  Alignment: %s", self.alignment)
        self.log.info("  Enable CQ straddling: %s", self.cq_straddle)
        self.log.info("  Enable CC straddling: %s", self.cc_straddle)
        self.log.info("  Enable RQ straddling: %s", self.rq_straddle)
        self.log.info("  Enable RC straddling: %s", self.rc_straddle)
        self.log.info("  Enable RC 4 TLP straddling: %s", self.rc_4tlp_straddle)
        self.log.info("  PF count: %d", self.pf_count)
        self.log.info("  Max payload size: %d", self.max_payload_size)
        self.log.info("  Enable client tag: %s", self.enable_client_tag)
        self.log.info("  Enable extended tag: %s", self.enable_extended_tag)
        self.log.info("  Enable parity: %s", self.enable_parity)
        self.log.info("  Enable RX message interface: %s", self.enable_rx_msg_interface)
        self.log.info("  Enable SR-IOV: %s", self.enable_sriov)
        self.log.info("  Enable extended configuration: %s", self.enable_extended_configuration)
        self.log.info("  Enable PF0 MSI: %s", self.pf0_msi_enable)
        self.log.info("  PF0 MSI vector count: %d", self.pf0_msi_count)
        self.log.info("  Enable PF1 MSI: %s", self.pf1_msi_enable)
        self.log.info("  PF1 MSI vector count: %d", self.pf1_msi_count)
        self.log.info("  Enable PF2 MSI: %s", self.pf2_msi_enable)
        self.log.info("  PF2 MSI vector count: %d", self.pf2_msi_count)
        self.log.info("  Enable PF3 MSI: %s", self.pf3_msi_enable)
        self.log.info("  PF3 MSI vector count: %d", self.pf3_msi_count)
        self.log.info("  Enable PF0 MSIX: %s", self.pf0_msix_enable)
        self.log.info("  PF0 MSIX table size: %d", self.pf0_msix_table_size)
        self.log.info("  PF0 MSIX table BIR: %d", self.pf0_msix_table_bir)
        self.log.info("  PF0 MSIX table offset: 0x%08x", self.pf0_msix_table_offset)
        self.log.info("  PF0 MSIX PBA BIR: %d", self.pf0_msix_pba_bir)
        self.log.info("  PF0 MSIX PBA offset: 0x%08x", self.pf0_msix_pba_offset)
        self.log.info("  Enable PF1 MSIX: %s", self.pf1_msix_enable)
        self.log.info("  PF1 MSIX table size: %d", self.pf1_msix_table_size)
        self.log.info("  PF1 MSIX table BIR: %d", self.pf1_msix_table_bir)
        self.log.info("  PF1 MSIX table offset: 0x%08x", self.pf1_msix_table_offset)
        self.log.info("  PF1 MSIX PBA BIR: %d", self.pf1_msix_pba_bir)
        self.log.info("  PF1 MSIX PBA offset: 0x%08x", self.pf1_msix_pba_offset)
        self.log.info("  Enable PF2 MSIX: %s", self.pf2_msix_enable)
        self.log.info("  PF2 MSIX table size: %d", self.pf2_msix_table_size)
        self.log.info("  PF2 MSIX table BIR: %d", self.pf2_msix_table_bir)
        self.log.info("  PF2 MSIX table offset: 0x%08x", self.pf2_msix_table_offset)
        self.log.info("  PF2 MSIX PBA BIR: %d", self.pf2_msix_pba_bir)
        self.log.info("  PF2 MSIX PBA offset: 0x%08x", self.pf2_msix_pba_offset)
        self.log.info("  Enable PF3 MSIX: %s", self.pf3_msix_enable)
        self.log.info("  PF3 MSIX table size: %d", self.pf3_msix_table_size)
        self.log.info("  PF3 MSIX table BIR: %d", self.pf3_msix_table_bir)
        self.log.info("  PF3 MSIX table offset: 0x%08x", self.pf3_msix_table_offset)
        self.log.info("  PF3 MSIX PBA BIR: %d", self.pf3_msix_pba_bir)
        self.log.info("  PF3 MSIX PBA offset: 0x%08x", self.pf3_msix_pba_offset)

        assert self.pcie_generation in {1, 2, 3, 4}
        assert self.pcie_link_width in {1, 2, 4, 8, 16}
        assert self.user_clk_frequency in {62.5e6, 125e6, 250e6}
        assert self.alignment in {"address", "dword"}

        if self.dw < 256 or self.alignment != "dword":
            assert not self.rc_straddle, "RC straddling only supported with 256- or 512-bit, DWORD-aligned interface"
            if self.dw != 512:
                assert not self.rq_straddle, "RQ straddling only supported with 512-bit, DWORD-aligned interface"
                assert not self.cq_straddle, "CQ straddling only supported with 512-bit, DWORD-aligned interface"
                assert not self.cc_straddle, "CC straddling only supported with 512-bit, DWORD-aligned interface"
                assert not self.rc_4tlp_straddle, "RC 4 TLP straddling only supported with 512-bit, DWORD-aligned interface"

        # TODO change this when support added
        assert self.alignment == 'dword', "only dword alignment currently supported"

        # check for valid configuration
        config_valid = False
        for config in valid_configs:
            if self.pcie_generation != config[0]:
                continue
            if self.pcie_link_width != config[1]:
                continue
            if self.dw != config[2]:
                continue
            if self.user_clk_frequency != config[3]:
                continue

            config_valid = True
            break

        assert config_valid, "link speed/link width/clock speed/interface width setting combination not valid"

        # configure port
        self.upstream_port.max_link_speed = self.pcie_generation
        self.upstream_port.max_link_width = self.pcie_link_width

        # configure functions

        self.make_function()

        if self.pf0_msi_enable:
            self.functions[0].msi_cap.msi_multiple_message_capable = (self.pf0_msi_count-1).bit_length()
        else:
            self.functions[0].deregister_capability(self.functions[0].msi_cap)

        if self.pf0_msix_enable:
            self.functions[0].msix_cap.msix_table_size = self.pf0_msix_table_size
            self.functions[0].msix_cap.msix_table_bar_indicator_register = self.pf0_msix_table_bir
            self.functions[0].msix_cap.msix_table_offset = self.pf0_msix_table_offset
            self.functions[0].msix_cap.msix_pba_bar_indicator_register = self.pf0_msix_pba_bir
            self.functions[0].msix_cap.msix_pba_offset = self.pf0_msix_pba_offset
        else:
            self.functions[0].deregister_capability(self.functions[0].msix_cap)

        if self.pf_count > 1:
            self.make_function()

            if self.pf1_msi_enable:
                self.functions[1].msi_cap.msi_multiple_message_capable = (self.pf1_msi_count-1).bit_length()
            else:
                self.functions[1].deregister_capability(self.functions[1].msi_cap)

            if self.pf1_msix_enable:
                self.functions[1].msix_cap.msix_table_size = self.pf1_msix_table_size
                self.functions[1].msix_cap.msix_table_bar_indicator_register = self.pf1_msix_table_bir
                self.functions[1].msix_cap.msix_table_offset = self.pf1_msix_table_offset
                self.functions[1].msix_cap.msix_pba_bar_indicator_register = self.pf1_msix_pba_bir
                self.functions[1].msix_cap.msix_pba_offset = self.pf1_msix_pba_offset
            else:
                self.functions[1].deregister_capability(self.functions[1].msix_cap)

        if self.pf_count > 2:
            self.make_function()

            if self.pf2_msi_enable:
                self.functions[2].msi_cap.msi_multiple_message_capable = (self.pf2_msi_count-2).bit_length()
            else:
                self.functions[2].deregister_capability(self.functions[2].msi_cap)

            if self.pf2_msix_enable:
                self.functions[2].msix_cap.msix_table_size = self.pf2_msix_table_size
                self.functions[2].msix_cap.msix_table_bar_indicator_register = self.pf2_msix_table_bir
                self.functions[2].msix_cap.msix_table_offset = self.pf2_msix_table_offset
                self.functions[2].msix_cap.msix_pba_bar_indicator_register = self.pf2_msix_pba_bir
                self.functions[2].msix_cap.msix_pba_offset = self.pf2_msix_pba_offset
            else:
                self.functions[2].deregister_capability(self.functions[2].msix_cap)

        if self.pf_count > 3:
            self.make_function()

            if self.pf3_msi_enable:
                self.functions[3].msi_cap.msi_multiple_message_capable = (self.pf3_msi_count-3).bit_length()
            else:
                self.functions[3].deregister_capability(self.functions[3].msi_cap)

            if self.pf3_msix_enable:
                self.functions[3].msix_cap.msix_table_size = self.pf3_msix_table_size
                self.functions[3].msix_cap.msix_table_bar_indicator_register = self.pf3_msix_table_bir
                self.functions[3].msix_cap.msix_table_offset = self.pf3_msix_table_offset
                self.functions[3].msix_cap.msix_pba_bar_indicator_register = self.pf3_msix_pba_bir
                self.functions[3].msix_cap.msix_pba_offset = self.pf3_msix_pba_offset
            else:
                self.functions[3].deregister_capability(self.functions[3].msix_cap)

        for f in self.functions:
            f.pcie_cap.max_payload_size_supported = (self.max_payload_size//128-1).bit_length()
            f.pcie_cap.extended_tag_supported = self.enable_extended_tag

        if self.cfg_config_space_enable is None:
            self.config_space_enable = True

        # fork coroutines

        if self.user_clk is not None:
            cocotb.start_soon(Clock(self.user_clk, int(1e9/self.user_clk_frequency), units="ns").start())

        if self.rq_sink:
            cocotb.start_soon(self._run_rq_logic())
            cocotb.start_soon(self._run_rq_np_queue_logic())
            cocotb.start_soon(self._run_rq_seq_num_logic())
            if not self.enable_client_tag:
                cocotb.start_soon(self._run_rq_tag_logic())
        if self.rc_source:
            cocotb.start_soon(self._run_rc_logic())
        if self.cq_source:
            cocotb.start_soon(self._run_cq_logic())
        if self.cc_sink:
            cocotb.start_soon(self._run_cc_logic())
        if self.cfg_mgmt_addr is not None:
            cocotb.start_soon(self._run_cfg_mgmt_logic())
        cocotb.start_soon(self._run_cfg_status_logic())
        if self.cfg_fc_sel is not None:
            cocotb.start_soon(self._run_cfg_fc_logic())
        cocotb.start_soon(self._run_cfg_ctrl_logic())
        cocotb.start_soon(self._run_cfg_int_logic())

        cocotb.start_soon(self._run_reset())

    def get_free_tag(self):
        tag_count = min(256 if self.functions[0].pcie_cap.extended_tag_field_enable else 32, self.tag_count)

        tag = self.current_tag
        for k in range(tag_count):
            tag = (tag + 1) % tag_count
            if self.active_request[tag] is None:
                self.current_tag = tag
                return tag

        return None

    def get_available_tag_count(self):
        if self.functions[0].pcie_cap.extended_tag_field_enable:
            return self.active_request.count(None)
        else:
            return self.active_request[0:32].count(None)

    async def upstream_recv(self, tlp):
        self.log.debug("Got downstream TLP: %r", tlp)

        if tlp.fmt_type in {TlpType.CFG_READ_0, TlpType.CFG_WRITE_0}:
            # config type 0

            if not self.config_space_enable:
                self.log.warning("Configuration space disabled")

                tlp.release_fc()

                cpl = Tlp.create_crs_completion_for_tlp(tlp, PcieId(self.bus_num, 0, 0))
                self.log.debug("CRS Completion: %r", cpl)
                await self.upstream_send(cpl)
                return
            else:
                # capture address information
                self.bus_num = tlp.completer_id.bus

                # pass TLP to function
                for f in self.functions:
                    if f.pcie_id == tlp.completer_id:
                        await f.upstream_recv(tlp)
                        return

                tlp.release_fc()

                self.log.warning("Function not found: failed to route config type 0 TLP: %r", tlp)

        elif tlp.fmt_type in {TlpType.CFG_READ_1, TlpType.CFG_WRITE_1}:
            # config type 1

            tlp.release_fc()

            self.log.warning("Malformed TLP: endpoint received config type 1 TLP: %r", tlp)
        elif tlp.fmt_type in {TlpType.CPL, TlpType.CPL_DATA, TlpType.CPL_LOCKED, TlpType.CPL_LOCKED_DATA}:
            # Completion

            for f in self.functions:
                if f.pcie_id == tlp.requester_id:

                    tlp.release_fc()

                    tlp = Tlp_us(tlp)

                    tlp.error_code = ErrorCode.NORMAL_TERMINATION

                    if tlp.ep:
                        # poisoned
                        self.log.warning("Poisoned TLP: %r", tlp)
                        tlp.error_code = ErrorCode.POISONED

                    req = self.active_request[tlp.tag]

                    if not req:
                        # tag not active
                        self.log.warning("Invalid tag: %r", tlp)
                        tlp.error_code = ErrorCode.INVALID_TAG
                    elif tlp.requester_id != req.requester_id or tlp.attr != req.attr or tlp.tc != req.tc:
                        # requester ID, ATTR, or TC field mismatch
                        self.log.warning("Mismatched fields: %r", tlp)
                        tlp.error_code = ErrorCode.MISMATCH
                    elif tlp.status != CplStatus.SC:
                        # bad status
                        self.log.warning("Bad status: %r", tlp)
                        tlp.error_code = ErrorCode.BAD_STATUS
                        tlp.request_completed = True
                        self.active_request[tlp.tag] = None
                    elif req.fmt_type in {TlpType.MEM_READ, TlpType.MEM_READ_64}:
                        # completion for memory read request

                        # reconstruct lower address MSBs
                        lower_address = req.address + req.get_first_be_offset() + req.get_be_byte_count() - tlp.byte_count

                        if tlp.lower_address != lower_address & 0x7f:
                            self.log.warning("Lower address mismatch: %r", tlp)
                            tlp.error_code = ErrorCode.INVALID_ADDRESS
                        else:
                            tlp.lower_address = lower_address & 0xfff

                        # mark request completed
                        if tlp.byte_count <= tlp.length*4 - (tlp.lower_address & 0x3):
                            tlp.request_completed = True
                            self.active_request[tlp.tag] = None

                        # completion for read request has SC status but no data
                        if tlp.fmt_type in {TlpType.CPL, TlpType.CPL_LOCKED}:
                            tlp.error_code = ErrorCode.INVALID_LENGTH
                            tlp.request_completed = True
                            self.active_request[tlp.tag] = None

                    else:
                        # completion for other request
                        tlp.request_completed = True
                        self.active_request[tlp.tag] = None

                    # TODO track individual operations
                    self.cpld_credit_count = max(self.cpld_credit_count-tlp.get_data_credits(), 0)
                    self.cpld_credit_released.set()

                    # check and track buffer occupancy
                    data_fc = tlp.get_data_credits()

                    if self.rx_buf_cplh_fc_count+1 <= self.rx_buf_cplh_fc_limit and self.rx_buf_cpld_fc_count+data_fc+1 <= self.rx_buf_cpld_fc_limit:
                        self.rx_buf_cplh_fc_count += 1
                        self.rx_buf_cpld_fc_count += data_fc+1
                        self.rc_queue.put_nowait(tlp)
                    else:
                        self.log.warning("No space in RX completion buffer, dropping TLP: CPLH %d (limit %d), CPLD %d (limit %d)",
                            self.rx_buf_cplh_fc_count, self.rx_buf_cplh_fc_limit, self.rx_buf_cpld_fc_count, self.rx_buf_cpld_fc_limit)
                        self.local_error.put_nowait(LocalError.RX_CPL_BUF_OVF_ERR)

                    self.tag_available_count = self.get_available_tag_count()

                    return

            tlp.release_fc()

            self.log.warning("Unexpected completion: failed to route completion to function: %r", tlp)
            return  # no UR response for completion
        elif tlp.fmt_type in {TlpType.IO_READ, TlpType.IO_WRITE}:
            # IO read/write

            for f in self.functions:
                bar = f.match_bar(tlp.address, True)
                if bar:

                    tlp.release_fc()

                    tlp = Tlp_us(tlp)
                    tlp.bar_id = bar[0]
                    tlp.bar_aperture = (~self.functions[0].bar_mask[bar[0]] & 0xffffffff).bit_length()
                    tlp.completer_id = tlp.completer_id._replace(bus=self.bus_num)
                    self.cq_queue.put_nowait(tlp)

                    return

            tlp.release_fc()

            self.log.warning("No BAR match: IO request did not match any BARs: %r", tlp)
        elif tlp.fmt_type in {TlpType.MEM_READ, TlpType.MEM_READ_64, TlpType.MEM_WRITE, TlpType.MEM_WRITE_64}:
            # Memory read/write

            for f in self.functions:
                bar = f.match_bar(tlp.address)
                if bar:

                    tlp.release_fc()

                    tlp = Tlp_us(tlp)
                    tlp.bar_id = bar[0]
                    if self.functions[0].bar[bar[0]] & 4:
                        tlp.bar_aperture = (~(self.functions[0].bar_mask[bar[0]] |
                            (self.functions[0].bar_mask[bar[0]+1] << 32)) & 0xffffffffffffffff).bit_length()
                    else:
                        tlp.bar_aperture = (~self.functions[0].bar_mask[bar[0]] & 0xffffffff).bit_length()
                    tlp.completer_id = f.pcie_id
                    self.cq_queue.put_nowait(tlp)

                    return

            tlp.release_fc()

            if tlp.fmt_type in {TlpType.MEM_WRITE, TlpType.MEM_WRITE_64}:
                self.log.warning("No BAR match: memory write request did not match any BARs: %r", tlp)
                return  # no UR response for write request
            else:
                self.log.warning("No BAR match: memory read request did not match any BARs: %r", tlp)
        else:
            raise Exception("TODO")

        # Unsupported request
        cpl = Tlp.create_ur_completion_for_tlp(tlp, PcieId(self.bus_num, 0, 0))
        self.log.debug("UR Completion: %r", cpl)
        await self.upstream_send(cpl)

    async def _run_reset(self):
        clock_edge_event = RisingEdge(self.user_clk)

        while True:
            await clock_edge_event
            await clock_edge_event

            if self.user_reset is not None:
                self.user_reset.value = 1

            if self.sys_reset is not None:
                if not self.sys_reset.value:
                    await RisingEdge(self.sys_reset)
                await First(FallingEdge(self.sys_reset), Timer(100, 'ns'))
                await First(FallingEdge(self.sys_reset), RisingEdge(self.user_clk))
                if not self.sys_reset.value:
                    continue
            else:
                await Timer(100, 'ns')
                await RisingEdge(self.user_clk)

            if self.user_reset is not None:
                self.user_reset.value = 0

            if self.sys_reset is not None:
                await FallingEdge(self.sys_reset)
            else:
                return

    async def _run_cq_logic(self):
        clock_edge_event = RisingEdge(self.user_clk)

        while True:
            await clock_edge_event

            # increment cq_np_req_count and saturate at 32
            if self.pcie_cq_np_req is None or self.pcie_cq_np_req.value:
                self.cq_np_req_count = min(self.cq_np_req_count+1, 32)

            # handle completer requests
            # send any queued non-posted requests first
            while not self.cq_np_queue.empty() and self.cq_np_req_count > 0:
                tlp = self.cq_np_queue.get_nowait()
                self.cq_np_req_count -= 1
                await self.cq_source.send(tlp.pack_us_cq())

            # handle new requests
            while not self.cq_queue.empty():
                tlp = self.cq_queue.get_nowait()

                if tlp.fmt_type in {TlpType.IO_READ, TlpType.IO_WRITE, TlpType.MEM_READ, TlpType.MEM_READ_64}:
                    # non-posted request
                    if self.cq_np_req_count > 0:
                        # have credit, can forward
                        self.cq_np_req_count -= 1
                        await self.cq_source.send(tlp.pack_us_cq())
                    else:
                        # no credits, put it in the queue
                        self.cq_np_queue.put_nowait(tlp)
                else:
                    # posted request
                    await self.cq_source.send(tlp.pack_us_cq())

            # output new cq_np_req_count
            if self.pcie_cq_np_req_count is not None:
                self.pcie_cq_np_req_count.value = self.cq_np_req_count

    async def _run_cc_logic(self):
        while True:
            tlp = Tlp_us.unpack_us_cc(await self.cc_sink.recv(), self.enable_parity)

            if not tlp.completer_id_enable:
                tlp.completer_id = tlp.completer_id._replace(bus=self.bus_num)

            if not tlp.discontinue:
                await self.send(Tlp(tlp))

    async def _run_rq_logic(self):
        while True:
            tlp = Tlp_us.unpack_us_rq(await self.rq_sink.recv(), self.enable_parity)

            if tlp.discontinue:
                self.log.warning("Discontinue bit set, discarding TLP: %r", tlp)
                continue

            if not tlp.requester_id_enable:
                tlp.requester_id = tlp.requester_id._replace(bus=self.bus_num)

            if tlp.is_nonposted():
                # non-posted request

                if self.rq_np_queue.empty() and self.cpld_credit_count+tlp.get_data_credits() <= self.cpld_credit_limit and (self.enable_client_tag or self.tag_available_count > 0):
                    # queue empty and have data credits; skip queue and send immediately to preserve ordering

                    if not self.functions[tlp.requester_id.function].bus_master_enable:
                        self.log.warning("Bus mastering disabled, dropping TLP: %r", tlp)
                        # TODO: internal response
                        continue

                    if self.functions[0].pcie_cap.extended_tag_field_enable:
                        assert tlp.tag < 256, "tag out of range (extended tags enabled)"
                    else:
                        assert tlp.tag < 32, "tag out of range (extended tags disabled)"

                    if not self.enable_client_tag:
                        tlp.tag = self.get_free_tag()
                        self.rq_tag.put_nowait(tlp.tag)

                    assert not self.active_request[tlp.tag], "active tag reused"
                    self.active_request[tlp.tag] = tlp
                    self.tag_available_count = self.get_available_tag_count()

                    self.cpld_credit_count += tlp.get_data_credits()

                    await self.send(Tlp(tlp))
                    self.rq_seq_num.put_nowait(tlp.seq_num)

                else:
                    # queue not empty or insufficient data credits; enqueue

                    # block to wait for space in queue
                    while self.rq_np_queue.qsize() >= self.rq_np_limit:
                        self.rq_np_queue_dequeue.clear()
                        await self.rq_np_queue_dequeue.wait()

                    self.rq_np_queue.put_nowait(tlp)
            else:
                # posted request; send immediately

                if not self.functions[tlp.requester_id.function].bus_master_enable:
                    self.log.warning("Bus mastering disabled, dropping TLP: %r", tlp)
                    # TODO: internal response
                    continue

                await self.send(Tlp(tlp))
                self.rq_seq_num.put_nowait(tlp.seq_num)

    async def _run_rq_np_queue_logic(self):
        while True:
            tlp = await self.rq_np_queue.get()
            self.rq_np_queue_dequeue.set()

            while True:
                # wait for data credits
                if self.cpld_credit_count+tlp.get_data_credits() > self.cpld_credit_limit:
                    self.cpld_credit_released.clear()
                    await self.cpld_credit_released.wait()
                    continue

                # wait for tags
                if not self.enable_client_tag and self.tag_available_count <= 0:
                    self.tag_release.clear()
                    await self.tag_release.wait()
                    continue

                break

            if not self.functions[tlp.requester_id.function].bus_master_enable:
                self.log.warning("Bus mastering disabled, dropping TLP: %r", tlp)
                # TODO: internal response
                continue

            self.cpld_credit_count += tlp.get_data_credits()

            if not self.enable_client_tag:
                tlp.tag = self.get_free_tag()
                self.rq_tag.put_nowait(tlp.tag)

            assert not self.active_request[tlp.tag], "active tag reused"
            self.active_request[tlp.tag] = tlp
            self.tag_available_count = self.get_available_tag_count()

            await self.send(Tlp(tlp))
            self.rq_seq_num.put_nowait(tlp.seq_num)

    async def _run_rq_seq_num_logic(self):
        clock_edge_event = RisingEdge(self.user_clk)

        while True:
            await clock_edge_event

            if self.pcie_rq_seq_num0 is not None:
                self.pcie_rq_seq_num_vld0.value = 0
                if not self.rq_seq_num.empty():
                    self.pcie_rq_seq_num0.value = self.rq_seq_num.get_nowait()
                    self.pcie_rq_seq_num_vld0.value = 1
            elif not self.rq_seq_num.empty():
                self.rq_seq_num.get_nowait()

            if self.dw == 512:

                if self.pcie_rq_seq_num1 is not None:
                    self.pcie_rq_seq_num_vld1.value = 0
                    if not self.rq_seq_num.empty():
                        self.pcie_rq_seq_num1.value = self.rq_seq_num.get_nowait()
                        self.pcie_rq_seq_num_vld1.value = 1
                elif not self.rq_seq_num.empty():
                    self.rq_seq_num.get_nowait()

    async def _run_rq_tag_logic(self):
        clock_edge_event = RisingEdge(self.user_clk)

        while True:
            await clock_edge_event

            if self.pcie_rq_tag_av is not None:
                self.pcie_rq_tag_av.value = min(0xf, self.tag_available_count)

            if self.pcie_rq_tag0 is not None:
                self.pcie_rq_tag_vld0.value = 0
                if not self.rq_tag.empty():
                    self.pcie_rq_tag0.value = self.rq_tag.get_nowait()
                    self.pcie_rq_tag_vld0.value = 1
            elif not self.rq_tag.empty():
                self.rq_tag.get_nowait()

            if self.dw == 512:

                if self.pcie_rq_tag1 is not None:
                    self.pcie_rq_tag_vld1.value = 0
                    if not self.rq_tag.empty():
                        self.pcie_rq_tag1.value = self.rq_tag.get_nowait()
                        self.pcie_rq_tag_vld1.value = 1
                elif not self.rq_tag.empty():
                    self.rq_tag.get_nowait()

    async def _run_rc_logic(self):
        while True:
            tlp = await self.rc_queue.get()
            await self.rc_source.send(tlp.pack_us_rc())

            self.rx_buf_cplh_fc_count = max(self.rx_buf_cplh_fc_count-1, 0)
            self.rx_buf_cpld_fc_count = max(self.rx_buf_cpld_fc_count-(tlp.get_data_credits()+1), 0)

    async def _run_tx_fc_logic(self):
        clock_edge_event = RisingEdge(self.user_clk)

        while True:
            await clock_edge_event

            # transmit flow control
            # TODO
            if self.pcie_tfc_nph_av is not None:
                self.pcie_tfc_nph_av.value = 0xf
            if self.pcie_tfc_npd_av is not None:
                self.pcie_tfc_npd_av.value = 0xf

    async def _run_cfg_mgmt_logic(self):
        clock_edge_event = RisingEdge(self.user_clk)

        while True:
            await clock_edge_event

            # configuration management
            function = self.cfg_mgmt_function_number.value.integer
            reg_num = self.cfg_mgmt_addr.value.integer
            write_data = self.cfg_mgmt_write_data.value.integer
            byte_enable = self.cfg_mgmt_byte_enable.value.integer
            cfg_mgmt_read = self.cfg_mgmt_read.value.integer
            cfg_mgmt_write = self.cfg_mgmt_write.value.integer

            if self.cfg_mgmt_read_write_done.value:
                self.cfg_mgmt_read_write_done.value = 0
            elif cfg_mgmt_read or cfg_mgmt_write:
                for k in range(3):
                    await RisingEdge(self.user_clk)
                if cfg_mgmt_read:
                    self.cfg_mgmt_read_data.value = await self.functions[function].read_config_register(reg_num)
                else:
                    await self.functions[function].write_config_register(reg_num, write_data, byte_enable)
                self.cfg_mgmt_read_write_done.value = 1
            # cfg_mgmt_debug_access

    async def _run_cfg_status_logic(self):
        clock_edge_event = RisingEdge(self.user_clk)

        while True:
            await clock_edge_event

            # configuration status
            if self.sys_reset is not None and not self.sys_reset.value:
                if self.cfg_phy_link_down is not None:
                    self.cfg_phy_link_down.value = 1
                if self.user_lnk_up is not None:
                    self.user_lnk_up.value = 0
            else:
                if self.cfg_phy_link_down is not None:
                    self.cfg_phy_link_down.value = 0  # TODO
                if self.user_lnk_up is not None:
                    self.user_lnk_up.value = 1  # TODO

            # cfg_phy_link_status
            if self.cfg_negotiated_width is not None:
                self.cfg_negotiated_width.value = min(max((self.functions[0].pcie_cap.negotiated_link_width).bit_length()-1, 0), 4)
            if self.cfg_current_speed is not None:
                self.cfg_current_speed.value = min(max(self.functions[0].pcie_cap.current_link_speed-1, 0), 3)
            if self.cfg_max_payload is not None:
                self.cfg_max_payload.value = self.functions[0].pcie_cap.max_payload_size & 3
            if self.cfg_max_read_req is not None:
                self.cfg_max_read_req.value = self.functions[0].pcie_cap.max_read_request_size

            if self.cfg_function_status is not None:
                status = 0
                for k in range(len(self.functions)):
                    if self.functions[k].bus_master_enable:
                        status |= 0x07 << k*4
                    if self.functions[k].interrupt_disable:
                        status |= 0x08 << k*4
                self.cfg_function_status.value = status

            # cfg_vf_status
            # cfg_function_power_state
            # cfg_vf_power_state
            # cfg_link_power_state
            # cfg_err_cor_out
            # cfg_err_nonfatal_out
            # cfg_err_fatal_out

            if self.cfg_local_error_out is not None:
                if not self.local_error.empty():
                    self.cfg_local_error_out.value = self.local_error.get_nowait()
                    self.cfg_local_error_valid.value = 1
                else:
                    self.cfg_local_error_out.value = 0
                    self.cfg_local_error_valid.value = 0

            # cfg_rx_pm_state
            # cfg_tx_pm_state
            # cfg_ltssm_state

            if self.cfg_rcb_status is not None:
                status = 0
                for k in range(len(self.functions)):
                    if self.functions[k].pcie_cap.read_completion_boundary:
                        status |= 1 << k
                self.cfg_rcb_status.value = status

            # cfg_obff_enable
            # cfg_pl_status_change
            # cfg_tph_requester_enable
            # cfg_tph_st_mode
            # cfg_vf_tph_requester_enable
            # cfg_vf_tph_st_mode

    async def _run_cfg_msg_rx_logic(self):
        clock_edge_event = RisingEdge(self.user_clk)

        while True:
            await clock_edge_event

            # cfg_msg_received
            # cfg_msg_received_data
            # cfg_msg_received_type

    async def _run_cfg_msg_tx_logic(self):
        clock_edge_event = RisingEdge(self.user_clk)

        while True:
            await clock_edge_event

            # cfg_msg_transmit
            # cfg_msg_transmit_type
            # cfg_msg_transmit_data
            # cfg_msg_transmit_done

    async def _run_cfg_fc_logic(self):
        clock_edge_event = RisingEdge(self.user_clk)

        while True:
            await clock_edge_event

            if isinstance(self.cfg_fc_sel, int):
                sel = self.cfg_fc_sel
            else:
                sel = self.cfg_fc_sel.value.integer

            if (sel == 0b010):
                # Receive credits consumed
                cfg_fc_ph = self.upstream_port.fc_state[0].ph.rx_credits_consumed
                cfg_fc_pd = self.upstream_port.fc_state[0].pd.rx_credits_consumed
                cfg_fc_nph = self.upstream_port.fc_state[0].nph.rx_credits_consumed
                cfg_fc_npd = self.upstream_port.fc_state[0].npd.rx_credits_consumed
                cfg_fc_cplh = self.upstream_port.fc_state[0].cplh.rx_credits_consumed
                cfg_fc_cpld = self.upstream_port.fc_state[0].cpld.rx_credits_consumed
            elif (sel == 0b100):
                # Transmit credits available
                cfg_fc_ph = self.upstream_port.fc_state[0].ph.tx_credits_available
                cfg_fc_pd = self.upstream_port.fc_state[0].pd.tx_credits_available
                cfg_fc_nph = self.upstream_port.fc_state[0].nph.tx_credits_available
                cfg_fc_npd = self.upstream_port.fc_state[0].npd.tx_credits_available
                cfg_fc_cplh = self.upstream_port.fc_state[0].cplh.tx_credits_available
                cfg_fc_cpld = self.upstream_port.fc_state[0].cpld.tx_credits_available
            elif (sel == 0b101):
                # Transmit credit limit
                cfg_fc_ph = self.upstream_port.fc_state[0].ph.tx_credit_limit
                cfg_fc_pd = self.upstream_port.fc_state[0].pd.tx_credit_limit
                cfg_fc_nph = self.upstream_port.fc_state[0].nph.tx_credit_limit
                cfg_fc_npd = self.upstream_port.fc_state[0].npd.tx_credit_limit
                cfg_fc_cplh = self.upstream_port.fc_state[0].cplh.tx_credit_limit
                cfg_fc_cpld = self.upstream_port.fc_state[0].cpld.tx_credit_limit
            elif (sel == 0b110):
                # Transmit credits consumed
                cfg_fc_ph = self.upstream_port.fc_state[0].ph.tx_credits_consumed
                cfg_fc_pd = self.upstream_port.fc_state[0].pd.tx_credits_consumed
                cfg_fc_nph = self.upstream_port.fc_state[0].nph.tx_credits_consumed
                cfg_fc_npd = self.upstream_port.fc_state[0].npd.tx_credits_consumed
                cfg_fc_cplh = self.upstream_port.fc_state[0].cplh.tx_credits_consumed
                cfg_fc_cpld = self.upstream_port.fc_state[0].cpld.tx_credits_consumed
            else:
                # Reserved
                cfg_fc_ph = 0
                cfg_fc_pd = 0
                cfg_fc_nph = 0
                cfg_fc_npd = 0
                cfg_fc_cplh = 0
                cfg_fc_cpld = 0

            if self.cfg_fc_ph is not None:
                self.cfg_fc_ph.value = cfg_fc_ph & 0xff
            if self.cfg_fc_pd is not None:
                self.cfg_fc_pd.value = cfg_fc_pd & 0xfff
            if self.cfg_fc_nph is not None:
                self.cfg_fc_nph.value = cfg_fc_nph & 0xff
            if self.cfg_fc_npd is not None:
                self.cfg_fc_npd.value = cfg_fc_npd & 0xfff
            if self.cfg_fc_cplh is not None:
                self.cfg_fc_cplh.value = cfg_fc_cplh & 0xff
            if self.cfg_fc_cpld is not None:
                self.cfg_fc_cpld.value = cfg_fc_cpld & 0xfff

    async def _run_cfg_ctrl_logic(self):
        clock_edge_event = RisingEdge(self.user_clk)

        while True:
            await clock_edge_event

            if self.sys_reset is not None and not self.sys_reset.value:
                self.config_space_enable = False
            else:
                if self.cfg_config_space_enable is not None:
                    self.config_space_enable = bool(self.cfg_config_space_enable.value)
                else:
                    self.config_space_enable = True

            # cfg_hot_reset_in
            # cfg_hot_reset_out
            # cfg_dsn
            if self.cfg_bus_number is not None:
                self.cfg_bus_number.value = self.bus_num
            # cfg_ds_port_number
            # cfg_ds_bus_number
            # cfg_ds_device_number
            # cfg_ds_function_number
            # cfg_power_state_change_ack
            # cfg_power_state_change_interrupt
            # cfg_err_cor_in
            # cfg_err_uncor_in
            # cfg_flr_in_process
            # cfg_flr_done
            # cfg_vf_flr_in_process
            # cfg_vf_flr_func_num
            # cfg_vf_flr_done
            # cfg_pm_aspm_l1_entry_reject
            # cfg_pm_aspm_tx_l0s_entry_disable
            # cfg_req_pm_transition_l23_ready
            # cfg_link_training_enable

    async def _run_cfg_int_logic(self):
        clock_edge_event = RisingEdge(self.user_clk)

        while True:
            await clock_edge_event

            msi_int = 0
            msi_function_number = 0
            msi_attr = TlpAttr(0)
            msi_select = 0
            msi_pending_status_data_enable = 0
            msi_pending_status_function_num = 0
            msi_pending_status = 0
            msix_int = 0
            msix_address = 0
            msix_data = 0

            if self.cfg_interrupt_msi_int is not None:
                msi_int = self.cfg_interrupt_msi_int.value.integer
            if self.cfg_interrupt_msi_function_number is not None:
                msi_function_number = self.cfg_interrupt_msi_function_number.value.integer
            if self.cfg_interrupt_msi_attr is not None:
                msi_attr = TlpAttr(self.cfg_interrupt_msi_attr.value.integer)
            if self.cfg_interrupt_msi_select is not None:
                msi_select = self.cfg_interrupt_msi_select.value.integer
            if self.cfg_interrupt_msi_pending_status_data_enable is not None:
                msi_pending_status_data_enable = self.cfg_interrupt_msi_pending_status_data_enable.value.integer
            if self.cfg_interrupt_msi_pending_status_function_num is not None:
                msi_pending_status_function_num = self.cfg_interrupt_msi_pending_status_function_num.value.integer
            if self.cfg_interrupt_msi_pending_status is not None:
                msi_pending_status = self.cfg_interrupt_msi_pending_status.value.integer
            if self.cfg_interrupt_msix_int is not None:
                msix_int = self.cfg_interrupt_msix_int.value.integer
            if self.cfg_interrupt_msix_address is not None:
                msix_address = self.cfg_interrupt_msix_address.value.integer
            if self.cfg_interrupt_msix_data is not None:
                msix_data = self.cfg_interrupt_msix_data.value.integer

            # INTx
            # cfg_interrupt_int
            # cfg_interrupt_sent
            # cfg_interrupt_pending

            # MSI
            if self.cfg_interrupt_msi_enable is not None:
                val = 0
                for k in range(min(len(self.functions), 2)):
                    if self.functions[k].msi_cap.msi_enable:
                        val |= 1 << k
                self.cfg_interrupt_msi_enable.value = val

            if self.cfg_interrupt_msi_sent is not None:
                self.cfg_interrupt_msi_sent.value = 0
            if self.cfg_interrupt_msi_fail is not None:
                self.cfg_interrupt_msi_fail.value = 0
            if msi_int:
                bits = [i for i in range(32) if msi_int >> i & 1]
                if len(bits) == 1 and msi_function_number < len(self.functions):
                    self.log.info("Issue MSI interrupt (index %d)", bits[0])
                    await self.functions[msi_function_number].msi_cap.issue_msi_interrupt(bits[0], attr=msi_attr)
                    if self.cfg_interrupt_msi_sent is not None:
                        self.cfg_interrupt_msi_sent.value = 1

            if self.cfg_interrupt_msi_mmenable is not None:
                val = 0
                for k in range(min(len(self.functions), 2)):
                    val |= (self.functions[k].msi_cap.msi_multiple_message_enable & 0x7) << k*3
                self.cfg_interrupt_msi_mmenable.value = val

            # cfg_interrupt_msi_mask_update

            if self.cfg_interrupt_msi_data is not None:
                if msi_select == 0b1111:
                    self.cfg_interrupt_msi_data.value = 0
                else:
                    if msi_select < len(self.functions):
                        self.cfg_interrupt_msi_data.value = self.functions[msi_select].msi_cap.msi_mask_bits
                    else:
                        self.cfg_interrupt_msi_data.value = 0
            if msi_pending_status_data_enable:
                if msi_pending_status_function_num < len(self.functions):
                    self.functions[msi_pending_status_function_num].msi_cap.msi_pending_bits = msi_pending_status

            # MSI-X
            if self.cfg_interrupt_msix_enable is not None:
                val = 0
                for k in range(min(len(self.functions), 4)):
                    if self.functions[k].msix_cap.msix_enable:
                        val |= 1 << k
                self.cfg_interrupt_msix_enable.value = val
            if self.cfg_interrupt_msix_mask is not None:
                val = 0
                for k in range(min(len(self.functions), 4)):
                    if self.functions[k].msix_cap.msix_function_mask:
                        val |= 1 << k
                self.cfg_interrupt_msix_mask.value = val
            # cfg_interrupt_msix_vf_enable
            # cfg_interrupt_msix_vf_mask

            if self.cfg_interrupt_msix_sent is not None:
                self.cfg_interrupt_msix_sent.value = 0
            if self.cfg_interrupt_msix_fail is not None:
                self.cfg_interrupt_msix_fail.value = 0
            if msix_int:
                if msi_function_number < len(self.functions):
                    self.log.info("Issue MSI-X interrupt (addr 0x%08x, data 0x%08x)", msix_address, msix_data)
                    await self.functions[msi_function_number].msix_cap.issue_msix_interrupt(msix_address, msix_data, attr=msi_attr)
                    if self.cfg_interrupt_msix_sent is not None:
                        self.cfg_interrupt_msix_sent.value = 1

            # MSI/MSI-X
            # cfg_interrupt_msi_tph_present
            # cfg_interrupt_msi_tph_type
            # cfg_interrupt_msi_tph_st_tag

    async def _run_cfg_extend_logic(self):
        clock_edge_event = RisingEdge(self.user_clk)

        while True:
            await clock_edge_event

            # cfg_ext_read_received
            # cfg_ext_write_received
            # cfg_ext_register_number
            # cfg_ext_function_number
            # cfg_ext_write_data
            # cfg_ext_write_byte_enable
            # cfg_ext_read_data
            # cfg_ext_read_data_valid



================================================
FILE: tests/Makefile
================================================
# Copyright (c) 2020 Alex Forencich
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

TOPTARGETS := all clean

SUBDIRS := $(wildcard */.)

$(TOPTARGETS): $(SUBDIRS)
$(SUBDIRS):
	$(MAKE) -C $@ $(MAKECMDGOALS)

.PHONY: $(TOPTARGETS) $(SUBDIRS)




================================================
FILE: tests/pcie/Makefile
================================================
# Copyright (c) 2020 Alex Forencich
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

TOPLEVEL_LANG = verilog

SIM ?= icarus
WAVES ?= 0

COCOTB_HDL_TIMEUNIT = 1ns
COCOTB_HDL_TIMEPRECISION = 1ps

DUT      = test_pcie
TOPLEVEL = $(DUT)
MODULE   = $(DUT)
VERILOG_SOURCES += $(DUT).v

include $(shell cocotb-config --makefiles)/Makefile.sim




================================================
FILE: tests/pcie/test_pcie.py
================================================
#!/usr/bin/env python
"""

Copyright (c) 2020 Alex Forencich

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

"""

import logging
import os

import cocotb_test.simulator

import cocotb
from cocotb.regression import TestFactory

from cocotbext.pcie.core import RootComplex, MemoryEndpoint, Device, Switch
from cocotbext.pcie.core.caps import MsiCapability
from cocotbext.pcie.core.utils import PcieId


class TestEndpoint(MemoryEndpoint):
    __test__ = False

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        self.vendor_id = 0x1234
        self.device_id = 0x5678

        self.msi_cap = MsiCapability()
        self.msi_cap.msi_multiple_message_capable = 5
        self.msi_cap.msi_64bit_address_capable = 1
        self.msi_cap.msi_per_vector_mask_capable = 1
        self.register_capability(self.msi_cap)

        self.add_mem_region(1024*1024)
        self.add_prefetchable_mem_region(1024*1024)
        self.add_io_region(1024)


class TB:
    def __init__(self, dut):
        self.dut = dut

        self.log = logging.getLogger("cocotb.tb")
        self.log.setLevel(logging.DEBUG)

        self.rc = RootComplex()

        self.ep = []

        ep = TestEndpoint()
        self.dev = Device(ep)
        self.dev.upstream_port.max_link_speed = 3
        self.dev.upstream_port.max_link_width = 16
        self.ep.append(ep)

        self.rc.make_port().connect(self.dev)

        self.sw = Switch()

        self.rc.make_port().connect(self.sw)

        ep = TestEndpoint()
        self.dev2 = Device(ep)
        self.dev2.upstream_port.max_link_speed = 3
        self.dev2.upstream_port.max_link_width = 16
        self.ep.append(ep)

        self.sw.make_port().connect(self.dev2)

        ep = TestEndpoint()
        self.dev3 = Device(ep)
        self.dev3.upstream_port.max_link_speed = 3
        self.dev3.upstream_port.max_link_width = 16
        self.ep.append(ep)

        self.sw.make_port().connect(self.dev3)

        ep = TestEndpoint()
        self.dev4 = Device(ep)
        self.dev4.upstream_port.max_link_speed = 3
        self.dev4.upstream_port.max_link_width = 16
        self.ep.append(ep)

        self.rc.make_port().connect(self.dev4)


async def run_test_rc_mem(dut):

    tb = TB(dut)

    tb.rc.log.setLevel(logging.DEBUG)

    mem = tb.rc.mem_pool.alloc_region(16*1024*1024)
    mem_base = mem.get_absolute_address(0)

    io = tb.rc.io_pool.alloc_region(1024)
    io_base = io.get_absolute_address(0)

    for length in list(range(1, 32))+[1024]:
        for offset in list(range(8))+list(range(4096-8, 4096)):
            tb.log.info("Memory operation length: %d offset: %d", length, offset)
            addr = mem_base+offset
            test_data = bytearray([x % 256 for x in range(length)])

            await tb.rc.mem_write(addr, test_data)
            assert mem[offset:offset+length] == test_data

            assert await tb.rc.mem_read(addr, length) == test_data

    for length in list(range(1, 32)):
        for offset in list(range(8)):
            tb.log.info("IO operation length: %d offset: %d", length, offset)
            addr = io_base+offset
            test_data = bytearray([x % 256 for x in range(length)])

            await tb.rc.io_write(addr, test_data)
            assert io[offset:offset+length] == test_data

            assert await tb.rc.io_read(addr, length) == test_data


async def run_test_config(dut):

    tb = TB(dut)

    tb.rc.log.setLevel(logging.DEBUG)

    tb.log.info("Read complete config space")
    orig = await tb.rc.config_read(PcieId(0, 1, 0), 0x000, 256, timeout=1000, timeout_unit='ns')

    tb.log.info("Read and write interrupt line register")
    await tb.rc.config_write(PcieId(0, 1, 0), 0x03c, b'\x12', timeout=1000, timeout_unit='ns')
    val = await tb.rc.config_read(PcieId(0, 1, 0), 0x03c, 1, timeout=1000, timeout_unit='ns')

    assert val == b'\x12'

    tb.log.info("Write complete config space")
    await tb.rc.config_write(PcieId(0, 1, 0), 0x000, orig, timeout=1000, timeout_unit='ns')


async def run_test_enumerate(dut):

    tb = TB(dut)

    all_ep = tb.rc.endpoints+[tb.sw.upstream_bridge]+tb.sw.endpoints+tb.ep

    tb.rc.log.setLevel(logging.DEBUG)
    for ep in all_ep:
        ep.log.setLevel(logging.DEBUG)

    await tb.rc.enumerate()

    # check that enumerated tree matches devices
    def check_dev(dev):
        tb.log.info("Check device at %s", dev.pcie_id)

        # ensure ID was assigned to device
        assert dev.pcie_id != PcieId(0, 0, 0)

        # get device
        pdev = tb.rc.find_device(dev.pcie_id)
        assert pdev is not None

        # check informational registers
        tb.log.info("Header type: 0x%02x", pdev.header_type)
        tb.log.info("Vendor ID: 0x%04x", pdev.vendor_id)
        tb.log.info("Device ID: 0x%04x", pdev.device_id)
        tb.log.info("Revision ID: 0x%02x", pdev.revision_id)
        tb.log.info("Class code: 0x%06x", pdev.class_code)

        assert pdev.header_type == dev.header_layout | (bool(dev.multifunction_device) << 7)
        assert pdev.class_code == dev.class_code
        assert pdev.revision_id == dev.revision_id

        assert pdev.vendor_id == dev.vendor_id
        assert pdev.device_id == dev.device_id

        if pdev.header_type == 0x01:
            # bridge
            bar_cnt = 2

            # check bridge registers
            tb.log.info("Primary bus %d", pdev.subordinate.primary)
            tb.log.info("Secondary bus %d", pdev.subordinate.bus_num)
            tb.log.info("Subordinate bus %d", pdev.subordinate.last_bus_num)
            tb.log.info("IO base 0x%08x", pdev.io_base)
            tb.log.info("IO limit 0x%08x", pdev.io_limit)
            tb.log.info("Mem base 0x%08x", pdev.mem_base)
            tb.log.info("Mem limit 0x%08x", pdev.mem_limit)
            tb.log.info("Prefetchable mem base 0x%016x", pdev.prefetchable_mem_base)
            tb.log.info("Prefetchable mem limit 0x%016x", pdev.prefetchable_mem_limit)

            assert pdev.subordinate.primary == dev.pri_bus_num
            assert pdev.subordinate.bus_num == dev.sec_bus_num
            assert pdev.subordinate.last_bus_num == dev.sub_bus_num

            assert pdev.io_base == dev.io_base
            assert pdev.io_limit == dev.io_limit
            assert pdev.mem_base == dev.mem_base
            assert pdev.mem_limit == dev.mem_limit
            assert pdev.prefetchable_mem_base == dev.prefetchable_mem_base
            assert pdev.prefetchable_mem_limit == dev.prefetchable_mem_limit
        else:
            bar_cnt = 6

            tb.log.info("Subsystem vendor ID: 0x%04x", pdev.subsystem_vendor_id)
            tb.log.info("Subsystem ID: 0x%04x", pdev.subsystem_id)

            assert pdev.subsystem_vendor_id == dev.subsystem_vendor_id
            assert pdev.subsystem_id == dev.subsystem_id

        # check BARs
        bar = 0
        while bar < bar_cnt:
            if dev.bar_mask[bar] == 0:
                # unused bar
                assert pdev.bar[bar] is None
                assert pdev.bar_raw[bar] == 0
                assert pdev.bar_addr[bar] is None
                assert pdev.bar_size[bar] == 0
                bar += 1
            elif dev.bar[bar] & 1:
                # IO BAR
                tb.log.info("BAR%d: IO BAR addr 0x%08x, size %d", bar, pdev.bar_addr[bar], pdev.bar_size[bar])
                assert pdev.bar[bar] == dev.bar[bar]
                assert pdev.bar_raw[bar] == dev.bar[bar]
                assert pdev.bar_addr[bar] == dev.bar[bar] & ~0x3
                assert pdev.bar_size[bar] == (~dev.bar_mask[bar] & 0xfffffffc)+0x4
                bar += 1
            elif dev.bar[bar] & 4:
                # 64 bit BAR
                tb.log.info("BAR%d: Mem BAR (32 bit) addr 0x%08x, size %d", bar, pdev.bar_addr[bar], pdev.bar_size[bar])
                assert pdev.bar[bar] == dev.bar[bar] | dev.bar[bar+1] << 32
                assert pdev.bar_raw[bar] == dev.bar[bar]
                assert pdev.bar_raw[bar+1] == dev.bar[bar+1]
                assert pdev.bar_addr[bar] == (dev.bar[bar] | dev.bar[bar+1] << 32) & ~0xf
                assert pdev.bar_size[bar] == (~(dev.bar_mask[bar] | dev.bar_mask[bar+1] << 32) & 0xfffffffffffffff0)+0x10
                bar += 2
            else:
                # 32 bit BAR
                tb.log.info("BAR%d: Mem BAR (64 bit) addr 0x%08x, size %d", bar, pdev.bar_addr[bar], pdev.bar_size[bar])
                assert pdev.bar[bar] == dev.bar[bar]
                assert pdev.bar_raw[bar] == dev.bar[bar]
                assert pdev.bar_addr[bar] == dev.bar[bar] & ~0xf
                assert pdev.bar_size[bar] == (~dev.bar_mask[bar] & 0xfffffff0)+0x10
                bar += 1

        if dev.expansion_rom_addr_mask == 0:
            assert pdev.expansion_rom_raw == 0
            assert pdev.expansion_rom_addr is None
            assert pdev.expansion_rom_size == 0
        else:
            assert pdev.expansion_rom_raw & 0xfffff800 == dev.expansion_rom_addr
            assert pdev.expansion_rom_addr == dev.expansion_rom_addr
            assert pdev.expansion_rom_size == (~dev.expansion_rom_addr_mask & 0xfffff800)+0x800

        # TODO capabilities

    for d in all_ep:
        check_dev(d)

    # check settings in enumerated tree
    def check_bus(bus):
        bus_regions = []
        io_regions = []
        mem_regions = []
        prefetchable_mem_regions = []

        for dev in bus.devices:
            tb.log.info("Check device at %s", dev.pcie_id)

            tb.log.info("Header type: 0x%02x", dev.header_type)
            tb.log.info("Vendor ID: 0x%04x", dev.vendor_id)
            tb.log.info("Device ID: 0x%04x", dev.device_id)
            tb.log.info("Revision ID: 0x%02x", dev.revision_id)
            tb.log.info("Class code: 0x%06x", dev.class_code)

            if dev.header_type & 0x7f == 0x00:
                # type 0 header
                tb.log.info("Subsystem vendor ID: 0x%04x", dev.subsystem_vendor_id)
                tb.log.info("Subsystem ID: 0x%04x", dev.subsystem_id)

            # check that BARs are within our apertures
            for bar in range(6):
                if dev.bar[bar] is None:
                    continue
                if dev.bar[bar] & 1:
                    # IO BAR
                    tb.log.info("BAR%d: IO BAR addr 0x%08x, size %d", bar, dev.bar_addr[bar], dev.bar_size[bar])
                    assert (dev.bus.bridge.io_base <= dev.bar_addr[bar]
                        and dev.bar_addr[bar]+dev.bar_size[bar]-1 <= dev.bus.bridge.io_limit)
                    io_regions.append((dev.bar_addr[bar], dev.bar_addr[bar]+dev.bar_size[bar]-1))
                elif dev.bar[bar] > 0xffffffff:
                    # prefetchable BAR
                    tb.log.info("BAR%d: Mem BAR (prefetchable) addr 0x%08x, size %d",
                        bar, dev.bar_addr[bar], dev.bar_size[bar])
                    assert (dev.bus.bridge.prefetchable_mem_base <= dev.bar_addr[bar]
                        and dev.bar_addr[bar]+dev.bar_size[bar]-1 <= dev.bus.bridge.prefetchable_mem_limit)
                    prefetchable_mem_regions.append((dev.bar_addr[bar], dev.bar_addr[bar]+dev.bar_size[bar]-1))
                else:
                    # non-prefetchable BAR
                    tb.log.info("BAR%d: Mem BAR (non-prefetchable) addr 0x%08x, size %d",
                        bar, dev.bar_addr[bar], dev.bar_size[bar])
                    assert (dev.bus.bridge.mem_base <= dev.bar_addr[bar]
                        and dev.bar_addr[bar]+dev.bar_size[bar]-1 <= dev.bus.bridge.mem_limit)
                    mem_regions.append((dev.bar_addr[bar], dev.bar_addr[bar]+dev.bar_size[bar]-1))

            if dev.expansion_rom_addr:
                # expansion ROM BAR
                tb.log.info("Expansion ROM BAR: Mem BAR (non-prefetchable) addr 0x%08x, size %d",
                    dev.expansion_rom_addr, dev.expansion_rom_size)
                assert (dev.bus.bridge.mem_base <= dev.expansion_rom_addr and
                    dev.expansion_rom_addr+dev.expansion_rom_size-1 <= dev.bus.bridge.mem_limit)
                mem_regions.append((dev.expansion_rom_addr, dev.expansion_rom_addr+dev.expansion_rom_size-1))

            if dev.header_type & 0x7f == 0x01:
                # type 1 header

                tb.log.info("Primary bus: %d", dev.pri_bus_num)
                tb.log.info("Secondary bus: %d", dev.sec_bus_num)
                tb.log.info("Subordinate bus: %d", dev.sub_bus_num)
                tb.log.info("IO base: 0x%08x", dev.io_base)
                tb.log.info("IO limit: 0x%08x", dev.io_limit)
                tb.log.info("Mem base: 0x%08x", dev.mem_base)
                tb.log.info("Mem limit: 0x%08x", dev.mem_limit)
                tb.log.info("Prefetchable mem base: 0x%016x", dev.prefetchable_mem_base)
                tb.log.info("Prefetchable mem limit: 0x%016x", dev.prefetchable_mem_limit)

                # check that child switch apertures are within our apertures
                assert dev.bus.bridge.sec_bus_num <= dev.pri_bus_num <= dev.bus.bridge.sub_bus_num
                assert dev.bus.bridge.sec_bus_num <= dev.sec_bus_num and dev.sub_bus_num <= dev.bus.bridge.sub_bus_num
                bus_regions.append((dev.sec_bus_num, dev.sub_bus_num))
                if dev.io_base:
                    assert dev.bus.bridge.io_base <= dev.io_base and dev.io_limit <= dev.bus.bridge.io_limit
                    io_regions.append((dev.io_base, dev.io_limit))
                if dev.mem_base:
                    assert dev.bus.bridge.mem_base <= dev.mem_base and dev.mem_limit <= dev.bus.bridge.mem_limit
                    mem_regions.append((dev.mem_base, dev.mem_limit))
                if dev.prefetchable_mem_base:
                    assert (dev.bus.bridge.prefetchable_mem_base <= dev.prefetchable_mem_base and
                        dev.prefetchable_mem_limit <= dev.bus.bridge.prefetchable_mem_limit)
                    prefetchable_mem_regions.append((dev.prefetchable_mem_base, dev.prefetchable_mem_limit))

        # check for assignment overlaps
        for lst in [bus_regions, io_regions, mem_regions, prefetchable_mem_regions]:
            lst.sort()
            for m in range(1, len(lst)):
                assert lst[m-1][1] <= lst[m][0], "assigned regions overlap"

        # recurse into child nodes
        for child in bus.children:
            check_bus(child)

    check_bus(tb.rc.host_bridge.bus)


async def run_test_ep_mem(dut, ep_index=0):

    tb = TB(dut)

    await tb.rc.enumerate()
    tb.rc.log.setLevel(logging.DEBUG)

    ep = tb.ep[ep_index]
    ep.log.setLevel(logging.DEBUG)
    dev = tb.rc.find_device(ep.pcie_id)
    await dev.enable_device()

    dev_bar0 = dev.bar_window[0]
    dev_bar1 = dev.bar_window[1]
    dev_bar3 = dev.bar_window[3]

    for length in list(range(0, 32))+[1024]:
        for offset in list(range(8))+list(range(4096-8, 4096)):
            tb.log.info("Memory operation (32-bit BAR) length: %d offset: %d", length, offset)
            test_data = bytearray([x % 256 for x in range(length)])

            await dev_bar0.write(offset, test_data, timeout=1000, timeout_unit='ns')
            # wait for write to complete
            await dev_bar0.read(offset, 0, timeout=1000, timeout_unit='ns')
            assert await ep.read_region(0, offset, length) == test_data

            assert await dev_bar0.read(offset, length, timeout=1000, timeout_unit='ns') == test_data

    for length in list(range(0, 32))+[1024]:
        for offset in list(range(8))+list(range(4096-8, 4096)):
            tb.log.info("Memory operation (64-bit BAR) length: %d offset: %d", length, offset)
            test_data = bytearray([x % 256 for x in range(length)])

            await dev_bar1.write(offset, test_data, timeout=1000, timeout_unit='ns')
            # wait for write to complete
            await dev_bar1.read(offset, 0, timeout=1000, timeout_unit='ns')
            assert await ep.read_region(1, offset, length) == test_data

            assert await dev_bar1.read(offset, length, timeout=1000, timeout_unit='ns') == test_data

    for length in list(range(0, 8)):
        for offset in list(range(8)):
            tb.log.info("IO operation length: %d offset: %d", length, offset)
            test_data = bytearray([x % 256 for x in range(length)])

            await dev_bar3.write(offset, test_data, timeout=1000, timeout_unit='ns')
            assert await ep.read_region(3, offset, length) == test_data

            assert await dev_bar3.read(offset, length, timeout=1000, timeout_unit='ns') == test_data


async def run_test_p2p_dma(dut, ep1_index=0, ep2_index=1):

    tb = TB(dut)

    await tb.rc.enumerate()
    tb.rc.log.setLevel(logging.DEBUG)

    ep1 = tb.ep[ep1_index]
    ep1.log.setLevel(logging.DEBUG)
    dev1 = tb.rc.find_device(ep1.pcie_id)
    await dev1.enable_device()
    await dev1.set_master()
    ep2 = tb.ep[ep2_index]
    ep2.log.setLevel(logging.DEBUG)
    dev2 = tb.rc.find_device(ep2.pcie_id)
    await dev2.enable_device()

    for length in list(range(0, 32))+[1024]:
        for offset in list(range(8))+list(range(4096-8, 4096)):
            tb.log.info("Memory operation (32-bit BAR) length: %d offset: %d", length, offset)
            addr = dev2.bar_addr[0]+offset
            test_data = bytearray([x % 256 for x in range(length)])

            await ep1.mem_write(addr, test_data, timeout=1000, timeout_unit='ns')
            # wait for write to complete
            await ep1.mem_read(addr, 0, timeout=1000, timeout_unit='ns')
            assert await ep2.read_region(0, offset, length) == test_data

            assert await ep1.mem_read(addr, length, timeout=1000, timeout_unit='ns') == test_data

    for length in list(range(0, 32))+[1024]:
        for offset in list(range(8))+list(range(4096-8, 4096)):
            tb.log.info("Memory operation (64-bit BAR) length: %d offset: %d", length, offset)
            addr = dev2.bar_addr[1]+offset
            test_data = bytearray([x % 256 for x in range(length)])

            await ep1.mem_write(addr, test_data, timeout=1000, timeout_unit='ns')
            # wait for write to complete
            await ep1.mem_read(addr, 0, timeout=1000, timeout_unit='ns')
            assert await ep2.read_region(1, offset, length) == test_data

            assert await ep1.mem_read(addr, length, timeout=1000, timeout_unit='ns') == test_data

    for length in list(range(0, 8)):
        for offset in list(range(8)):
            tb.log.info("IO operation length: %d offset: %d", length, offset)
            addr = dev2.bar_addr[3]+offset
            test_data = bytearray([x % 256 for x in range(length)])

            await ep1.io_write(addr, test_data, timeout=1000, timeout_unit='ns')
            assert await ep2.read_region(3, offset, length) == test_data

            assert await ep1.io_read(addr, length, timeout=1000, timeout_unit='ns') == test_data


async def run_test_dma(dut, ep_index=0):

    tb = TB(dut)

    mem = tb.rc.mem_pool.alloc_region(16*1024*1024)
    mem_base = mem.get_absolute_address(0)

    io = tb.rc.io_pool.alloc_region(1024)
    io_base = io.get_absolute_address(0)

    await tb.rc.enumerate()
    tb.rc.log.setLevel(logging.DEBUG)

    ep = tb.ep[ep_index]
    ep.log.setLevel(logging.DEBUG)
    dev = tb.rc.find_device(ep.pcie_id)
    await dev.enable_device()
    await dev.set_master()

    for length in list(range(0, 32))+[1024]:
        for offset in list(range(8))+list(range(4096-8, 4096)):
            tb.log.info("Memory operation (DMA) length: %d offset: %d", length, offset)
            addr = mem_base+offset
            test_data = bytearray([x % 256 for x in range(length)])

            await ep.mem_write(addr, test_data, timeout=1000, timeout_unit='ns')
            # wait for write to complete
            await ep.mem_read(addr, 0, timeout=1000, timeout_unit='ns')
            assert mem[offset:offset+length] == test_data

            assert await ep.mem_read(addr, length, timeout=1000, timeout_unit='ns') == test_data

    for length in list(range(0, 8)):
        for offset in list(range(8)):
            tb.log.info("IO operation (DMA) length: %d offset: %d", length, offset)
            addr = io_base+offset
            test_data = bytearray([x % 256 for x in range(length)])

            await ep.io_write(addr, test_data, timeout=1000, timeout_unit='ns')
            assert io[offset:offset+length] == test_data

            assert await ep.io_read(addr, length, timeout=1000, timeout_unit='ns') == test_data


async def run_test_msi(dut, ep_index=0):

    tb = TB(dut)

    await tb.rc.enumerate()
    tb.rc.log.setLevel(logging.DEBUG)

    ep = tb.ep[ep_index]
    ep.log.setLevel(logging.DEBUG)
    dev = tb.rc.find_device(ep.pcie_id)
    await dev.enable_device()
    await dev.set_master()
    await dev.alloc_irq_vectors(32, 32)

    for k in range(32):
        tb.log.info("Send MSI %d", k)

        await ep.msi_cap.issue_msi_interrupt(k)

        event = dev.msi_vectors[k].event
        event.clear()
        await event.wait()

if cocotb.SIM_NAME:

    for test in [
                run_test_rc_mem,
                run_test_config,
                run_test_enumerate,
            ]:

        factory = TestFactory(test)
        factory.generate_tests()

    factory = TestFactory(run_test_ep_mem)
    factory.add_option("ep_index", range(4))
    factory.generate_tests()

    factory = TestFactory(run_test_p2p_dma)
    factory.add_option("ep1_index", [0, 1])
    factory.add_option("ep2_index", [2, 3])
    factory.generate_tests()

    factory = TestFactory(run_test_dma)
    factory.add_option("ep_index", range(4))
    factory.generate_tests()

    factory = TestFactory(run_test_msi)
    factory.add_option("ep_index", range(4))
    factory.generate_tests()


# cocotb-test

tests_dir = os.path.dirname(__file__)


def test_pcie(request):
    dut = "test_pcie"
    module = os.path.splitext(os.path.basename(__file__))[0]
    toplevel = dut

    verilog_sources = [
        os.path.join(os.path.dirname(__file__), f"{dut}.v"),
    ]

    sim_build = os.path.join(tests_dir, "sim_build",
        request.node.name.replace('[', '-').replace(']', ''))

    cocotb_test.simulator.run(
        python_search=[tests_dir],
        verilog_sources=verilog_sources,
        toplevel=toplevel,
        module=module,
        sim_build=sim_build,
    )



================================================
FILE: tests/pcie/test_pcie.v
================================================

`resetall
`timescale 1 ns / 1 ps
`default_nettype none

module test_pcie;

endmodule

`resetall



================================================
FILE: tests/pcie_ptile/Makefile
================================================
# Copyright (c) 2022 Alex Forencich
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

TOPLEVEL_LANG = verilog

SIM ?= icarus
WAVES ?= 0

COCOTB_HDL_TIMEUNIT = 1ns
COCOTB_HDL_TIMEPRECISION = 1ps

DUT      = test_pcie_ptile
TOPLEVEL = $(DUT)
MODULE   = $(DUT)
VERILOG_SOURCES  = $(DUT).v

# module parameters
export PARAM_SEG_COUNT := 1
export PARAM_SEG_DATA_WIDTH := 128
export PARAM_SEG_HDR_WIDTH := 128
export PARAM_SEG_PRFX_WIDTH := 32
export PARAM_SEG_DATA_PAR_WIDTH := $(shell expr $(PARAM_SEG_DATA_WIDTH) / 8 )
export PARAM_SEG_HDR_PAR_WIDTH := $(shell expr $(PARAM_SEG_HDR_WIDTH) / 8 )
export PARAM_SEG_PRFX_PAR_WIDTH := $(shell expr $(PARAM_SEG_PRFX_WIDTH) / 8 )
export PARAM_SEG_EMPTY_WIDTH := $(shell python -c "print((($(PARAM_SEG_DATA_WIDTH)//32)-1).bit_length())" )

ifeq ($(SIM), icarus)
	PLUSARGS += -fst

	COMPILE_ARGS += $(foreach v,$(filter PARAM_%,$(.VARIABLES)),-P $(TOPLEVEL).$(subst PARAM_,,$(v))=$($(v)))

	ifeq ($(WAVES), 1)
		VERILOG_SOURCES += iverilog_dump.v
		COMPILE_ARGS += -s iverilog_dump
	endif
else ifeq ($(SIM), verilator)
	COMPILE_ARGS += -Wno-SELRANGE -Wno-WIDTH

	COMPILE_ARGS += $(foreach v,$(filter PARAM_%,$(.VARIABLES)),-G$(subst PARAM_,,$(v))=$($(v)))

	ifeq ($(WAVES), 1)
		COMPILE_ARGS += --trace-fst
	endif
endif

include $(shell cocotb-config --makefiles)/Makefile.sim

iverilog_dump.v:
	echo 'module iverilog_dump();' > $@
	echo 'initial begin' >> $@
	echo '    $$dumpfile("$(TOPLEVEL).fst");' >> $@
	echo '    $$dumpvars(0, $(TOPLEVEL));' >> $@
	echo 'end' >> $@
	echo 'endmodule' >> $@

clean::
	@rm -rf iverilog_dump.v
	@rm -rf dump.fst $(TOPLEVEL).fst



================================================
FILE: tests/pcie_ptile/test_pcie_ptile.py
================================================
#!/usr/bin/env python
"""

Copyright (c) 2022 Alex Forencich

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

"""

import itertools
import logging
import mmap
import os
import struct

import cocotb_test.simulator
import pytest

import cocotb
from cocotb.queue import Queue
from cocotb.triggers import RisingEdge, Timer, Event, First
from cocotb.regression import TestFactory

from cocotbext.pcie.core import RootComplex
from cocotbext.pcie.intel.ptile import PTilePcieDevice, PTileRxBus, PTileTxBus
from cocotbext.pcie.intel.ptile.interface import PTilePcieFrame, PTilePcieSource, PTilePcieSink
from cocotbext.pcie.core.tlp import Tlp, TlpType, CplStatus
from cocotbext.pcie.core.utils import PcieId


class TB:
    def __init__(self, dut, msix=False):
        self.dut = dut

        self.log = logging.getLogger("cocotb.tb")
        self.log.setLevel(logging.DEBUG)

        # PCIe
        self.rc = RootComplex()

        self.dev = PTilePcieDevice(
            # configuration options
            port_num=0,
            pcie_generation=3,
            # pcie_link_width=2,
            # user_clk_frequency=250e6,
            pf_count=1,
            max_payload_size=128,
            enable_extended_tag=False,

            pf0_msi_enable=True,
            pf0_msi_count=32,
            pf1_msi_enable=False,
            pf1_msi_count=1,
            pf2_msi_enable=False,
            pf2_msi_count=1,
            pf3_msi_enable=False,
            pf3_msi_count=1,
            pf0_msix_enable=msix,
            pf0_msix_table_size=63,
            pf0_msix_table_bir=4,
            pf0_msix_table_offset=0x00000000,
            pf0_msix_pba_bir=4,
            pf0_msix_pba_offset=0x00008000,
            pf1_msix_enable=False,
            pf1_msix_table_size=0,
            pf1_msix_table_bir=0,
            pf1_msix_table_offset=0x00000000,
            pf1_msix_pba_bir=0,
            pf1_msix_pba_offset=0x00000000,
            pf2_msix_enable=False,
            pf2_msix_table_size=0,
            pf2_msix_table_bir=0,
            pf2_msix_table_offset=0x00000000,
            pf2_msix_pba_bir=0,
            pf2_msix_pba_offset=0x00000000,
            pf3_msix_enable=False,
            pf3_msix_table_size=0,
            pf3_msix_table_bir=0,
            pf3_msix_table_offset=0x00000000,
            pf3_msix_pba_bir=0,
            pf3_msix_pba_offset=0x00000000,

            # signals
            # Clock and reset
            # reset_status=dut.reset_status,
            reset_status_n=dut.reset_status_n,
            coreclkout_hip=dut.coreclkout_hip,
            refclk0=dut.refclk0,
            refclk1=dut.refclk1,
            pin_perst_n=dut.pin_perst_n,

            # RX interface
            rx_bus=PTileRxBus.from_prefix(dut, "rx_st"),
            rx_par_err=dut.rx_par_err,

            # TX interface
            tx_bus=PTileTxBus.from_prefix(dut, "tx_st"),
            tx_par_err=dut.tx_par_err,

            # RX flow control
            rx_buffer_limit=dut.rx_buffer_limit,
            rx_buffer_limit_tdm_idx=dut.rx_buffer_limit_tdm_idx,

            # TX flow control
            tx_cdts_limit=dut.tx_cdts_limit,
            tx_cdts_limit_tdm_idx=dut.tx_cdts_limit_tdm_idx,

            # Power management and hard IP status interface
            link_up=dut.link_up,
            dl_up=dut.dl_up,
            surprise_down_err=dut.surprise_down_err,
            ltssm_state=dut.ltssm_state,
            pm_state=dut.pm_state,
            pm_dstate=dut.pm_dstate,
            apps_pm_xmt_pme=dut.apps_pm_xmt_pme,
            app_req_retry_en=dut.app_req_retry_en,

            # Interrupt interface
            app_int=dut.app_int,
            msi_pnd_func=dut.msi_pnd_func,
            msi_pnd_byte=dut.msi_pnd_byte,
            msi_pnd_addr=dut.msi_pnd_addr,

            # Error interface
            serr_out=dut.serr_out,
            hip_enter_err_mode=dut.hip_enter_err_mode,
            app_err_valid=dut.app_err_valid,
            app_err_hdr=dut.app_err_hdr,
            app_err_info=dut.app_err_info,
            app_err_func_num=dut.app_err_func_num,

            # Completion timeout interface
            cpl_timeout=dut.cpl_timeout,
            cpl_timeout_avmm_clk=dut.cpl_timeout_avmm_clk,
            cpl_timeout_avmm_address=dut.cpl_timeout_avmm_address,
            cpl_timeout_avmm_read=dut.cpl_timeout_avmm_read,
            cpl_timeout_avmm_readdata=dut.cpl_timeout_avmm_readdata,
            cpl_timeout_avmm_readdatavalid=dut.cpl_timeout_avmm_readdatavalid,
            cpl_timeout_avmm_write=dut.cpl_timeout_avmm_write,
            cpl_timeout_avmm_writedata=dut.cpl_timeout_avmm_writedata,
            cpl_timeout_avmm_waitrequest=dut.cpl_timeout_avmm_waitrequest,

            # Configuration output
            tl_cfg_func=dut.tl_cfg_func,
            tl_cfg_add=dut.tl_cfg_add,
            tl_cfg_ctl=dut.tl_cfg_ctl,
            dl_timer_update=dut.dl_timer_update,

            # Configuration intercept interface
            cii_req=dut.cii_req,
            cii_hdr_poisoned=dut.cii_hdr_poisoned,
            cii_hdr_first_be=dut.cii_hdr_first_be,
            cii_func_num=dut.cii_func_num,
            cii_wr_vf_active=dut.cii_wr_vf_active,
            cii_vf_num=dut.cii_vf_num,
            cii_wr=dut.cii_wr,
            cii_addr=dut.cii_addr,
            cii_dout=dut.cii_dout,
            cii_override_en=dut.cii_override_en,
            cii_override_din=dut.cii_override_din,
            cii_halt=dut.cii_halt,

            # Hard IP reconfiguration interface
            hip_reconfig_clk=dut.hip_reconfig_clk,
            hip_reconfig_address=dut.hip_reconfig_address,
            hip_reconfig_read=dut.hip_reconfig_read,
            hip_reconfig_readdata=dut.hip_reconfig_readdata,
            hip_reconfig_readdatavalid=dut.hip_reconfig_readdatavalid,
            hip_reconfig_write=dut.hip_reconfig_write,
            hip_reconfig_writedata=dut.hip_reconfig_writedata,
            hip_reconfig_waitrequest=dut.hip_reconfig_waitrequest,

            # Page request service
            prs_event_valid=dut.prs_event_valid,
            prs_event_func=dut.prs_event_func,
            prs_event=dut.prs_event,

            # SR-IOV (VF error)
            vf_err_ur_posted_s0=dut.vf_err_ur_posted_s0,
            vf_err_ur_posted_s1=dut.vf_err_ur_posted_s1,
            vf_err_ur_posted_s2=dut.vf_err_ur_posted_s2,
            vf_err_ur_posted_s3=dut.vf_err_ur_posted_s3,
            vf_err_func_num_s0=dut.vf_err_func_num_s0,
            vf_err_func_num_s1=dut.vf_err_func_num_s1,
            vf_err_func_num_s2=dut.vf_err_func_num_s2,
            vf_err_func_num_s3=dut.vf_err_func_num_s3,
            vf_err_ca_postedreq_s0=dut.vf_err_ca_postedreq_s0,
            vf_err_ca_postedreq_s1=dut.vf_err_ca_postedreq_s1,
            vf_err_ca_postedreq_s2=dut.vf_err_ca_postedreq_s2,
            vf_err_ca_postedreq_s3=dut.vf_err_ca_postedreq_s3,
            vf_err_vf_num_s0=dut.vf_err_vf_num_s0,
            vf_err_vf_num_s1=dut.vf_err_vf_num_s1,
            vf_err_vf_num_s2=dut.vf_err_vf_num_s2,
            vf_err_vf_num_s3=dut.vf_err_vf_num_s3,
            vf_err_poisonedwrreq_s0=dut.vf_err_poisonedwrreq_s0,
            vf_err_poisonedwrreq_s1=dut.vf_err_poisonedwrreq_s1,
            vf_err_poisonedwrreq_s2=dut.vf_err_poisonedwrreq_s2,
            vf_err_poisonedwrreq_s3=dut.vf_err_poisonedwrreq_s3,
            vf_err_poisonedcompl_s0=dut.vf_err_poisonedcompl_s0,
            vf_err_poisonedcompl_s1=dut.vf_err_poisonedcompl_s1,
            vf_err_poisonedcompl_s2=dut.vf_err_poisonedcompl_s2,
            vf_err_poisonedcompl_s3=dut.vf_err_poisonedcompl_s3,
            user_vfnonfatalmsg_func_num=dut.user_vfnonfatalmsg_func_num,
            user_vfnonfatalmsg_vfnum=dut.user_vfnonfatalmsg_vfnum,
            user_sent_vfnonfatalmsg=dut.user_sent_vfnonfatalmsg,
            vf_err_overflow=dut.vf_err_overflow,

            # FLR
            flr_rcvd_pf=dut.flr_rcvd_pf,
            flr_rcvd_vf=dut.flr_rcvd_vf,
            flr_rcvd_pf_num=dut.flr_rcvd_pf_num,
            flr_rcvd_vf_num=dut.flr_rcvd_vf_num,
            flr_completed_pf=dut.flr_completed_pf,
            flr_completed_vf=dut.flr_completed_vf,
            flr_completed_pf_num=dut.flr_completed_pf_num,
            flr_completed_vf_num=dut.flr_completed_vf_num,

            # VirtIO
            virtio_pcicfg_vfaccess=dut.virtio_pcicfg_vfaccess,
            virtio_pcicfg_vfnum=dut.virtio_pcicfg_vfnum,
            virtio_pcicfg_pfnum=dut.virtio_pcicfg_pfnum,
            virtio_pcicfg_bar=dut.virtio_pcicfg_bar,
            virtio_pcicfg_length=dut.virtio_pcicfg_length,
            virtio_pcicfg_baroffset=dut.virtio_pcicfg_baroffset,
            virtio_pcicfg_cfgdata=dut.virtio_pcicfg_cfgdata,
            virtio_pcicfg_cfgwr=dut.virtio_pcicfg_cfgwr,
            virtio_pcicfg_cfgrd=dut.virtio_pcicfg_cfgrd,
            virtio_pcicfg_appvfnum=dut.virtio_pcicfg_appvfnum,
            virtio_pcicfg_apppfnum=dut.virtio_pcicfg_apppfnum,
            virtio_pcicfg_rdack=dut.virtio_pcicfg_rdack,
            virtio_pcicfg_rdbe=dut.virtio_pcicfg_rdbe,
            virtio_pcicfg_data=dut.virtio_pcicfg_data,
        )

        self.dev.log.setLevel(logging.DEBUG)

        dut.refclk0.setimmediatevalue(0)
        dut.refclk1.setimmediatevalue(0)
        dut.pin_perst_n.setimmediatevalue(1)
        dut.rx_buffer_limit.setimmediatevalue(0)
        dut.rx_buffer_limit_tdm_idx.setimmediatevalue(0)
        dut.apps_pm_xmt_pme.setimmediatevalue(0)
        dut.app_req_retry_en.setimmediatevalue(0)
        dut.app_int.setimmediatevalue(0)
        dut.msi_pnd_func.setimmediatevalue(0)
        dut.msi_pnd_byte.setimmediatevalue(0)
        dut.msi_pnd_addr.setimmediatevalue(0)
        dut.app_err_valid.setimmediatevalue(0)
        dut.app_err_hdr.setimmediatevalue(0)
        dut.app_err_info.setimmediatevalue(0)
        dut.app_err_func_num.setimmediatevalue(0)
        dut.cpl_timeout.setimmediatevalue(0)
        dut.cpl_timeout_avmm_clk.setimmediatevalue(0)
        dut.cpl_timeout_avmm_address.setimmediatevalue(0)
        dut.cpl_timeout_avmm_read.setimmediatevalue(0)
        dut.cpl_timeout_avmm_write.setimmediatevalue(0)
        dut.cpl_timeout_avmm_writedata.setimmediatevalue(0)
        dut.cii_override_en.setimmediatevalue(0)
        dut.cii_override_din.setimmediatevalue(0)
        dut.cii_halt.setimmediatevalue(0)
        dut.hip_reconfig_clk.setimmediatevalue(0)
        dut.hip_reconfig_address.setimmediatevalue(0)
        dut.hip_reconfig_read.setimmediatevalue(0)
        dut.hip_reconfig_write.setimmediatevalue(0)
        dut.hip_reconfig_writedata.setimmediatevalue(0)
        dut.prs_event_valid.setimmediatevalue(0)
        dut.prs_event_func.setimmediatevalue(0)
        dut.prs_event.setimmediatevalue(0)
        dut.user_vfnonfatalmsg_func_num.setimmediatevalue(0)
        dut.user_vfnonfatalmsg_vfnum.setimmediatevalue(0)
        dut.user_sent_vfnonfatalmsg.setimmediatevalue(0)
        dut.flr_completed_pf.setimmediatevalue(0)
        dut.flr_completed_vf.setimmediatevalue(0)
        dut.flr_completed_pf_num.setimmediatevalue(0)
        dut.flr_completed_vf_num.setimmediatevalue(0)
        dut.virtio_pcicfg_appvfnum.setimmediatevalue(0)
        dut.virtio_pcicfg_apppfnum.setimmediatevalue(0)
        dut.virtio_pcicfg_rdack.setimmediatevalue(0)
        dut.virtio_pcicfg_rdbe.setimmediatevalue(0)
        dut.virtio_pcicfg_data.setimmediatevalue(0)

        self.rc.make_port().connect(self.dev)

        # user logic
        self.tx_source = PTilePcieSource(PTileTxBus.from_prefix(dut, "tx_st"), dut.coreclkout_hip)
        self.tx_source.ready_latency = 3
        self.rx_sink = PTilePcieSink(PTileRxBus.from_prefix(dut, "rx_st"), dut.coreclkout_hip)
        self.rx_sink.ready_latency = 27

        self.regions = [None]*6
        self.regions[0] = mmap.mmap(-1, 1024*1024)
        self.regions[1] = mmap.mmap(-1, 1024*1024)
        self.regions[3] = mmap.mmap(-1, 1024)
        self.regions[4] = mmap.mmap(-1, 1024*64)

        self.current_tag = 0
        self.tag_count = 256
        self.tag_active = [False]*256
        self.tag_release = Event()

        self.rx_cpl_queues = [Queue() for k in range(256)]
        self.rx_cpl_sync = [Event() for k in range(256)]

        self.dev_bus_num = 0
        self.dev_device_num = 0
        self.dev_max_payload = 0
        self.dev_max_read_req = 0
        self.dev_msi_enable = 0
        self.dev_msi_multi_msg_enable = 0
        self.dev_msi_address = 0
        self.dev_msi_data = 0
        self.dev_msi_mask = 0
        self.dev.msix_enable = 0
        self.dev.msix_function_mask = 0

        self.dev.functions[0].configure_bar(0, len(self.regions[0]))
        self.dev.functions[0].configure_bar(1, len(self.regions[1]), True, True)
        self.dev.functions[0].configure_bar(3, len(self.regions[3]), False, False, True)
        self.dev.functions[0].configure_bar(4, len(self.regions[4]))

        cocotb.start_soon(self._run_rx_tlp())
        cocotb.start_soon(self._run_cfg())

    def set_idle_generator(self, generator=None):
        if generator:
            self.dev.rx_source.set_pause_generator(generator())

    def set_backpressure_generator(self, generator=None):
        if generator:
            self.dev.tx_sink.set_pause_generator(generator())

    async def recv_cpl(self, tag, timeout=0, timeout_unit='ns'):
        queue = self.rx_cpl_queues[tag]
        sync = self.rx_cpl_sync[tag]

        if not queue.empty():
            return queue.get_nowait()

        sync.clear()
        if timeout:
            await First(sync.wait(), Timer(timeout, timeout_unit))
        else:
            await sync.wait()

        if not queue.empty():
            return queue.get_nowait()

        return None

    async def alloc_tag(self):
        tag_count = min(256 if self.dev.functions[0].pcie_cap.extended_tag_field_enable else 32, self.tag_count)

        while True:
            tag = self.current_tag
            for k in range(tag_count):
                tag = (tag + 1) % tag_count
                if not self.tag_active[tag]:
                    self.tag_active[tag] = True
                    self.current_tag = tag
                    return tag

            self.tag_release.clear()
            await self.tag_release.wait()

    def release_tag(self, tag):
        assert self.tag_active[tag]
        self.tag_active[tag] = False
        self.tag_release.set()

    async def perform_posted_operation(self, req):
        await self.tx_source.send(PTilePcieFrame.from_tlp(req))

    async def perform_nonposted_operation(self, req, timeout=0, timeout_unit='ns'):
        completions = []

        req.tag = await self.alloc_tag()

        await self.tx_source.send(PTilePcieFrame.from_tlp(req))

        while True:
            cpl = await self.recv_cpl(req.tag, timeout, timeout_unit)

            if not cpl:
                break

            completions.append(cpl)

            if cpl.status != CplStatus.SC:
                # bad status
                break
            elif req.fmt_type in {TlpType.MEM_READ, TlpType.MEM_READ_64}:
                # completion for memory read request

                # request completed
                if cpl.byte_count <= cpl.length*4 - (cpl.lower_address & 0x3):
                    break

                # completion for read request has SC status but no data
                if cpl.fmt_type in {TlpType.CPL, TlpType.CPL_LOCKED}:
                    break

            else:
                # completion for other request
                break

        self.release_tag(req.tag)

        return completions

    async def dma_io_write(self, addr, data, timeout=0, timeout_unit='ns'):
        n = 0

        zero_len = len(data) == 0
        if zero_len:
            data = b'\x00'

        op_list = []

        while n < len(data):
            req = Tlp()
            req.fmt_type = TlpType.IO_WRITE
            req.requester_id = PcieId(self.dev_bus_num, self.dev_device_num, 0)

            first_pad = addr % 4
            byte_length = min(len(data)-n, 4-first_pad)
            req.set_addr_be_data(addr, data[n:n+byte_length])

            if zero_len:
                req.first_be = 0

            op_list.append(cocotb.start_soon(self.perform_nonposted_operation(req, timeout, timeout_unit)))

            n += byte_length
            addr += byte_length

        for op in op_list:
            cpl_list = await op.join()

            if not cpl_list:
                raise Exception("Timeout")
            if cpl_list[0].status != CplStatus.SC:
                raise Exception("Unsuccessful completion")

    async def dma_io_read(self, addr, length, timeout=0, timeout_unit='ns'):
        data = bytearray()
        n = 0

        zero_len = length <= 0
        if zero_len:
            length = 1

        op_list = []

        while n < length:
            req = Tlp()
            req.fmt_type = TlpType.IO_READ
            req.requester_id = PcieId(self.dev_bus_num, self.dev_device_num, 0)

            first_pad = addr % 4
            byte_length = min(length-n, 4-first_pad)
            req.set_addr_be(addr, byte_length)

            if zero_len:
                req.first_be = 0

            op_list.append((first_pad, cocotb.start_soon(self.perform_nonposted_operation(req, timeout, timeout_unit))))

            n += byte_length
            addr += byte_length

        for first_pad, op in op_list:
            cpl_list = await op.join()

            if not cpl_list:
                raise Exception("Timeout")
            cpl = cpl_list[0]
            if cpl.status != CplStatus.SC:
                raise Exception("Unsuccessful completion")

            assert cpl.length == 1
            d = cpl.get_data()

            data.extend(d[first_pad:])

        if zero_len:
            return b''

        return bytes(data[:length])

    async def dma_mem_write(self, addr, data, timeout=0, timeout_unit='ns'):
        n = 0

        zero_len = len(data) == 0
        if zero_len:
            data = b'\x00'

        while n < len(data):
            req = Tlp()
            if addr > 0xffffffff:
                req.fmt_type = TlpType.MEM_WRITE_64
            else:
                req.fmt_type = TlpType.MEM_WRITE
            req.requester_id = PcieId(self.dev_bus_num, self.dev_device_num, 0)

            first_pad = addr % 4
            byte_length = len(data)-n
            # max payload size
            byte_length = min(byte_length, (128 << self.dev_max_payload)-first_pad)
            # 4k address align
            byte_length = min(byte_length, 0x1000 - (addr & 0xfff))
            req.set_addr_be_data(addr, data[n:n+byte_length])

            if zero_len:
                req.first_be = 0

            await self.perform_posted_operation(req)

            n += byte_length
            addr += byte_length

    async def dma_mem_read(self, addr, length, timeout=0, timeout_unit='ns'):
        data = bytearray()
        n = 0

        zero_len = length <= 0
        if zero_len:
            length = 1

        op_list = []

        while n < length:
            req = Tlp()
            if addr > 0xffffffff:
                req.fmt_type = TlpType.MEM_READ_64
            else:
                req.fmt_type = TlpType.MEM_READ
            req.requester_id = PcieId(self.dev_bus_num, self.dev_device_num, 0)

            first_pad = addr % 4
            # remaining length
            byte_length = length-n
            # limit to max read request size
            if byte_length > (128 << self.dev_max_read_req) - first_pad:
                # split on 128-byte read completion boundary
                byte_length = min(byte_length, (128 << self.dev_max_read_req) - (addr & 0x7f))
            # 4k align
            byte_length = min(byte_length, 0x1000 - (addr & 0xfff))
            req.set_addr_be(addr, byte_length)

            if zero_len:
                req.first_be = 0

            op_list.append((byte_length, cocotb.start_soon(self.perform_nonposted_operation(req, timeout, timeout_unit))))

            n += byte_length
            addr += byte_length

        for byte_length, op in op_list:
            cpl_list = await op.join()

            m = 0

            while m < byte_length:
                if not cpl_list:
                    raise Exception("Timeout")

                cpl = cpl_list.pop(0)

                if cpl.status != CplStatus.SC:
                    raise Exception("Unsuccessful completion")

                assert cpl.byte_count+3+(cpl.lower_address & 3) >= cpl.length*4
                assert cpl.byte_count == max(byte_length - m, 1)

                d = cpl.get_data()

                offset = cpl.lower_address & 3
                data.extend(d[offset:offset+cpl.byte_count])

                m += len(d)-offset

        if zero_len:
            return b''

        return bytes(data[:length])

    async def _run_rx_tlp(self):
        while True:
            frame = await self.rx_sink.recv()

            tlp = frame.to_tlp()

            self.log.debug("RX TLP: %s", repr(tlp))

            if tlp.fmt_type in {TlpType.CPL, TlpType.CPL_DATA, TlpType.CPL_LOCKED, TlpType.CPL_LOCKED_DATA}:
                self.log.info("Completion")

                self.rx_cpl_queues[tlp.tag].put_nowait(tlp)
                self.rx_cpl_sync[tlp.tag].set()

            elif tlp.fmt_type == TlpType.IO_READ:
                self.log.info("IO read")

                cpl = Tlp.create_completion_data_for_tlp(tlp, PcieId(self.dev_bus_num, 0, 0))

                # region = tlp.bar_id
                region = 3
                addr = tlp.address % len(self.regions[region])
                offset = 0
                start_offset = None
                mask = tlp.first_be

                # perform operation
                data = bytearray(4)

                for k in range(4):
                    if mask & (1 << k):
                        if start_offset is None:
                            start_offset = offset
                    else:
                        if start_offset is not None and offset != start_offset:
                            data[start_offset:offset] = self.regions[region][addr+start_offset:addr+offset]
                        start_offset = None

                    offset += 1

                if start_offset is not None and offset != start_offset:
                    data[start_offset:offset] = self.regions[region][addr+start_offset:addr+offset]

                cpl.set_data(data)
                cpl.byte_count = 4
                cpl.length = 1

                self.log.debug("Completion: %s", repr(cpl))
                await self.tx_source.send(PTilePcieFrame.from_tlp(cpl))

            elif tlp.fmt_type == TlpType.IO_WRITE:
                self.log.info("IO write")

                cpl = Tlp.create_completion_for_tlp(tlp, PcieId(self.dev_bus_num, 0, 0))

                # region = tlp.bar_id
                region = 3
                addr = tlp.address % len(self.regions[region])
                offset = 0
                start_offset = None
                mask = tlp.first_be

                # perform operation
                data = tlp.get_data()

                for k in range(4):
                    if mask & (1 << k):
                        if start_offset is None:
                            start_offset = offset
                    else:
                        if start_offset is not None and offset != start_offset:
                            self.regions[region][addr+start_offset:addr+offset] = data[start_offset:offset]
                        start_offset = None

                    offset += 1

                if start_offset is not None and offset != start_offset:
                    self.regions[region][addr+start_offset:addr+offset] = data[start_offset:offset]

                self.log.debug("Completion: %s", repr(cpl))
                await self.tx_source.send(PTilePcieFrame.from_tlp(cpl))

            elif tlp.fmt_type in {TlpType.MEM_READ, TlpType.MEM_READ_64}:
                self.log.info("Memory read")

                # perform operation
                region = frame.bar_range
                addr = tlp.address % len(self.regions[region])
                offset = 0
                length = tlp.length

                # perform read
                data = self.regions[region][addr:addr+length*4]

                # prepare completion TLP(s)
                m = 0
                n = 0
                addr = tlp.address+tlp.get_first_be_offset()
                dw_length = tlp.length
                byte_length = tlp.get_be_byte_count()

                while m < dw_length:
                    cpl = Tlp.create_completion_data_for_tlp(tlp, PcieId(0, 0, 0))

                    cpl_dw_length = dw_length - m
                    cpl_byte_length = byte_length - n
                    cpl.byte_count = cpl_byte_length
                    if cpl_dw_length > 32 << self.dev_max_payload:
                        # max payload size
                        cpl_dw_length = 32 << self.dev_max_payload
                        # RCB align
                        cpl_dw_length -= (addr & 0x7c) >> 2

                    cpl.lower_address = addr & 0x7f

                    cpl.set_data(data[m*4:(m+cpl_dw_length)*4])

                    self.log.debug("Completion: %s", repr(cpl))
                    await self.tx_source.send(PTilePcieFrame.from_tlp(cpl))

                    m += cpl_dw_length
                    n += cpl_dw_length*4 - (addr & 3)
                    addr += cpl_dw_length*4 - (addr & 3)

            elif tlp.fmt_type in {TlpType.MEM_WRITE, TlpType.MEM_WRITE_64}:
                self.log.info("Memory write")

                # perform operation
                region = frame.bar_range
                addr = tlp.address % len(self.regions[region])
                offset = 0
                start_offset = None
                mask = tlp.first_be
                length = tlp.length

                # perform write
                data = tlp.get_data()

                # first dword
                for k in range(4):
                    if mask & (1 << k):
                        if start_offset is None:
                            start_offset = offset
                    else:
                        if start_offset is not None and offset != start_offset:
                            self.regions[region][addr+start_offset:addr+offset] = data[start_offset:offset]
                        start_offset = None

                    offset += 1

                if length > 2:
                    # middle dwords
                    if start_offset is None:
                        start_offset = offset
                    offset += (length-2)*4

                if length > 1:
                    # last dword
                    mask = tlp.last_be

                    for k in range(4):
                        if mask & (1 << k):
                            if start_offset is None:
                                start_offset = offset
                        else:
                            if start_offset is not None and offset != start_offset:
                                self.regions[region][addr+start_offset:addr+offset] = data[start_offset:offset]
                            start_offset = None

                        offset += 1

                if start_offset is not None and offset != start_offset:
                    self.regions[region][addr+start_offset:addr+offset] = data[start_offset:offset]

    async def _run_cfg(self):
        while True:
            await RisingEdge(self.dut.coreclkout_hip)

            if self.dut.tl_cfg_func.value.integer == 0:
                addr = self.dut.tl_cfg_add.value.integer
                ctl = self.dut.tl_cfg_ctl.value.integer
                if addr == 0x00:
                    self.dev_max_payload = ctl & 0x7
                    self.dev_max_read_req = (ctl >> 3) & 0x7
                elif addr == 0x01:
                    self.dev_bus_num = ctl & 0xff
                    self.dev_device_num = (ctl >> 8) & 0x1f
                elif addr == 0x06:
                    self.dev_msi_address = (self.dev_msi_address & ~(0xffff << 0)) | ctl << 0
                elif addr == 0x07:
                    self.dev_msi_address = (self.dev_msi_address & ~(0xffff << 16)) | ctl << 16
                elif addr == 0x08:
                    self.dev_msi_address = (self.dev_msi_address & ~(0xffff << 32)) | ctl << 32
                elif addr == 0x09:
                    self.dev_msi_address = (self.dev_msi_address & ~(0xffff << 48)) | ctl << 48
                elif addr == 0x0A:
                    self.dev_msi_mask = (self.dev_msi_mask & ~(0xffff << 0)) | ctl << 0
                elif addr == 0x0B:
                    self.dev_msi_mask = (self.dev_msi_mask & ~(0xffff << 16)) | ctl << 16
                elif addr == 0x0C:
                    self.dev_msi_enable = ctl & 1
                    self.dev_msi_multi_msg_enable = (ctl >> 2) & 0x7
                    self.dev_msix_enable = (ctl >> 5) & 1
                    self.dev_msix_function_mask = (ctl >> 6) & 1
                elif addr == 0x0D:
                    self.dev_msi_data = (self.dev_msi_data & ~(0xffff << 0)) | ctl << 0
                elif addr == 0x1D:
                    self.dev_msi_data = (self.dev_msi_data & ~(0xffff << 16)) | ctl << 16


async def run_test_mem(dut, idle_inserter=None, backpressure_inserter=None):

    tb = TB(dut)

    tb.set_idle_generator(idle_inserter)
    tb.set_backpressure_generator(backpressure_inserter)

    await RisingEdge(dut.reset_status_n)
    await Timer(100, 'ns')

    await tb.rc.enumerate()

    dev = tb.rc.find_device(tb.dev.functions[0].pcie_id)
    await dev.enable_device()

    dev_bar0 = dev.bar_window[0]
    dev_bar1 = dev.bar_window[1]
    dev_bar3 = dev.bar_window[3]

    for length in list(range(0, 8)):
        for offset in list(range(8)):
            tb.log.info("IO operation length: %d offset: %d", length, offset)
            test_data = bytearray([x % 256 for x in range(length)])

            await dev_bar3.write(offset, test_data, timeout=5000)
            assert tb.regions[3][offset:offset+length] == test_data

            assert await dev_bar3.read(offset, length, timeout=5000) == test_data

    for length in list(range(0, 32))+[1024]:
        for offset in list(range(8))+list(range(4096-8, 4096)):
            tb.log.info("Memory operation (32-bit BAR) length: %d offset: %d", length, offset)
            test_data = bytearray([x % 256 for x in range(length)])

            await dev_bar0.write(offset, test_data, timeout=100)
            # wait for write to complete
            await dev_bar0.read(offset, 0, timeout=5000)
            assert tb.regions[0][offset:offset+length] == test_data

            assert await dev_bar0.read(offset, length, timeout=5000) == test_data

    for length in list(range(0, 32))+[1024]:
        for offset in list(range(8))+list(range(4096-8, 4096)):
            tb.log.info("Memory operation (64-bit BAR) length: %d offset: %d", length, offset)
            test_data = bytearray([x % 256 for x in range(length)])

            await dev_bar1.write(offset, test_data, timeout=100)
            # wait for write to complete
            await dev_bar1.read(offset, 0, timeout=5000)
            assert tb.regions[1][offset:offset+length] == test_data

            assert await dev_bar1.read(offset, length, timeout=5000) == test_data

    await RisingEdge(dut.coreclkout_hip)
    await RisingEdge(dut.coreclkout_hip)


async def run_test_dma(dut, idle_inserter=None, backpressure_inserter=None):

    tb = TB(dut)

    mem = tb.rc.mem_pool.alloc_region(16*1024*1024)
    mem_base = mem.get_absolute_address(0)

    io = tb.rc.io_pool.alloc_region(1024)
    io_base = io.get_absolute_address(0)

    tb.set_idle_generator(idle_inserter)
    tb.set_backpressure_generator(backpressure_inserter)

    await RisingEdge(dut.reset_status_n)
    await Timer(100, 'ns')

    await tb.rc.enumerate()

    dev = tb.rc.find_device(tb.dev.functions[0].pcie_id)
    await dev.enable_device()
    await dev.set_master()

    for length in list(range(0, 32))+[1024]:
        for offset in list(range(8))+list(range(4096-8, 4096)):
            tb.log.info("Memory operation (DMA) length: %d offset: %d", length, offset)
            addr = mem_base+offset
            test_data = bytearray([x % 256 for x in range(length)])

            await tb.dma_mem_write(addr, test_data, 5000, 'ns')
            # wait for write to complete
            await tb.dma_mem_read(addr, 0, 5000, 'ns')
            assert mem[offset:offset+length] == test_data

            assert await tb.dma_mem_read(addr, length, 5000, 'ns') == test_data

    for length in list(range(0, 8)):
        for offset in list(range(8)):
            tb.log.info("IO operation (DMA) length: %d offset: %d", length, offset)
            addr = io_base+offset
            test_data = bytearray([x % 256 for x in range(length)])

            await tb.dma_io_write(addr, test_data, 5000, 'ns')
            assert io[offset:offset+length] == test_data

            assert await tb.dma_io_read(addr, length, 5000, 'ns') == test_data

    await RisingEdge(dut.coreclkout_hip)
    await RisingEdge(dut.coreclkout_hip)


async def run_test_msi(dut, idle_inserter=None, backpressure_inserter=None):

    tb = TB(dut)

    tb.set_idle_generator(idle_inserter)
    tb.set_backpressure_generator(backpressure_inserter)

    await RisingEdge(dut.reset_status_n)
    await Timer(100, 'ns')

    await tb.rc.enumerate()

    dev = tb.rc.find_device(tb.dev.functions[0].pcie_id)
    await dev.enable_device()
    await dev.set_master()
    await dev.alloc_irq_vectors(32, 32)

    await Timer(100, 'ns')
    assert tb.dev_msi_enable

    for k in range(32):
        tb.log.info("Send MSI %d", k)

        data = tb.dev_msi_data & ~(2**tb.dev_msi_multi_msg_enable-1) | k
        await tb.dma_mem_write(tb.dev_msi_address, struct.pack('<L', data))

        event = dev.msi_vectors[k].event
        event.clear()
        await event.wait()

    await RisingEdge(dut.coreclkout_hip)
    await RisingEdge(dut.coreclkout_hip)


async def run_test_msix(dut, idle_inserter=None, backpressure_inserter=None):

    tb = TB(dut, msix=True)

    tb.set_idle_generator(idle_inserter)
    tb.set_backpressure_generator(backpressure_inserter)

    await RisingEdge(dut.reset_status_n)
    await Timer(100, 'ns')

    await tb.rc.enumerate()

    dev = tb.rc.find_device(tb.dev.functions[0].pcie_id)
    await dev.enable_device()
    await dev.set_master()
    await dev.alloc_irq_vectors(64, 64)

    await Timer(100, 'ns')
    assert tb.dev_msix_enable

    for k in range(64):
        tb.log.info("Send MSI %d", k)

        addr = int.from_bytes(tb.regions[4][16*k+0:16*k+8], 'little')
        data = int.from_bytes(tb.regions[4][16*k+8:16*k+12], 'little')

        await tb.dma_mem_write(addr, data.to_bytes(4, 'little'), 5000, 'ns')

        event = dev.msi_vectors[k].event
        event.clear()
        await event.wait()

    await RisingEdge(dut.coreclkout_hip)
    await RisingEdge(dut.coreclkout_hip)


def cycle_pause():
    return itertools.cycle([1, 1, 1, 0])


if cocotb.SIM_NAME:

    for test in [
                run_test_mem,
                run_test_dma,
                run_test_msi,
                run_test_msix,
            ]:

        factory = TestFactory(test)
        factory.add_option(("idle_inserter", "backpressure_inserter"), [(None, None), (cycle_pause, cycle_pause)])
        factory.generate_tests()


# cocotb-test

tests_dir = os.path.dirname(__file__)


@pytest.mark.parametrize("data_width", [128, 256, 512])
def test_pcie_ptile(request, data_width):
    dut = "test_pcie_ptile"
    module = os.path.splitext(os.path.basename(__file__))[0]
    toplevel = dut

    verilog_sources = [
        os.path.join(tests_dir, f"{dut}.v"),
    ]

    parameters = {}

    parameters['SEG_COUNT'] = 2 if data_width == 512 else 1
    parameters['SEG_DATA_WIDTH'] = data_width // parameters['SEG_COUNT']
    parameters['SEG_HDR_WIDTH'] = 128
    parameters['SEG_PRFX_WIDTH'] = 32
    parameters['SEG_DATA_PAR_WIDTH'] = parameters['SEG_DATA_WIDTH'] // 8
    parameters['SEG_HDR_PAR_WIDTH'] = parameters['SEG_HDR_WIDTH'] // 8
    parameters['SEG_PRFX_PAR_WIDTH'] = parameters['SEG_PRFX_WIDTH'] // 8
    parameters['SEG_EMPTY_WIDTH'] = ((parameters['SEG_DATA_WIDTH'] // 32) - 1).bit_length()

    extra_env = {f'PARAM_{k}': str(v) for k, v in parameters.items()}

    sim_build = os.path.join(tests_dir, "sim_build",
        request.node.name.replace('[', '-').replace(']', ''))

    cocotb_test.simulator.run(
        python_search=[tests_dir],
        verilog_sources=verilog_sources,
        toplevel=toplevel,
        module=module,
        parameters=parameters,
        sim_build=sim_build,
        extra_env=extra_env,
    )



================================================
FILE: tests/pcie_ptile/test_pcie_ptile.v
================================================
/*

Copyright (c) 2022 Alex Forencich

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

// Language: Verilog 2001

`resetall
`timescale 1ns / 1ns
`default_nettype none

/*
 * Intel P-Tile PCIe IP core model test module
 */
module test_pcie_ptile #
(
    parameter SEG_COUNT = 1,
    parameter SEG_DATA_WIDTH = 128,
    parameter SEG_HDR_WIDTH = 128,
    parameter SEG_PRFX_WIDTH = 32,
    parameter SEG_DATA_PAR_WIDTH = SEG_DATA_WIDTH/8,
    parameter SEG_HDR_PAR_WIDTH = SEG_HDR_WIDTH/8,
    parameter SEG_PRFX_PAR_WIDTH = SEG_PRFX_WIDTH/8,
    parameter SEG_EMPTY_WIDTH = $clog2(SEG_DATA_WIDTH/32)
)
(
    // Clock and reset
    output wire                                     reset_status_n,
    output wire                                     coreclkout_hip,
    input  wire                                     refclk0,
    input  wire                                     refclk1,
    input  wire                                     pin_perst_n,
    // RX interface
    output wire [SEG_COUNT*SEG_DATA_WIDTH-1:0]      rx_st_data,
    output wire [SEG_COUNT*SEG_EMPTY_WIDTH-1:0]     rx_st_empty,
    output wire [SEG_COUNT-1:0]                     rx_st_sop,
    output wire [SEG_COUNT-1:0]                     rx_st_eop,
    output wire [SEG_COUNT-1:0]                     rx_st_valid,
    input  wire                                     rx_st_ready,
    output wire [SEG_COUNT*SEG_HDR_WIDTH-1:0]       rx_st_hdr,
    output wire [SEG_COUNT*SEG_PRFX_WIDTH-1:0]      rx_st_tlp_prfx,
    output wire [SEG_COUNT-1:0]                     rx_st_vf_active,
    output wire [SEG_COUNT*3-1:0]                   rx_st_func_num,
    output wire [SEG_COUNT*11-1:0]                  rx_st_vf_num,
    output wire [SEG_COUNT*3-1:0]                   rx_st_bar_range,
    output wire [SEG_COUNT-1:0]                     rx_st_tlp_abort,
    output wire [SEG_COUNT*SEG_DATA_PAR_WIDTH-1:0]  rx_st_data_par,
    output wire [SEG_COUNT*SEG_HDR_PAR_WIDTH-1:0]   rx_st_hdr_par,
    output wire [SEG_COUNT*SEG_PRFX_PAR_WIDTH-1:0]  rx_st_tlp_prfx_par,
    output wire                                     rx_par_err,
    // TX interface
    input  wire [SEG_COUNT*SEG_DATA_WIDTH-1:0]      tx_st_data,
    input  wire [SEG_COUNT-1:0]                     tx_st_sop,
    input  wire [SEG_COUNT-1:0]                     tx_st_eop,
    input  wire [SEG_COUNT-1:0]                     tx_st_valid,
    output wire                                     tx_st_ready,
    input  wire [SEG_COUNT-1:0]                     tx_st_err,
    input  wire [SEG_COUNT*SEG_HDR_WIDTH-1:0]       tx_st_hdr,
    input  wire [SEG_COUNT*SEG_PRFX_WIDTH-1:0]      tx_st_tlp_prfx,
    input  wire [SEG_COUNT*SEG_DATA_PAR_WIDTH-1:0]  tx_st_data_par,
    input  wire [SEG_COUNT*SEG_HDR_PAR_WIDTH-1:0]   tx_st_hdr_par,
    input  wire [SEG_COUNT*SEG_PRFX_PAR_WIDTH-1:0]  tx_st_tlp_prfx_par,
    output wire                                     tx_par_err,
    // RX flow control
    input  wire [11:0]                              rx_buffer_limit,
    input  wire [1:0]                               rx_buffer_limit_tdm_idx,
    // TX flow control
    output wire [15:0]                              tx_cdts_limit,
    output wire [2:0]                               tx_cdts_limit_tdm_idx,
    // Power management and hard IP status interface
    output wire                                     link_up,
    output wire                                     dl_up,
    output wire                                     surprise_down_err,
    output wire [5:0]                               ltssm_state,
    output wire [2:0]                               pm_state,
    output wire [31:0]                              pm_dstate,
    input  wire [7:0]                               apps_pm_xmt_pme,
    input  wire [7:0]                               app_req_retry_en,
    // Interrupt interface
    input  wire [7:0]                               app_int,
    input  wire [2:0]                               msi_pnd_func,
    input  wire [7:0]                               msi_pnd_byte,
    input  wire [1:0]                               msi_pnd_addr,
    // Error interface
    output wire                                     serr_out,
    output wire                                     hip_enter_err_mode,
    input  wire                                     app_err_valid,
    input  wire [31:0]                              app_err_hdr,
    input  wire [12:0]                              app_err_info,
    input  wire [2:0]                               app_err_func_num,
    // Completion timeout interface
    output wire                                     cpl_timeout,
    input  wire                                     cpl_timeout_avmm_clk,
    input  wire [2:0]                               cpl_timeout_avmm_address,
    input  wire                                     cpl_timeout_avmm_read,
    output wire [7:0]                               cpl_timeout_avmm_readdata,
    output wire                                     cpl_timeout_avmm_readdatavalid,
    input  wire                                     cpl_timeout_avmm_write,
    input  wire [7:0]                               cpl_timeout_avmm_writedata,
    output wire                                     cpl_timeout_avmm_waitrequest,
    // Configuration output
    output wire [2:0]                               tl_cfg_func,
    output wire [4:0]                               tl_cfg_add,
    output wire [15:0]                              tl_cfg_ctl,
    output wire                                     dl_timer_update,
    // Configuration intercept interface
    output wire                                     cii_req,
    output wire                                     cii_hdr_poisoned,
    output wire [3:0]                               cii_hdr_first_be,
    output wire [2:0]                               cii_func_num,
    output wire                                     cii_wr_vf_active,
    output wire [10:0]                              cii_vf_num,
    output wire                                     cii_wr,
    output wire [9:0]                               cii_addr,
    output wire [31:0]                              cii_dout,
    input  wire                                     cii_override_en,
    input  wire [31:0]                              cii_override_din,
    input  wire                                     cii_halt,
    // Hard IP reconfiguration interface
    input  wire                                     hip_reconfig_clk,
    input  wire [20:0]                              hip_reconfig_address,
    input  wire                                     hip_reconfig_read,
    output wire [7:0]                               hip_reconfig_readdata,
    output wire                                     hip_reconfig_readdatavalid,
    input  wire                                     hip_reconfig_write,
    input  wire [7:0]                               hip_reconfig_writedata,
    output wire                                     hip_reconfig_waitrequest,
    // Page request service
    input  wire                                     prs_event_valid,
    input  wire [2:0]                               prs_event_func,
    input  wire [1:0]                               prs_event,
    // SR-IOV (VF error)
    output wire                                     vf_err_ur_posted_s0,
    output wire                                     vf_err_ur_posted_s1,
    output wire                                     vf_err_ur_posted_s2,
    output wire                                     vf_err_ur_posted_s3,
    output wire [2:0]                               vf_err_func_num_s0,
    output wire [2:0]                               vf_err_func_num_s1,
    output wire [2:0]                               vf_err_func_num_s2,
    output wire [2:0]                               vf_err_func_num_s3,
    output wire                                     vf_err_ca_postedreq_s0,
    output wire                                     vf_err_ca_postedreq_s1,
    output wire                                     vf_err_ca_postedreq_s2,
    output wire                                     vf_err_ca_postedreq_s3,
    output wire [10:0]                              vf_err_vf_num_s0,
    output wire [10:0]                              vf_err_vf_num_s1,
    output wire [10:0]                              vf_err_vf_num_s2,
    output wire [10:0]                              vf_err_vf_num_s3,
    output wire                                     vf_err_poisonedwrreq_s0,
    output wire                                     vf_err_poisonedwrreq_s1,
    output wire                                     vf_err_poisonedwrreq_s2,
    output wire                                     vf_err_poisonedwrreq_s3,
    output wire                                     vf_err_poisonedcompl_s0,
    output wire                                     vf_err_poisonedcompl_s1,
    output wire                                     vf_err_poisonedcompl_s2,
    output wire                                     vf_err_poisonedcompl_s3,
    input  wire [2:0]                               user_vfnonfatalmsg_func_num,
    input  wire [10:0]                              user_vfnonfatalmsg_vfnum,
    input  wire                                     user_sent_vfnonfatalmsg,
    output wire                                     vf_err_overflow,
    // FLR
    output wire [7:0]                               flr_rcvd_pf,
    output wire                                     flr_rcvd_vf,
    output wire [2:0]                               flr_rcvd_pf_num,
    output wire [10:0]                              flr_rcvd_vf_num,
    input  wire [7:0]                               flr_completed_pf,
    input  wire                                     flr_completed_vf,
    input  wire [2:0]                               flr_completed_pf_num,
    input  wire [10:0]                              flr_completed_vf_num,
    // VirtIO
    output wire                                     virtio_pcicfg_vfaccess,
    output wire [10:0]                              virtio_pcicfg_vfnum,
    output wire [2:0]                               virtio_pcicfg_pfnum,
    output wire [7:0]                               virtio_pcicfg_bar,
    output wire [31:0]                              virtio_pcicfg_length,
    output wire [31:0]                              virtio_pcicfg_baroffset,
    output wire [31:0]                              virtio_pcicfg_cfgdata,
    output wire                                     virtio_pcicfg_cfgwr,
    output wire                                     virtio_pcicfg_cfgrd,
    input  wire [10:0]                              virtio_pcicfg_appvfnum,
    input  wire [2:0]                               virtio_pcicfg_apppfnum,
    input  wire                                     virtio_pcicfg_rdack,
    input  wire [3:0]                               virtio_pcicfg_rdbe,
    input  wire [31:0]                              virtio_pcicfg_data
);

endmodule

`resetall



================================================
FILE: tests/pcie_s10/Makefile
================================================
# Copyright (c) 2021 Alex Forencich
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

TOPLEVEL_LANG = verilog

SIM ?= icarus
WAVES ?= 0

COCOTB_HDL_TIMEUNIT = 1ns
COCOTB_HDL_TIMEPRECISION = 1ps

DUT      = test_pcie_s10
TOPLEVEL = $(DUT)
MODULE   = $(DUT)
VERILOG_SOURCES  = $(DUT).v

# module parameters
export PARAM_SEG_COUNT := 1
export PARAM_SEG_DATA_WIDTH := 256
export PARAM_SEG_PARITY_WIDTH := $(shell expr $(PARAM_SEG_DATA_WIDTH) / 8 )
export PARAM_SEG_EMPTY_WIDTH := $(shell python -c "print((($(PARAM_SEG_DATA_WIDTH)//32)-1).bit_length())" )

ifeq ($(SIM), icarus)
	PLUSARGS += -fst

	COMPILE_ARGS += $(foreach v,$(filter PARAM_%,$(.VARIABLES)),-P $(TOPLEVEL).$(subst PARAM_,,$(v))=$($(v)))

	ifeq ($(WAVES), 1)
		VERILOG_SOURCES += iverilog_dump.v
		COMPILE_ARGS += -s iverilog_dump
	endif
else ifeq ($(SIM), verilator)
	COMPILE_ARGS += -Wno-SELRANGE -Wno-WIDTH

	COMPILE_ARGS += $(foreach v,$(filter PARAM_%,$(.VARIABLES)),-G$(subst PARAM_,,$(v))=$($(v)))

	ifeq ($(WAVES), 1)
		COMPILE_ARGS += --trace-fst
	endif
endif

include $(shell cocotb-config --makefiles)/Makefile.sim

iverilog_dump.v:
	echo 'module iverilog_dump();' > $@
	echo 'initial begin' >> $@
	echo '    $$dumpfile("$(TOPLEVEL).fst");' >> $@
	echo '    $$dumpvars(0, $(TOPLEVEL));' >> $@
	echo 'end' >> $@
	echo 'endmodule' >> $@

clean::
	@rm -rf iverilog_dump.v
	@rm -rf dump.fst $(TOPLEVEL).fst



================================================
FILE: tests/pcie_s10/test_pcie_s10.py
================================================
#!/usr/bin/env python
"""

Copyright (c) 2021 Alex Forencich

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

"""

import itertools
import logging
import mmap
import os

import cocotb_test.simulator
import pytest

import cocotb
from cocotb.queue import Queue
from cocotb.triggers import RisingEdge, FallingEdge, Timer, Event, First
from cocotb.regression import TestFactory

from cocotbext.pcie.core import RootComplex
from cocotbext.pcie.intel.s10 import S10PcieDevice, S10RxBus, S10TxBus
from cocotbext.pcie.intel.s10.interface import S10PcieFrame, S10PcieSource, S10PcieSink
from cocotbext.pcie.core.tlp import Tlp, TlpType, CplStatus
from cocotbext.pcie.core.utils import PcieId


class TB:
    def __init__(self, dut, msix=False):
        self.dut = dut

        self.log = logging.getLogger("cocotb.tb")
        self.log.setLevel(logging.DEBUG)

        # PCIe
        self.rc = RootComplex()

        self.dev = S10PcieDevice(
            # configuration options
            pcie_generation=3,
            # pcie_link_width=2,
            # pld_clk_frequency=250e6,
            l_tile=False,
            pf_count=1,
            max_payload_size=128,
            enable_extended_tag=False,

            pf0_msi_enable=True,
            pf0_msi_count=32,
            pf1_msi_enable=False,
            pf1_msi_count=1,
            pf2_msi_enable=False,
            pf2_msi_count=1,
            pf3_msi_enable=False,
            pf3_msi_count=1,
            pf0_msix_enable=msix,
            pf0_msix_table_size=63,
            pf0_msix_table_bir=4,
            pf0_msix_table_offset=0x00000000,
            pf0_msix_pba_bir=4,
            pf0_msix_pba_offset=0x00008000,
            pf1_msix_enable=False,
            pf1_msix_table_size=0,
            pf1_msix_table_bir=0,
            pf1_msix_table_offset=0x00000000,
            pf1_msix_pba_bir=0,
            pf1_msix_pba_offset=0x00000000,
            pf2_msix_enable=False,
            pf2_msix_table_size=0,
            pf2_msix_table_bir=0,
            pf2_msix_table_offset=0x00000000,
            pf2_msix_pba_bir=0,
            pf2_msix_pba_offset=0x00000000,
            pf3_msix_enable=False,
            pf3_msix_table_size=0,
            pf3_msix_table_bir=0,
            pf3_msix_table_offset=0x00000000,
            pf3_msix_pba_bir=0,
            pf3_msix_pba_offset=0x00000000,

            # signals
            # Clock and reset
            npor=dut.npor,
            pin_perst=dut.pin_perst,
            ninit_done=dut.ninit_done,
            pld_clk_inuse=dut.pld_clk_inuse,
            pld_core_ready=dut.pld_core_ready,
            reset_status=dut.reset_status,
            clr_st=dut.clr_st,
            refclk=dut.refclk,
            coreclkout_hip=dut.coreclkout_hip,

            # RX interface
            rx_bus=S10RxBus.from_prefix(dut, "rx_st"),

            # TX interface
            tx_bus=S10TxBus.from_prefix(dut, "tx_st"),

            # TX flow control
            tx_ph_cdts=dut.tx_ph_cdts,
            tx_pd_cdts=dut.tx_pd_cdts,
            tx_nph_cdts=dut.tx_nph_cdts,
            tx_npd_cdts=dut.tx_npd_cdts,
            tx_cplh_cdts=dut.tx_cplh_cdts,
            tx_cpld_cdts=dut.tx_cpld_cdts,
            tx_hdr_cdts_consumed=dut.tx_hdr_cdts_consumed,
            tx_data_cdts_consumed=dut.tx_data_cdts_consumed,
            tx_cdts_type=dut.tx_cdts_type,
            tx_cdts_data_value=dut.tx_cdts_data_value,

            # Hard IP status
            int_status=dut.int_status,
            int_status_common=dut.int_status_common,
            derr_cor_ext_rpl=dut.derr_cor_ext_rpl,
            derr_rpl=dut.derr_rpl,
            derr_cor_ext_rcv=dut.derr_cor_ext_rcv,
            derr_uncor_ext_rcv=dut.derr_uncor_ext_rcv,
            rx_par_err=dut.rx_par_err,
            tx_par_err=dut.tx_par_err,
            ltssmstate=dut.ltssmstate,
            link_up=dut.link_up,
            lane_act=dut.lane_act,
            currentspeed=dut.currentspeed,

            # Power management
            pm_linkst_in_l1=dut.pm_linkst_in_l1,
            pm_linkst_in_l0s=dut.pm_linkst_in_l0s,
            pm_state=dut.pm_state,
            pm_dstate=dut.pm_dstate,
            apps_pm_xmt_pme=dut.apps_pm_xmt_pme,
            apps_ready_entr_l23=dut.apps_ready_entr_l23,
            apps_pm_xmt_turnoff=dut.apps_pm_xmt_turnoff,
            app_init_rst=dut.app_init_rst,
            app_xfer_pending=dut.app_xfer_pending,

            # Interrupt interface
            app_msi_req=dut.app_msi_req,
            app_msi_ack=dut.app_msi_ack,
            app_msi_tc=dut.app_msi_tc,
            app_msi_num=dut.app_msi_num,
            app_msi_func_num=dut.app_msi_func_num,
            app_int_sts=dut.app_int_sts,

            # Error interface
            app_err_valid=dut.app_err_valid,
            app_err_hdr=dut.app_err_hdr,
            app_err_info=dut.app_err_info,
            app_err_func_num=dut.app_err_func_num,

            # Configuration output
            tl_cfg_func=dut.tl_cfg_func,
            tl_cfg_add=dut.tl_cfg_add,
            tl_cfg_ctl=dut.tl_cfg_ctl,

            # Configuration extension bus
            ceb_req=dut.ceb_req,
            ceb_ack=dut.ceb_ack,
            ceb_addr=dut.ceb_addr,
            ceb_din=dut.ceb_din,
            ceb_dout=dut.ceb_dout,
            ceb_wr=dut.ceb_wr,
            ceb_cdm_convert_data=dut.ceb_cdm_convert_data,
            ceb_func_num=dut.ceb_func_num,
            ceb_vf_num=dut.ceb_vf_num,
            ceb_vf_active=dut.ceb_vf_active,

            # Hard IP reconfiguration interface
            hip_reconfig_clk=dut.hip_reconfig_clk,
            hip_reconfig_address=dut.hip_reconfig_address,
            hip_reconfig_read=dut.hip_reconfig_read,
            hip_reconfig_readdata=dut.hip_reconfig_readdata,
            hip_reconfig_readdatavalid=dut.hip_reconfig_readdatavalid,
            hip_reconfig_write=dut.hip_reconfig_write,
            hip_reconfig_writedata=dut.hip_reconfig_writedata,
            hip_reconfig_waitrequest=dut.hip_reconfig_waitrequest,
        )

        self.dev.log.setLevel(logging.DEBUG)

        dut.npor.setimmediatevalue(1)
        dut.pin_perst.setimmediatevalue(1)
        dut.ninit_done.setimmediatevalue(0)
        dut.pld_core_ready.setimmediatevalue(1)
        dut.refclk.setimmediatevalue(0)
        dut.apps_pm_xmt_pme.setimmediatevalue(0)
        dut.apps_ready_entr_l23.setimmediatevalue(0)
        dut.apps_pm_xmt_turnoff.setimmediatevalue(0)
        dut.app_init_rst.setimmediatevalue(0)
        dut.app_xfer_pending.setimmediatevalue(0)
        dut.app_msi_req.setimmediatevalue(0)
        dut.app_msi_tc.setimmediatevalue(0)
        dut.app_msi_num.setimmediatevalue(0)
        dut.app_msi_func_num.setimmediatevalue(0)
        dut.app_int_sts.setimmediatevalue(0)
        dut.app_err_valid.setimmediatevalue(0)
        dut.app_err_hdr.setimmediatevalue(0)
        dut.app_err_info.setimmediatevalue(0)
        dut.app_err_func_num.setimmediatevalue(0)
        dut.ceb_ack.setimmediatevalue(0)
        dut.ceb_din.setimmediatevalue(0)
        dut.ceb_cdm_convert_data.setimmediatevalue(0)
        dut.hip_reconfig_clk.setimmediatevalue(0)
        dut.hip_reconfig_rst_n.setimmediatevalue(1)
        dut.hip_reconfig_address.setimmediatevalue(0)
        dut.hip_reconfig_read.setimmediatevalue(0)
        dut.hip_reconfig_write.setimmediatevalue(0)
        dut.hip_reconfig_writedata.setimmediatevalue(0)

        self.rc.make_port().connect(self.dev)

        # user logic
        self.tx_source = S10PcieSource(S10TxBus.from_prefix(dut, "tx_st"), dut.coreclkout_hip)
        self.tx_source.ready_latency = 3
        self.rx_sink = S10PcieSink(S10RxBus.from_prefix(dut, "rx_st"), dut.coreclkout_hip)
        self.rx_sink.ready_latency = 18 if self.tx_source.width == 512 else 17

        self.regions = [None]*6
        self.regions[0] = mmap.mmap(-1, 1024*1024)
        self.regions[1] = mmap.mmap(-1, 1024*1024)
        self.regions[3] = mmap.mmap(-1, 1024)
        self.regions[4] = mmap.mmap(-1, 1024*64)

        self.current_tag = 0
        self.tag_count = 256
        self.tag_active = [False]*256
        self.tag_release = Event()

        self.rx_cpl_queues = [Queue() for k in range(256)]
        self.rx_cpl_sync = [Event() for k in range(256)]

        self.dev_bus_num = 0
        self.dev_device_num = 0
        self.dev_max_payload = 0
        self.dev_max_read_req = 0
        self.dev_msi_enable = 0
        self.dev_msi_multi_msg_enable = 0
        self.dev_msi_address = 0
        self.dev_msi_data = 0
        self.dev_msi_mask = 0
        self.dev.msix_enable = 0
        self.dev.msix_function_mask = 0

        self.dev.functions[0].configure_bar(0, len(self.regions[0]))
        self.dev.functions[0].configure_bar(1, len(self.regions[1]), True, True)
        self.dev.functions[0].configure_bar(3, len(self.regions[3]), False, False, True)
        self.dev.functions[0].configure_bar(4, len(self.regions[4]))

        cocotb.start_soon(self._run_rx_tlp())
        cocotb.start_soon(self._run_cfg())

    def set_idle_generator(self, generator=None):
        if generator:
            self.dev.rx_source.set_pause_generator(generator())

    def set_backpressure_generator(self, generator=None):
        if generator:
            self.dev.tx_sink.set_pause_generator(generator())

    async def recv_cpl(self, tag, timeout=0, timeout_unit='ns'):
        queue = self.rx_cpl_queues[tag]
        sync = self.rx_cpl_sync[tag]

        if not queue.empty():
            return queue.get_nowait()

        sync.clear()
        if timeout:
            await First(sync.wait(), Timer(timeout, timeout_unit))
        else:
            await sync.wait()

        if not queue.empty():
            return queue.get_nowait()

        return None

    async def alloc_tag(self):
        tag_count = min(256 if self.dev.functions[0].pcie_cap.extended_tag_field_enable else 32, self.tag_count)

        while True:
            tag = self.current_tag
            for k in range(tag_count):
                tag = (tag + 1) % tag_count
                if not self.tag_active[tag]:
                    self.tag_active[tag] = True
                    self.current_tag = tag
                    return tag

            self.tag_release.clear()
            await self.tag_release.wait()

    def release_tag(self, tag):
        assert self.tag_active[tag]
        self.tag_active[tag] = False
        self.tag_release.set()

    async def perform_posted_operation(self, req):
        await self.tx_source.send(S10PcieFrame.from_tlp(req))

    async def perform_nonposted_operation(self, req, timeout=0, timeout_unit='ns'):
        completions = []

        req.tag = await self.alloc_tag()

        await self.tx_source.send(S10PcieFrame.from_tlp(req))

        while True:
            cpl = await self.recv_cpl(req.tag, timeout, timeout_unit)

            if not cpl:
                break

            completions.append(cpl)

            if cpl.status != CplStatus.SC:
                # bad status
                break
            elif req.fmt_type in {TlpType.MEM_READ, TlpType.MEM_READ_64}:
                # completion for memory read request

                # request completed
                if cpl.byte_count <= cpl.length*4 - (cpl.lower_address & 0x3):
                    break

                # completion for read request has SC status but no data
                if cpl.fmt_type in {TlpType.CPL, TlpType.CPL_LOCKED}:
                    break

            else:
                # completion for other request
                break

        self.release_tag(req.tag)

        return completions

    async def dma_io_write(self, addr, data, timeout=0, timeout_unit='ns'):
        n = 0

        zero_len = len(data) == 0
        if zero_len:
            data = b'\x00'

        op_list = []

        while n < len(data):
            req = Tlp()
            req.fmt_type = TlpType.IO_WRITE
            req.requester_id = PcieId(self.dev_bus_num, self.dev_device_num, 0)

            first_pad = addr % 4
            byte_length = min(len(data)-n, 4-first_pad)
            req.set_addr_be_data(addr, data[n:n+byte_length])

            if zero_len:
                req.first_be = 0

            op_list.append(cocotb.start_soon(self.perform_nonposted_operation(req, timeout, timeout_unit)))

            n += byte_length
            addr += byte_length

        for op in op_list:
            cpl_list = await op.join()

            if not cpl_list:
                raise Exception("Timeout")
            if cpl_list[0].status != CplStatus.SC:
                raise Exception("Unsuccessful completion")

    async def dma_io_read(self, addr, length, timeout=0, timeout_unit='ns'):
        data = bytearray()
        n = 0

        zero_len = length <= 0
        if zero_len:
            length = 1

        op_list = []

        while n < length:
            req = Tlp()
            req.fmt_type = TlpType.IO_READ
            req.requester_id = PcieId(self.dev_bus_num, self.dev_device_num, 0)

            first_pad = addr % 4
            byte_length = min(length-n, 4-first_pad)
            req.set_addr_be(addr, byte_length)

            if zero_len:
                req.first_be = 0

            op_list.append((first_pad, cocotb.start_soon(self.perform_nonposted_operation(req, timeout, timeout_unit))))

            n += byte_length
            addr += byte_length

        for first_pad, op in op_list:
            cpl_list = await op.join()

            if not cpl_list:
                raise Exception("Timeout")
            cpl = cpl_list[0]
            if cpl.status != CplStatus.SC:
                raise Exception("Unsuccessful completion")

            assert cpl.length == 1
            d = cpl.get_data()

            data.extend(d[first_pad:])

        if zero_len:
            return b''

        return bytes(data[:length])

    async def dma_mem_write(self, addr, data, timeout=0, timeout_unit='ns'):
        n = 0

        zero_len = len(data) == 0
        if zero_len:
            data = b'\x00'

        while n < len(data):
            req = Tlp()
            if addr > 0xffffffff:
                req.fmt_type = TlpType.MEM_WRITE_64
            else:
                req.fmt_type = TlpType.MEM_WRITE
            req.requester_id = PcieId(self.dev_bus_num, self.dev_device_num, 0)

            first_pad = addr % 4
            byte_length = len(data)-n
            # max payload size
            byte_length = min(byte_length, (128 << self.dev_max_payload)-first_pad)
            # 4k address align
            byte_length = min(byte_length, 0x1000 - (addr & 0xfff))
            req.set_addr_be_data(addr, data[n:n+byte_length])

            if zero_len:
                req.first_be = 0

            await self.perform_posted_operation(req)

            n += byte_length
            addr += byte_length

    async def dma_mem_read(self, addr, length, timeout=0, timeout_unit='ns'):
        data = bytearray()
        n = 0

        zero_len = length <= 0
        if zero_len:
            length = 1

        op_list = []

        while n < length:
            req = Tlp()
            if addr > 0xffffffff:
                req.fmt_type = TlpType.MEM_READ_64
            else:
                req.fmt_type = TlpType.MEM_READ
            req.requester_id = PcieId(self.dev_bus_num, self.dev_device_num, 0)

            first_pad = addr % 4
            # remaining length
            byte_length = length-n
            # limit to max read request size
            if byte_length > (128 << self.dev_max_read_req) - first_pad:
                # split on 128-byte read completion boundary
                byte_length = min(byte_length, (128 << self.dev_max_read_req) - (addr & 0x7f))
            # 4k align
            byte_length = min(byte_length, 0x1000 - (addr & 0xfff))
            req.set_addr_be(addr, byte_length)

            if zero_len:
                req.first_be = 0

            op_list.append((byte_length, cocotb.start_soon(self.perform_nonposted_operation(req, timeout, timeout_unit))))

            n += byte_length
            addr += byte_length

        for byte_length, op in op_list:
            cpl_list = await op.join()

            m = 0

            while m < byte_length:
                if not cpl_list:
                    raise Exception("Timeout")

                cpl = cpl_list.pop(0)

                if cpl.status != CplStatus.SC:
                    raise Exception("Unsuccessful completion")

                assert cpl.byte_count+3+(cpl.lower_address & 3) >= cpl.length*4
                assert cpl.byte_count == max(byte_length - m, 1)

                d = cpl.get_data()

                offset = cpl.lower_address & 3
                data.extend(d[offset:offset+cpl.byte_count])

                m += len(d)-offset

        if zero_len:
            return b''

        return bytes(data[:length])

    async def _run_rx_tlp(self):
        while True:
            frame = await self.rx_sink.recv()

            tlp = frame.to_tlp()

            self.log.debug("RX TLP: %s", repr(tlp))

            if tlp.fmt_type in {TlpType.CPL, TlpType.CPL_DATA, TlpType.CPL_LOCKED, TlpType.CPL_LOCKED_DATA}:
                self.log.info("Completion")

                self.rx_cpl_queues[tlp.tag].put_nowait(tlp)
                self.rx_cpl_sync[tlp.tag].set()

            elif tlp.fmt_type == TlpType.IO_READ:
                self.log.info("IO read")

                cpl = Tlp.create_completion_data_for_tlp(tlp, PcieId(self.dev_bus_num, 0, 0))

                # region = tlp.bar_id
                region = 3
                addr = tlp.address % len(self.regions[region])
                offset = 0
                start_offset = None
                mask = tlp.first_be

                # perform operation
                data = bytearray(4)

                for k in range(4):
                    if mask & (1 << k):
                        if start_offset is None:
                            start_offset = offset
                    else:
                        if start_offset is not None and offset != start_offset:
                            data[start_offset:offset] = self.regions[region][addr+start_offset:addr+offset]
                        start_offset = None

                    offset += 1

                if start_offset is not None and offset != start_offset:
                    data[start_offset:offset] = self.regions[region][addr+start_offset:addr+offset]

                cpl.set_data(data)
                cpl.byte_count = 4
                cpl.length = 1

                self.log.debug("Completion: %s", repr(cpl))
                await self.tx_source.send(S10PcieFrame.from_tlp(cpl))

            elif tlp.fmt_type == TlpType.IO_WRITE:
                self.log.info("IO write")

                cpl = Tlp.create_completion_for_tlp(tlp, PcieId(self.dev_bus_num, 0, 0))

                # region = tlp.bar_id
                region = 3
                addr = tlp.address % len(self.regions[region])
                offset = 0
                start_offset = None
                mask = tlp.first_be

                # perform operation
                data = tlp.get_data()

                for k in range(4):
                    if mask & (1 << k):
                        if start_offset is None:
                            start_offset = offset
                    else:
                        if start_offset is not None and offset != start_offset:
                            self.regions[region][addr+start_offset:addr+offset] = data[start_offset:offset]
                        start_offset = None

                    offset += 1

                if start_offset is not None and offset != start_offset:
                    self.regions[region][addr+start_offset:addr+offset] = data[start_offset:offset]

                self.log.debug("Completion: %s", repr(cpl))
                await self.tx_source.send(S10PcieFrame.from_tlp(cpl))

            elif tlp.fmt_type in {TlpType.MEM_READ, TlpType.MEM_READ_64}:
                self.log.info("Memory read")

                # perform operation
                region = frame.bar_range
                addr = tlp.address % len(self.regions[region])
                offset = 0
                length = tlp.length

                # perform read
                data = self.regions[region][addr:addr+length*4]

                # prepare completion TLP(s)
                m = 0
                n = 0
                addr = tlp.address+tlp.get_first_be_offset()
                dw_length = tlp.length
                byte_length = tlp.get_be_byte_count()

                while m < dw_length:
                    cpl = Tlp.create_completion_data_for_tlp(tlp, PcieId(self.dev_bus_num, 0, 0))

                    cpl_dw_length = dw_length - m
                    cpl_byte_length = byte_length - n
                    cpl.byte_count = cpl_byte_length
                    if cpl_dw_length > 32 << self.dev_max_payload:
                        # max payload size
                        cpl_dw_length = 32 << self.dev_max_payload
                        # RCB align
                        cpl_dw_length -= (addr & 0x7c) >> 2

                    cpl.lower_address = addr & 0x7f

                    cpl.set_data(data[m*4:(m+cpl_dw_length)*4])

                    self.log.debug("Completion: %s", repr(cpl))
                    await self.tx_source.send(S10PcieFrame.from_tlp(cpl))

                    m += cpl_dw_length
                    n += cpl_dw_length*4 - (addr & 3)
                    addr += cpl_dw_length*4 - (addr & 3)

            elif tlp.fmt_type in {TlpType.MEM_WRITE, TlpType.MEM_WRITE_64}:
                self.log.info("Memory write")

                # perform operation
                region = frame.bar_range
                addr = tlp.address % len(self.regions[region])
                offset = 0
                start_offset = None
                mask = tlp.first_be
                length = tlp.length

                # perform write
                data = tlp.get_data()

                # first dword
                for k in range(4):
                    if mask & (1 << k):
                        if start_offset is None:
                            start_offset = offset
                    else:
                        if start_offset is not None and offset != start_offset:
                            self.regions[region][addr+start_offset:addr+offset] = data[start_offset:offset]
                        start_offset = None

                    offset += 1

                if length > 2:
                    # middle dwords
                    if start_offset is None:
                        start_offset = offset
                    offset += (length-2)*4

                if length > 1:
                    # last dword
                    mask = tlp.last_be

                    for k in range(4):
                        if mask & (1 << k):
                            if start_offset is None:
                                start_offset = offset
                        else:
                            if start_offset is not None and offset != start_offset:
                                self.regions[region][addr+start_offset:addr+offset] = data[start_offset:offset]
                            start_offset = None

                        offset += 1

                if start_offset is not None and offset != start_offset:
                    self.regions[region][addr+start_offset:addr+offset] = data[start_offset:offset]

    async def _run_cfg(self):
        while True:
            await RisingEdge(self.dut.coreclkout_hip)

            if self.dut.tl_cfg_func.value.integer == 0:
                addr = self.dut.tl_cfg_add.value.integer
                ctl = self.dut.tl_cfg_ctl.value.integer
                if addr == 0x00:
                    self.dev_max_payload = ctl & 0x7
                    self.dev_max_read_req = (ctl >> 3) & 0x7
                    self.dev_bus_num = (ctl >> 16) & 0xff
                    self.dev_device_num = (ctl >> 24) & 0x1f
                elif addr == 0x03:
                    self.dev_msi_address = (self.dev_msi_address & ~(0xffffffff << 0)) | ctl << 0
                elif addr == 0x04:
                    self.dev_msi_address = (self.dev_msi_address & ~(0xffffffff << 32)) | ctl << 32
                elif addr == 0x05:
                    self.dev_msi_mask = ctl
                elif addr == 0x06:
                    self.dev_msi_enable = ctl & 1
                    self.dev_msi_multi_msg_enable = (ctl >> 2) & 0x7
                    self.dev_msi_data = ctl >> 16
                    self.dev_msix_enable = (ctl >> 5) & 1
                    self.dev_msix_function_mask = (ctl >> 6) & 1


async def run_test_mem(dut, idle_inserter=None, backpressure_inserter=None):

    tb = TB(dut)

    tb.set_idle_generator(idle_inserter)
    tb.set_backpressure_generator(backpressure_inserter)

    await FallingEdge(dut.reset_status)
    await Timer(100, 'ns')

    await tb.rc.enumerate()

    dev = tb.rc.find_device(tb.dev.functions[0].pcie_id)
    await dev.enable_device()

    dev_bar0 = dev.bar_window[0]
    dev_bar1 = dev.bar_window[1]
    dev_bar3 = dev.bar_window[3]

    for length in list(range(0, 8)):
        for offset in list(range(8)):
            tb.log.info("IO operation length: %d offset: %d", length, offset)
            test_data = bytearray([x % 256 for x in range(length)])

            await dev_bar3.write(offset, test_data, timeout=5000)
            assert tb.regions[3][offset:offset+length] == test_data

            assert await dev_bar3.read(offset, length, timeout=5000) == test_data

    for length in list(range(0, 32))+[1024]:
        for offset in list(range(8))+list(range(4096-8, 4096)):
            tb.log.info("Memory operation (32-bit BAR) length: %d offset: %d", length, offset)
            test_data = bytearray([x % 256 for x in range(length)])

            await dev_bar0.write(offset, test_data, timeout=100)
            # wait for write to complete
            await dev_bar0.read(offset, 0, timeout=5000)
            assert tb.regions[0][offset:offset+length] == test_data

            assert await dev_bar0.read(offset, length, timeout=5000) == test_data

    for length in list(range(0, 32))+[1024]:
        for offset in list(range(8))+list(range(4096-8, 4096)):
            tb.log.info("Memory operation (64-bit BAR) length: %d offset: %d", length, offset)
            test_data = bytearray([x % 256 for x in range(length)])

            await dev_bar1.write(offset, test_data, timeout=100)
            # wait for write to complete
            await dev_bar1.read(offset, 0, timeout=5000)
            assert tb.regions[1][offset:offset+length] == test_data

            assert await dev_bar1.read(offset, length, timeout=5000) == test_data

    await RisingEdge(dut.coreclkout_hip)
    await RisingEdge(dut.coreclkout_hip)


async def run_test_dma(dut, idle_inserter=None, backpressure_inserter=None):

    tb = TB(dut)

    mem = tb.rc.mem_pool.alloc_region(16*1024*1024)
    mem_base = mem.get_absolute_address(0)

    io = tb.rc.io_pool.alloc_region(1024)
    io_base = io.get_absolute_address(0)

    tb.set_idle_generator(idle_inserter)
    tb.set_backpressure_generator(backpressure_inserter)

    await FallingEdge(dut.reset_status)
    await Timer(100, 'ns')

    await tb.rc.enumerate()

    dev = tb.rc.find_device(tb.dev.functions[0].pcie_id)
    await dev.enable_device()
    await dev.set_master()

    for length in list(range(0, 32))+[1024]:
        for offset in list(range(8))+list(range(4096-8, 4096)):
            tb.log.info("Memory operation (DMA) length: %d offset: %d", length, offset)
            addr = mem_base+offset
            test_data = bytearray([x % 256 for x in range(length)])

            await tb.dma_mem_write(addr, test_data, 5000, 'ns')
            # wait for write to complete
            await tb.dma_mem_read(addr, 0, 5000, 'ns')
            assert mem[offset:offset+length] == test_data

            assert await tb.dma_mem_read(addr, length, 5000, 'ns') == test_data

    for length in list(range(0, 8)):
        for offset in list(range(8)):
            tb.log.info("IO operation (DMA) length: %d offset: %d", length, offset)
            addr = io_base+offset
            test_data = bytearray([x % 256 for x in range(length)])

            await tb.dma_io_write(addr, test_data, 5000, 'ns')
            assert io[offset:offset+length] == test_data

            assert await tb.dma_io_read(addr, length, 5000, 'ns') == test_data

    await RisingEdge(dut.coreclkout_hip)
    await RisingEdge(dut.coreclkout_hip)


async def run_test_msi(dut, idle_inserter=None, backpressure_inserter=None):

    tb = TB(dut)

    tb.set_idle_generator(idle_inserter)
    tb.set_backpressure_generator(backpressure_inserter)

    await FallingEdge(dut.reset_status)
    await Timer(100, 'ns')

    await tb.rc.enumerate()

    dev = tb.rc.find_device(tb.dev.functions[0].pcie_id)
    await dev.enable_device()
    await dev.set_master()
    await dev.alloc_irq_vectors(32, 32)

    await Timer(100, 'ns')
    assert tb.dev_msi_enable

    for k in range(32):
        tb.log.info("Send MSI %d", k)

        await RisingEdge(dut.coreclkout_hip)
        dut.app_msi_req.value = 1
        dut.app_msi_tc.value = 0
        dut.app_msi_num.value = k
        dut.app_msi_func_num.value = 0

        while not dut.app_msi_ack.value.integer:
            await RisingEdge(dut.coreclkout_hip)

        dut.app_msi_req.value = 0
        await RisingEdge(dut.coreclkout_hip)

        event = dev.msi_vectors[k].event
        event.clear()
        await event.wait()

    await RisingEdge(dut.coreclkout_hip)
    await RisingEdge(dut.coreclkout_hip)


async def run_test_msix(dut, idle_inserter=None, backpressure_inserter=None):

    tb = TB(dut, msix=True)

    tb.set_idle_generator(idle_inserter)
    tb.set_backpressure_generator(backpressure_inserter)

    await FallingEdge(dut.reset_status)
    await Timer(100, 'ns')

    await tb.rc.enumerate()

    dev = tb.rc.find_device(tb.dev.functions[0].pcie_id)
    await dev.enable_device()
    await dev.set_master()
    await dev.alloc_irq_vectors(64, 64)

    await Timer(100, 'ns')
    assert tb.dev_msix_enable

    for k in range(64):
        tb.log.info("Send MSI %d", k)

        addr = int.from_bytes(tb.regions[4][16*k+0:16*k+8], 'little')
        data = int.from_bytes(tb.regions[4][16*k+8:16*k+12], 'little')

        await tb.dma_mem_write(addr, data.to_bytes(4, 'little'), 5000, 'ns')

        event = dev.msi_vectors[k].event
        event.clear()
        await event.wait()

    await RisingEdge(dut.coreclkout_hip)
    await RisingEdge(dut.coreclkout_hip)


def cycle_pause():
    return itertools.cycle([1, 1, 1, 0])


if cocotb.SIM_NAME:

    for test in [
                run_test_mem,
                run_test_dma,
                run_test_msi,
                run_test_msix,
            ]:

        factory = TestFactory(test)
        factory.add_option(("idle_inserter", "backpressure_inserter"), [(None, None), (cycle_pause, cycle_pause)])
        factory.generate_tests()


# cocotb-test

tests_dir = os.path.dirname(__file__)


@pytest.mark.parametrize("data_width", [256, 512])
def test_pcie_s10(request, data_width):
    dut = "test_pcie_s10"
    module = os.path.splitext(os.path.basename(__file__))[0]
    toplevel = dut

    verilog_sources = [
        os.path.join(tests_dir, f"{dut}.v"),
    ]

    parameters = {}

    parameters['SEG_COUNT'] = 2 if data_width == 512 else 1
    parameters['SEG_DATA_WIDTH'] = data_width // parameters['SEG_COUNT']
    parameters['SEG_PARITY_WIDTH'] = parameters['SEG_DATA_WIDTH'] // 8
    parameters['SEG_EMPTY_WIDTH'] = ((parameters['SEG_DATA_WIDTH'] // 32) - 1).bit_length()

    extra_env = {f'PARAM_{k}': str(v) for k, v in parameters.items()}

    sim_build = os.path.join(tests_dir, "sim_build",
        request.node.name.replace('[', '-').replace(']', ''))

    cocotb_test.simulator.run(
        python_search=[tests_dir],
        verilog_sources=verilog_sources,
        toplevel=toplevel,
        module=module,
        parameters=parameters,
        sim_build=sim_build,
        extra_env=extra_env,
    )



================================================
FILE: tests/pcie_s10/test_pcie_s10.v
================================================
/*

Copyright (c) 2021 Alex Forencich

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

// Language: Verilog 2001

`resetall
`timescale 1ns / 1ns
`default_nettype none

/*
 * Intel Stratix 10 H-Tile/L-Tile PCIe IP core model test module
 */
module test_pcie_s10 #
(
    parameter SEG_COUNT = 1,
    parameter SEG_DATA_WIDTH = 256,
    parameter SEG_PARITY_WIDTH = SEG_DATA_WIDTH/8,
    parameter SEG_EMPTY_WIDTH = $clog2(SEG_DATA_WIDTH/32)
)
(
    // Clock and reset
    input  wire                                   npor,
    input  wire                                   pin_perst,
    input  wire                                   ninit_done,
    output wire                                   pld_clk_inuse,
    input  wire                                   pld_core_ready,
    output wire                                   reset_status,
    output wire                                   clr_st,
    input  wire                                   refclk,
    output wire                                   coreclkout_hip,
    // RX interface
    output wire [SEG_COUNT*SEG_DATA_WIDTH-1:0]    rx_st_data,
    output wire [SEG_COUNT*SEG_EMPTY_WIDTH-1:0]   rx_st_empty,
    output wire [SEG_COUNT-1:0]                   rx_st_sop,
    output wire [SEG_COUNT-1:0]                   rx_st_eop,
    output wire [SEG_COUNT-1:0]                   rx_st_valid,
    input  wire                                   rx_st_ready,
    output wire [SEG_COUNT-1:0]                   rx_st_vf_active,
    output wire [SEG_COUNT*2-1:0]                 rx_st_func_num,
    output wire [SEG_COUNT*11-1:0]                rx_st_vf_num,
    output wire [SEG_COUNT*3-1:0]                 rx_st_bar_range,
    output wire [SEG_COUNT*SEG_PARITY_WIDTH-1:0]  rx_st_parity,
    // TX interface
    input  wire [SEG_COUNT*SEG_DATA_WIDTH-1:0]    tx_st_data,
    input  wire [SEG_COUNT-1:0]                   tx_st_sop,
    input  wire [SEG_COUNT-1:0]                   tx_st_eop,
    input  wire [SEG_COUNT-1:0]                   tx_st_valid,
    output wire                                   tx_st_ready,
    input  wire [SEG_COUNT-1:0]                   tx_st_err,
    input  wire [SEG_COUNT-1:0]                   tx_st_vf_active,
    input  wire [SEG_COUNT*SEG_PARITY_WIDTH-1:0]  tx_st_parity,
    // TX flow control
    output wire [7:0]                             tx_ph_cdts,
    output wire [11:0]                            tx_pd_cdts,
    output wire [7:0]                             tx_nph_cdts,
    output wire [11:0]                            tx_npd_cdts,
    output wire [7:0]                             tx_cplh_cdts,
    output wire [11:0]                            tx_cpld_cdts,
    output wire [SEG_COUNT-1:0]                   tx_hdr_cdts_consumed,
    output wire [SEG_COUNT-1:0]                   tx_data_cdts_consumed,
    output wire [SEG_COUNT*2-1:0]                 tx_cdts_type,
    output wire [SEG_COUNT*1-1:0]                 tx_cdts_data_value,
    // Hard IP status
    output wire [10:0]                            int_status,
    output wire [2:0]                             int_status_common,
    output wire                                   derr_cor_ext_rpl,
    output wire                                   derr_rpl,
    output wire                                   derr_cor_ext_rcv,
    output wire                                   derr_uncor_ext_rcv,
    output wire                                   rx_par_err,
    output wire                                   tx_par_err,
    output wire [5:0]                             ltssmstate,
    output wire                                   link_up,
    output wire [4:0]                             lane_act,
    output wire [1:0]                             currentspeed,
    // Power management
    output wire                                   pm_linkst_in_l1,
    output wire                                   pm_linkst_in_l0s,
    output wire [2:0]                             pm_state,
    output wire [2:0]                             pm_dstate,
    input  wire                                   apps_pm_xmt_pme,
    input  wire                                   apps_ready_entr_l23,
    input  wire                                   apps_pm_xmt_turnoff,
    input  wire                                   app_init_rst,
    input  wire                                   app_xfer_pending,
    // Interrupt interface
    input  wire                                   app_msi_req,
    output wire                                   app_msi_ack,
    input  wire [2:0]                             app_msi_tc,
    input  wire [4:0]                             app_msi_num,
    input  wire [1:0]                             app_msi_func_num,
    input  wire [3:0]                             app_int_sts,
    // Error interface
    input  wire                                   app_err_valid,
    input  wire [31:0]                            app_err_hdr,
    input  wire [10:0]                            app_err_info,
    input  wire [1:0]                             app_err_func_num,
    // Configuration output interface
    output wire [1:0]                             tl_cfg_func,
    output wire [4:0]                             tl_cfg_add,
    output wire [31:0]                            tl_cfg_ctl,
    // Configuration extension bus
    output wire                                   ceb_req,
    input  wire                                   ceb_ack,
    output wire [11:0]                            ceb_addr,
    input  wire [31:0]                            ceb_din,
    output wire [31:0]                            ceb_dout,
    output wire [3:0]                             ceb_wr,
    input  wire [31:0]                            ceb_cdm_convert_data,
    output wire [1:0]                             ceb_func_num,
    output wire [10:0]                            ceb_vf_num,
    output wire                                   ceb_vf_active,
    // Hard IP reconfiguration interface
    input  wire                                   hip_reconfig_clk,
    input  wire                                   hip_reconfig_rst_n,
    input  wire [20:0]                            hip_reconfig_address,
    input  wire                                   hip_reconfig_read,
    output wire [7:0]                             hip_reconfig_readdata,
    output wire                                   hip_reconfig_readdatavalid,
    input  wire                                   hip_reconfig_write,
    input  wire [7:0]                             hip_reconfig_writedata,
    output wire                                   hip_reconfig_waitrequest
);

endmodule

`resetall



================================================
FILE: tests/pcie_us/Makefile
================================================
# Copyright (c) 2020 Alex Forencich
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

TOPLEVEL_LANG = verilog

SIM ?= icarus
WAVES ?= 0

COCOTB_HDL_TIMEUNIT = 1ns
COCOTB_HDL_TIMEPRECISION = 1ps

DUT      = test_pcie_us
TOPLEVEL = $(DUT)
MODULE   = $(DUT)
VERILOG_SOURCES  = $(DUT).v

# module parameters
export PARAM_DATA_WIDTH := 64
export PARAM_KEEP_WIDTH := $(shell expr $(PARAM_DATA_WIDTH) / 32 )
export PARAM_RQ_USER_WIDTH := 60
export PARAM_RC_USER_WIDTH := 75
export PARAM_CQ_USER_WIDTH := 85
export PARAM_CC_USER_WIDTH := 33
export STRADDLE := $(if $(filter-out 256,$(PARAM_DATA_WIDTH)),0,1)
export CLIENT_TAG := 1

ifeq ($(SIM), icarus)
	PLUSARGS += -fst

	COMPILE_ARGS += $(foreach v,$(filter PARAM_%,$(.VARIABLES)),-P $(TOPLEVEL).$(subst PARAM_,,$(v))=$($(v)))

	ifeq ($(WAVES), 1)
		VERILOG_SOURCES += iverilog_dump.v
		COMPILE_ARGS += -s iverilog_dump
	endif
else ifeq ($(SIM), verilator)
	COMPILE_ARGS += -Wno-SELRANGE -Wno-WIDTH

	COMPILE_ARGS += $(foreach v,$(filter PARAM_%,$(.VARIABLES)),-G$(subst PARAM_,,$(v))=$($(v)))

	ifeq ($(WAVES), 1)
		COMPILE_ARGS += --trace-fst
	endif
endif

include $(shell cocotb-config --makefiles)/Makefile.sim

iverilog_dump.v:
	echo 'module iverilog_dump();' > $@
	echo 'initial begin' >> $@
	echo '    $$dumpfile("$(TOPLEVEL).fst");' >> $@
	echo '    $$dumpvars(0, $(TOPLEVEL));' >> $@
	echo 'end' >> $@
	echo 'endmodule' >> $@

clean::
	@rm -rf iverilog_dump.v
	@rm -rf dump.fst $(TOPLEVEL).fst



================================================
FILE: tests/pcie_us/test_pcie_us.py
================================================
#!/usr/bin/env python
"""

Copyright (c) 2020 Alex Forencich

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

"""

import itertools
import logging
import mmap
import os

import cocotb_test.simulator
import pytest

import cocotb
from cocotb.queue import Queue
from cocotb.triggers import RisingEdge, FallingEdge, Timer, Event, First
from cocotb.regression import TestFactory

from cocotbext.axi import AxiStreamBus
from cocotbext.pcie.core import RootComplex
from cocotbext.pcie.core.tlp import TlpType, CplStatus
from cocotbext.pcie.core.utils import PcieId
from cocotbext.pcie.xilinx.us import UltraScalePcieDevice
from cocotbext.pcie.xilinx.us.interface import RqSource, RcSink, CqSink, CcSource
from cocotbext.pcie.xilinx.us.tlp import Tlp_us


class TB:
    def __init__(self, dut, msix=False):
        self.dut = dut

        self.log = logging.getLogger("cocotb.tb")
        self.log.setLevel(logging.DEBUG)

        # PCIe
        self.rc = RootComplex()

        rc_straddle = False
        if int(os.getenv("STRADDLE", "0")):
            if len(dut.s_axis_rq_tdata) == 256:
                rc_straddle = True

        self.client_tag = bool(int(os.getenv("CLIENT_TAG", "1")))

        self.dev = UltraScalePcieDevice(
            # configuration options
            # pcie_generation=3,
            # pcie_link_width=2,
            # user_clk_frequency=250e6,
            alignment="dword",
            rc_straddle=rc_straddle,
            pf_count=1,
            max_payload_size=128,
            enable_client_tag=self.client_tag,
            enable_extended_tag=False,
            enable_parity=False,
            enable_rx_msg_interface=False,
            enable_sriov=False,
            enable_extended_configuration=False,

            pf0_msi_enable=True,
            pf0_msi_count=32,
            pf1_msi_enable=False,
            pf1_msi_count=1,
            pf0_msix_enable=msix,
            pf0_msix_table_size=63,
            pf0_msix_table_bir=4,
            pf0_msix_table_offset=0x00000000,
            pf0_msix_pba_bir=4,
            pf0_msix_pba_offset=0x00008000,
            pf1_msix_enable=False,
            pf1_msix_table_size=0,
            pf1_msix_table_bir=0,
            pf1_msix_table_offset=0x00000000,
            pf1_msix_pba_bir=0,
            pf1_msix_pba_offset=0x00000000,

            # signals
            user_clk=dut.user_clk,
            user_reset=dut.user_reset,
            user_lnk_up=dut.user_lnk_up,
            sys_clk=dut.sys_clk,
            sys_clk_gt=dut.sys_clk_gt,
            sys_reset=dut.sys_reset,
            pcie_perstn1_in=dut.pcie_perstn1_in,
            pcie_perstn0_out=dut.pcie_perstn0_out,
            pcie_perstn1_out=dut.pcie_perstn1_out,
            phy_rdy_out=dut.phy_rdy_out,

            rq_bus=AxiStreamBus.from_prefix(dut, "s_axis_rq"),
            pcie_rq_seq_num=dut.pcie_rq_seq_num,
            pcie_rq_seq_num_vld=dut.pcie_rq_seq_num_vld,
            pcie_rq_tag=dut.pcie_rq_tag,
            pcie_rq_tag_av=dut.pcie_rq_tag_av,
            pcie_rq_tag_vld=dut.pcie_rq_tag_vld,

            rc_bus=AxiStreamBus.from_prefix(dut, "m_axis_rc"),

            cq_bus=AxiStreamBus.from_prefix(dut, "m_axis_cq"),
            pcie_cq_np_req=dut.pcie_cq_np_req,
            pcie_cq_np_req_count=dut.pcie_cq_np_req_count,

            cc_bus=AxiStreamBus.from_prefix(dut, "s_axis_cc"),

            pcie_tfc_nph_av=dut.pcie_tfc_nph_av,
            pcie_tfc_npd_av=dut.pcie_tfc_npd_av,
            cfg_phy_link_down=dut.cfg_phy_link_down,
            cfg_phy_link_status=dut.cfg_phy_link_status,
            cfg_negotiated_width=dut.cfg_negotiated_width,
            cfg_current_speed=dut.cfg_current_speed,
            cfg_max_payload=dut.cfg_max_payload,
            cfg_max_read_req=dut.cfg_max_read_req,
            cfg_function_status=dut.cfg_function_status,
            cfg_function_power_state=dut.cfg_function_power_state,
            cfg_vf_status=dut.cfg_vf_status,
            cfg_vf_power_state=dut.cfg_vf_power_state,
            cfg_link_power_state=dut.cfg_link_power_state,
            cfg_mgmt_addr=dut.cfg_mgmt_addr,
            cfg_mgmt_write=dut.cfg_mgmt_write,
            cfg_mgmt_write_data=dut.cfg_mgmt_write_data,
            cfg_mgmt_byte_enable=dut.cfg_mgmt_byte_enable,
            cfg_mgmt_read=dut.cfg_mgmt_read,
            cfg_mgmt_read_data=dut.cfg_mgmt_read_data,
            cfg_mgmt_read_write_done=dut.cfg_mgmt_read_write_done,
            cfg_mgmt_type1_cfg_reg_access=dut.cfg_mgmt_type1_cfg_reg_access,
            cfg_err_cor_out=dut.cfg_err_cor_out,
            cfg_err_nonfatal_out=dut.cfg_err_nonfatal_out,
            cfg_err_fatal_out=dut.cfg_err_fatal_out,
            cfg_local_error=dut.cfg_local_error,
            cfg_ltr_enable=dut.cfg_ltr_enable,
            cfg_ltssm_state=dut.cfg_ltssm_state,
            cfg_rcb_status=dut.cfg_rcb_status,
            cfg_dpa_substate_change=dut.cfg_dpa_substate_change,
            cfg_obff_enable=dut.cfg_obff_enable,
            cfg_pl_status_change=dut.cfg_pl_status_change,
            cfg_tph_requester_enable=dut.cfg_tph_requester_enable,
            cfg_tph_st_mode=dut.cfg_tph_st_mode,
            cfg_vf_tph_requester_enable=dut.cfg_vf_tph_requester_enable,
            cfg_vf_tph_st_mode=dut.cfg_vf_tph_st_mode,
            cfg_msg_received=dut.cfg_msg_received,
            cfg_msg_received_data=dut.cfg_msg_received_data,
            cfg_msg_received_type=dut.cfg_msg_received_type,
            cfg_msg_transmit=dut.cfg_msg_transmit,
            cfg_msg_transmit_type=dut.cfg_msg_transmit_type,
            cfg_msg_transmit_data=dut.cfg_msg_transmit_data,
            cfg_msg_transmit_done=dut.cfg_msg_transmit_done,
            cfg_fc_ph=dut.cfg_fc_ph,
            cfg_fc_pd=dut.cfg_fc_pd,
            cfg_fc_nph=dut.cfg_fc_nph,
            cfg_fc_npd=dut.cfg_fc_npd,
            cfg_fc_cplh=dut.cfg_fc_cplh,
            cfg_fc_cpld=dut.cfg_fc_cpld,
            cfg_fc_sel=dut.cfg_fc_sel,
            cfg_per_func_status_control=dut.cfg_per_func_status_control,
            cfg_per_func_status_data=dut.cfg_per_func_status_data,
            cfg_per_function_number=dut.cfg_per_function_number,
            cfg_per_function_output_request=dut.cfg_per_function_output_request,
            cfg_per_function_update_done=dut.cfg_per_function_update_done,
            cfg_dsn=dut.cfg_dsn,
            cfg_power_state_change_ack=dut.cfg_power_state_change_ack,
            cfg_power_state_change_interrupt=dut.cfg_power_state_change_interrupt,
            cfg_err_cor_in=dut.cfg_err_cor_in,
            cfg_err_uncor_in=dut.cfg_err_uncor_in,
            cfg_flr_in_process=dut.cfg_flr_in_process,
            cfg_flr_done=dut.cfg_flr_done,
            cfg_vf_flr_in_process=dut.cfg_vf_flr_in_process,
            cfg_vf_flr_done=dut.cfg_vf_flr_done,
            cfg_link_training_enable=dut.cfg_link_training_enable,
            cfg_interrupt_int=dut.cfg_interrupt_int,
            cfg_interrupt_pending=dut.cfg_interrupt_pending,
            cfg_interrupt_sent=dut.cfg_interrupt_sent,
            cfg_interrupt_msi_enable=dut.cfg_interrupt_msi_enable,
            cfg_interrupt_msi_vf_enable=dut.cfg_interrupt_msi_vf_enable,
            cfg_interrupt_msi_mmenable=dut.cfg_interrupt_msi_mmenable,
            cfg_interrupt_msi_mask_update=dut.cfg_interrupt_msi_mask_update,
            cfg_interrupt_msi_data=dut.cfg_interrupt_msi_data,
            cfg_interrupt_msi_select=dut.cfg_interrupt_msi_select,
            cfg_interrupt_msi_int=dut.cfg_interrupt_msi_int,
            cfg_interrupt_msi_pending_status=dut.cfg_interrupt_msi_pending_status,
            cfg_interrupt_msi_pending_status_data_enable=dut.cfg_interrupt_msi_pending_status_data_enable,
            cfg_interrupt_msi_pending_status_function_num=dut.cfg_interrupt_msi_pending_status_function_num,
            cfg_interrupt_msi_sent=dut.cfg_interrupt_msi_sent,
            cfg_interrupt_msi_fail=dut.cfg_interrupt_msi_fail,
            cfg_interrupt_msix_enable=dut.cfg_interrupt_msix_enable,
            cfg_interrupt_msix_mask=dut.cfg_interrupt_msix_mask,
            cfg_interrupt_msix_vf_enable=dut.cfg_interrupt_msix_vf_enable,
            cfg_interrupt_msix_vf_mask=dut.cfg_interrupt_msix_vf_mask,
            cfg_interrupt_msix_address=dut.cfg_interrupt_msix_address,
            cfg_interrupt_msix_data=dut.cfg_interrupt_msix_data,
            cfg_interrupt_msix_int=dut.cfg_interrupt_msix_int,
            cfg_interrupt_msix_sent=dut.cfg_interrupt_msix_sent,
            cfg_interrupt_msix_fail=dut.cfg_interrupt_msix_fail,
            cfg_interrupt_msi_attr=dut.cfg_interrupt_msi_attr,
            cfg_interrupt_msi_tph_present=dut.cfg_interrupt_msi_tph_present,
            cfg_interrupt_msi_tph_type=dut.cfg_interrupt_msi_tph_type,
            cfg_interrupt_msi_tph_st_tag=dut.cfg_interrupt_msi_tph_st_tag,
            cfg_interrupt_msi_function_number=dut.cfg_interrupt_msi_function_number,
            cfg_hot_reset_out=dut.cfg_hot_reset_out,
            cfg_config_space_enable=dut.cfg_config_space_enable,
            cfg_req_pm_transition_l23_ready=dut.cfg_req_pm_transition_l23_ready,
            cfg_hot_reset_in=dut.cfg_hot_reset_in,
            cfg_ds_port_number=dut.cfg_ds_port_number,
            cfg_ds_bus_number=dut.cfg_ds_bus_number,
            cfg_ds_device_number=dut.cfg_ds_device_number,
            cfg_ds_function_number=dut.cfg_ds_function_number,
            cfg_subsys_vend_id=dut.cfg_subsys_vend_id
        )

        self.dev.log.setLevel(logging.DEBUG)

        dut.pcie_cq_np_req.setimmediatevalue(1)
        dut.cfg_mgmt_addr.setimmediatevalue(0)
        dut.cfg_mgmt_write.setimmediatevalue(0)
        dut.cfg_mgmt_write_data.setimmediatevalue(0)
        dut.cfg_mgmt_byte_enable.setimmediatevalue(0)
        dut.cfg_mgmt_read.setimmediatevalue(0)
        dut.cfg_mgmt_type1_cfg_reg_access.setimmediatevalue(0)
        dut.cfg_msg_transmit.setimmediatevalue(0)
        dut.cfg_msg_transmit_type.setimmediatevalue(0)
        dut.cfg_msg_transmit_data.setimmediatevalue(0)
        dut.cfg_fc_sel.setimmediatevalue(0)
        dut.cfg_per_func_status_control.setimmediatevalue(0)
        dut.cfg_per_function_number.setimmediatevalue(0)
        dut.cfg_per_function_output_request.setimmediatevalue(0)
        dut.cfg_dsn.setimmediatevalue(0)
        dut.cfg_power_state_change_ack.setimmediatevalue(0)
        dut.cfg_err_cor_in.setimmediatevalue(0)
        dut.cfg_err_uncor_in.setimmediatevalue(0)
        dut.cfg_flr_done.setimmediatevalue(0)
        dut.cfg_vf_flr_done.setimmediatevalue(0)
        dut.cfg_link_training_enable.setimmediatevalue(1)
        dut.cfg_interrupt_int.setimmediatevalue(0)
        dut.cfg_interrupt_pending.setimmediatevalue(0)
        dut.cfg_interrupt_msi_select.setimmediatevalue(0)
        dut.cfg_interrupt_msi_int.setimmediatevalue(0)
        dut.cfg_interrupt_msi_pending_status.setimmediatevalue(0)
        dut.cfg_interrupt_msi_pending_status_data_enable.setimmediatevalue(0)
        dut.cfg_interrupt_msi_pending_status_function_num.setimmediatevalue(0)
        dut.cfg_interrupt_msix_address.setimmediatevalue(0)
        dut.cfg_interrupt_msix_data.setimmediatevalue(0)
        dut.cfg_interrupt_msix_int.setimmediatevalue(0)
        dut.cfg_interrupt_msi_attr.setimmediatevalue(0)
        dut.cfg_interrupt_msi_tph_present.setimmediatevalue(0)
        dut.cfg_interrupt_msi_tph_type.setimmediatevalue(0)
        dut.cfg_interrupt_msi_tph_st_tag.setimmediatevalue(0)
        dut.cfg_interrupt_msi_function_number.setimmediatevalue(0)
        dut.cfg_config_space_enable.setimmediatevalue(1)
        dut.cfg_req_pm_transition_l23_ready.setimmediatevalue(0)
        dut.cfg_hot_reset_in.setimmediatevalue(0)
        dut.cfg_ds_port_number.setimmediatevalue(0)
        dut.cfg_ds_bus_number.setimmediatevalue(0)
        dut.cfg_ds_device_number.setimmediatevalue(0)
        dut.cfg_ds_function_number.setimmediatevalue(0)
        dut.cfg_subsys_vend_id.setimmediatevalue(0)
        dut.sys_clk.setimmediatevalue(0)
        dut.sys_clk_gt.setimmediatevalue(0)
        dut.sys_reset.setimmediatevalue(1)
        dut.pcie_perstn1_in.setimmediatevalue(1)

        self.rc.make_port().connect(self.dev)

        # user logic
        rc_segments = 2 if rc_straddle else 1

        self.rq_source = RqSource(AxiStreamBus.from_prefix(dut, "s_axis_rq"), dut.user_clk, dut.user_reset)
        self.rc_sink = RcSink(AxiStreamBus.from_prefix(dut, "m_axis_rc"), dut.user_clk, dut.user_reset, segments=rc_segments)
        self.cq_sink = CqSink(AxiStreamBus.from_prefix(dut, "m_axis_cq"), dut.user_clk, dut.user_reset)
        self.cc_source = CcSource(AxiStreamBus.from_prefix(dut, "s_axis_cc"), dut.user_clk, dut.user_reset)

        self.regions = [None]*6
        self.regions[0] = mmap.mmap(-1, 1024*1024)
        self.regions[1] = mmap.mmap(-1, 1024*1024)
        self.regions[3] = mmap.mmap(-1, 1024)
        self.regions[4] = mmap.mmap(-1, 1024*64)

        self.current_tag = 0
        self.tag_count = 64
        self.tag_active = [False]*256
        self.tag_release = Event()

        self.rq_tag = Queue()

        self.rx_cpl_queues = [Queue() for k in range(256)]
        self.rx_cpl_sync = [Event() for k in range(256)]

        self.dev.functions[0].configure_bar(0, len(self.regions[0]))
        self.dev.functions[0].configure_bar(1, len(self.regions[1]), True, True)
        self.dev.functions[0].configure_bar(3, len(self.regions[3]), False, False, True)
        self.dev.functions[0].configure_bar(4, len(self.regions[4]))

        if not self.client_tag:
            cocotb.start_soon(self._run_rq_tags())
        cocotb.start_soon(self._run_rc())
        cocotb.start_soon(self._run_cq())

    def set_idle_generator(self, generator=None):
        if generator:
            self.dev.rc_source.set_pause_generator(generator())
            self.dev.cq_source.set_pause_generator(generator())

    def set_backpressure_generator(self, generator=None):
        if generator:
            self.dev.rq_sink.set_pause_generator(generator())
            self.dev.cc_sink.set_pause_generator(generator())

    async def recv_cpl(self, tag, timeout=0, timeout_unit='ns'):
        queue = self.rx_cpl_queues[tag]
        sync = self.rx_cpl_sync[tag]

        if not queue.empty():
            return queue.get_nowait()

        sync.clear()
        if timeout:
            await First(sync.wait(), Timer(timeout, timeout_unit))
        else:
            await sync.wait()

        if not queue.empty():
            return queue.get_nowait()

        return None

    async def alloc_tag(self):
        tag_count = min(256 if self.dev.functions[0].pcie_cap.extended_tag_field_enable else 32, self.tag_count)

        while True:
            tag = self.current_tag
            for k in range(tag_count):
                tag = (tag + 1) % tag_count
                if not self.tag_active[tag]:
                    self.tag_active[tag] = True
                    self.current_tag = tag
                    return tag

            self.tag_release.clear()
            await self.tag_release.wait()

    def release_tag(self, tag):
        assert self.tag_active[tag]
        self.tag_active[tag] = False
        self.tag_release.set()

    async def perform_posted_operation(self, req):
        await self.rq_source.send(req.pack_us_rq())

    async def perform_nonposted_operation(self, req, timeout=0, timeout_unit='ns'):
        completions = []

        if self.client_tag:
            req.tag = await self.alloc_tag()
            await self.rq_source.send(req.pack_us_rq())
        else:
            await self.rq_source.send(req.pack_us_rq())
            req.tag = await self.rq_tag.get()

        while True:
            cpl = await self.recv_cpl(req.tag, timeout, timeout_unit)

            if not cpl:
                break

            completions.append(cpl)

            if cpl.status != CplStatus.SC:
                # bad status
                break
            elif req.fmt_type in {TlpType.MEM_READ, TlpType.MEM_READ_64}:
                # completion for memory read request

                # request completed
                if cpl.byte_count <= cpl.length*4 - (cpl.lower_address & 0x3):
                    break

                # completion for read request has SC status but no data
                if cpl.fmt_type in {TlpType.CPL, TlpType.CPL_LOCKED}:
                    break

            else:
                # completion for other request
                break

        if self.client_tag:
            self.release_tag(req.tag)

        return completions

    async def dma_io_write(self, addr, data, timeout=0, timeout_unit='ns'):
        n = 0

        zero_len = len(data) == 0
        if zero_len:
            data = b'\x00'

        op_list = []

        while n < len(data):
            req = Tlp_us()
            req.fmt_type = TlpType.IO_WRITE
            req.requester_id = PcieId(0, 0, 0)

            first_pad = addr % 4
            byte_length = min(len(data)-n, 4-first_pad)
            req.set_addr_be_data(addr, data[n:n+byte_length])

            if zero_len:
                req.first_be = 0

            op_list.append(cocotb.start_soon(self.perform_nonposted_operation(req, timeout, timeout_unit)))

            n += byte_length
            addr += byte_length

        for op in op_list:
            cpl_list = await op.join()

            if not cpl_list:
                raise Exception("Timeout")
            if cpl_list[0].status != CplStatus.SC:
                raise Exception("Unsuccessful completion")

    async def dma_io_read(self, addr, length, timeout=0, timeout_unit='ns'):
        data = bytearray()
        n = 0

        zero_len = length <= 0
        if zero_len:
            length = 1

        op_list = []

        while n < length:
            req = Tlp_us()
            req.fmt_type = TlpType.IO_READ
            req.requester_id = PcieId(0, 0, 0)

            first_pad = addr % 4
            byte_length = min(length-n, 4-first_pad)
            req.set_addr_be(addr, byte_length)

            if zero_len:
                req.first_be = 0

            op_list.append((first_pad, cocotb.start_soon(self.perform_nonposted_operation(req, timeout, timeout_unit))))

            n += byte_length
            addr += byte_length

        for first_pad, op in op_list:
            cpl_list = await op.join()

            if not cpl_list:
                raise Exception("Timeout")
            cpl = cpl_list[0]
            if cpl.status != CplStatus.SC:
                raise Exception("Unsuccessful completion")

            assert cpl.length == 1
            d = cpl.get_data()

            data.extend(d[first_pad:])

        if zero_len:
            return b''

        return bytes(data[:length])

    async def dma_mem_write(self, addr, data, timeout=0, timeout_unit='ns'):
        n = 0

        zero_len = len(data) == 0
        if zero_len:
            data = b'\x00'

        while n < len(data):
            req = Tlp_us()
            if addr > 0xffffffff:
                req.fmt_type = TlpType.MEM_WRITE_64
            else:
                req.fmt_type = TlpType.MEM_WRITE
            req.requester_id = PcieId(0, 0, 0)

            first_pad = addr % 4
            byte_length = len(data)-n
            # max payload size
            byte_length = min(byte_length, (128 << self.dut.cfg_max_payload.value.integer)-first_pad)
            # 4k address align
            byte_length = min(byte_length, 0x1000 - (addr & 0xfff))
            req.set_addr_be_data(addr, data[n:n+byte_length])

            if zero_len:
                req.first_be = 0

            await self.perform_posted_operation(req)

            n += byte_length
            addr += byte_length

    async def dma_mem_read(self, addr, length, timeout=0, timeout_unit='ns'):
        data = bytearray()
        n = 0

        zero_len = length <= 0
        if zero_len:
            length = 1

        op_list = []

        while n < length:
            req = Tlp_us()
            if addr > 0xffffffff:
                req.fmt_type = TlpType.MEM_READ_64
            else:
                req.fmt_type = TlpType.MEM_READ
            req.requester_id = PcieId(0, 0, 0)

            first_pad = addr % 4
            # remaining length
            byte_length = length-n
            # limit to max read request size
            if byte_length > (128 << self.dut.cfg_max_read_req.value.integer) - first_pad:
                # split on 128-byte read completion boundary
                byte_length = min(byte_length, (128 << self.dut.cfg_max_read_req.value.integer) - (addr & 0x7f))
            # 4k align
            byte_length = min(byte_length, 0x1000 - (addr & 0xfff))
            req.set_addr_be(addr, byte_length)

            if zero_len:
                req.first_be = 0

            op_list.append((byte_length, cocotb.start_soon(self.perform_nonposted_operation(req, timeout, timeout_unit))))

            n += byte_length
            addr += byte_length

        for byte_length, op in op_list:
            cpl_list = await op.join()

            m = 0

            while m < byte_length:
                if not cpl_list:
                    raise Exception("Timeout")

                cpl = cpl_list.pop(0)

                if cpl.status != CplStatus.SC:
                    raise Exception("Unsuccessful completion")

                assert cpl.byte_count+3+(cpl.lower_address & 3) >= cpl.length*4
                assert cpl.byte_count == max(byte_length - m, 1)

                d = cpl.get_data()

                offset = cpl.lower_address & 3
                data.extend(d[offset:offset+cpl.byte_count])

                m += len(d)-offset

        if zero_len:
            return b''

        return bytes(data[:length])

    async def _run_rq_tags(self):
        clock_edge_event = RisingEdge(self.dut.user_clk)

        while True:
            await clock_edge_event

            if self.dut.pcie_rq_tag_vld.value:
                self.rq_tag.put_nowait(self.dut.pcie_rq_tag.value.integer)

    async def _run_rc(self):
        while True:
            pkt = await self.rc_sink.recv()

            tlp = Tlp_us.unpack_us_rc(pkt)

            self.log.debug("RC TLP: %s", repr(tlp))

            self.rx_cpl_queues[tlp.tag].put_nowait(tlp)
            self.rx_cpl_sync[tlp.tag].set()

    async def _run_cq(self):
        while True:
            pkt = await self.cq_sink.recv()

            tlp = Tlp_us.unpack_us_cq(pkt)

            self.log.debug("CQ TLP: %s", repr(tlp))

            if tlp.fmt_type == TlpType.IO_READ:
                self.log.info("IO read")

                cpl = Tlp_us.create_completion_data_for_tlp(tlp, PcieId(0, 0, 0))

                region = tlp.bar_id
                addr = tlp.address % len(self.regions[region])
                offset = 0
                start_offset = None
                mask = tlp.first_be

                # perform operation
                data = bytearray(4)

                for k in range(4):
                    if mask & (1 << k):
                        if start_offset is None:
                            start_offset = offset
                    else:
                        if start_offset is not None and offset != start_offset:
                            data[start_offset:offset] = self.regions[region][addr+start_offset:addr+offset]
                        start_offset = None

                    offset += 1

                if start_offset is not None and offset != start_offset:
                    data[start_offset:offset] = self.regions[region][addr+start_offset:addr+offset]

                cpl.set_data(data)
                cpl.byte_count = 4
                cpl.length = 1

                self.log.debug("Completion: %s", repr(cpl))
                await self.cc_source.send(cpl.pack_us_cc())

            elif tlp.fmt_type == TlpType.IO_WRITE:
                self.log.info("IO write")

                cpl = Tlp_us.create_completion_for_tlp(tlp, PcieId(0, 0, 0))

                region = tlp.bar_id
                addr = tlp.address % len(self.regions[region])
                offset = 0
                start_offset = None
                mask = tlp.first_be

                # perform operation
                data = tlp.get_data()

                for k in range(4):
                    if mask & (1 << k):
                        if start_offset is None:
                            start_offset = offset
                    else:
                        if start_offset is not None and offset != start_offset:
                            self.regions[region][addr+start_offset:addr+offset] = data[start_offset:offset]
                        start_offset = None

                    offset += 1

                if start_offset is not None and offset != start_offset:
                    self.regions[region][addr+start_offset:addr+offset] = data[start_offset:offset]

                self.log.debug("Completion: %s", repr(cpl))
                await self.cc_source.send(cpl.pack_us_cc())

            elif tlp.fmt_type in {TlpType.MEM_READ, TlpType.MEM_READ_64}:
                self.log.info("Memory read")

                # perform operation
                region = tlp.bar_id
                addr = tlp.address % len(self.regions[region])
                offset = 0
                length = tlp.length

                # perform read
                data = self.regions[region][addr:addr+length*4]

                # prepare completion TLP(s)
                m = 0
                n = 0
                addr = tlp.address+tlp.get_first_be_offset()
                dw_length = tlp.length
                byte_length = tlp.get_be_byte_count()

                while m < dw_length:
                    cpl = Tlp_us.create_completion_data_for_tlp(tlp, PcieId(0, 0, 0))

                    cpl_dw_length = dw_length - m
                    cpl_byte_length = byte_length - n
                    cpl.byte_count = cpl_byte_length
                    if cpl_dw_length > 32 << self.dut.cfg_max_payload.value.integer:
                        # max payload size
                        cpl_dw_length = 32 << self.dut.cfg_max_payload.value.integer
                        # RCB align
                        cpl_dw_length -= (addr & 0x7c) >> 2

                    cpl.lower_address = addr & 0x7f

                    cpl.set_data(data[m*4:(m+cpl_dw_length)*4])

                    self.log.debug("Completion: %s", repr(cpl))
                    await self.cc_source.send(cpl.pack_us_cc())

                    m += cpl_dw_length
                    n += cpl_dw_length*4 - (addr & 3)
                    addr += cpl_dw_length*4 - (addr & 3)

            elif tlp.fmt_type in {TlpType.MEM_WRITE, TlpType.MEM_WRITE_64}:
                self.log.info("Memory write")

                # perform operation
                region = tlp.bar_id
                addr = tlp.address % len(self.regions[region])
                offset = 0
                start_offset = None
                mask = tlp.first_be
                length = tlp.length

                # perform write
                data = tlp.get_data()

                # first dword
                for k in range(4):
                    if mask & (1 << k):
                        if start_offset is None:
                            start_offset = offset
                    else:
                        if start_offset is not None and offset != start_offset:
                            self.regions[region][addr+start_offset:addr+offset] = data[start_offset:offset]
                        start_offset = None

                    offset += 1

                if length > 2:
                    # middle dwords
                    if start_offset is None:
                        start_offset = offset
                    offset += (length-2)*4

                if length > 1:
                    # last dword
                    mask = tlp.last_be

                    for k in range(4):
                        if mask & (1 << k):
                            if start_offset is None:
                                start_offset = offset
                        else:
                            if start_offset is not None and offset != start_offset:
                                self.regions[region][addr+start_offset:addr+offset] = data[start_offset:offset]
                            start_offset = None

                        offset += 1

                if start_offset is not None and offset != start_offset:
                    self.regions[region][addr+start_offset:addr+offset] = data[start_offset:offset]


async def run_test_mem(dut, idle_inserter=None, backpressure_inserter=None):

    tb = TB(dut)

    tb.set_idle_generator(idle_inserter)
    tb.set_backpressure_generator(backpressure_inserter)

    await FallingEdge(dut.user_reset)
    await Timer(100, 'ns')

    await tb.rc.enumerate()

    dev = tb.rc.find_device(tb.dev.functions[0].pcie_id)
    await dev.enable_device()

    dev_bar0 = dev.bar_window[0]
    dev_bar1 = dev.bar_window[1]
    dev_bar3 = dev.bar_window[3]

    for length in list(range(0, 8)):
        for offset in list(range(8)):
            tb.log.info("IO operation length: %d offset: %d", length, offset)
            test_data = bytearray([x % 256 for x in range(length)])

            await dev_bar3.write(offset, test_data, timeout=5000)
            assert tb.regions[3][offset:offset+length] == test_data

            assert await dev_bar3.read(offset, length, timeout=5000) == test_data

    for length in list(range(0, 32))+[1024]:
        for offset in list(range(8))+list(range(4096-8, 4096)):
            tb.log.info("Memory operation (32-bit BAR) length: %d offset: %d", length, offset)
            test_data = bytearray([x % 256 for x in range(length)])

            await dev_bar0.write(offset, test_data, timeout=100)
            # wait for write to complete
            await dev_bar0.read(offset, 0, timeout=5000)
            assert tb.regions[0][offset:offset+length] == test_data

            assert await dev_bar0.read(offset, length, timeout=5000) == test_data

    for length in list(range(0, 32))+[1024]:
        for offset in list(range(8))+list(range(4096-8, 4096)):
            tb.log.info("Memory operation (64-bit BAR) length: %d offset: %d", length, offset)
            test_data = bytearray([x % 256 for x in range(length)])

            await dev_bar1.write(offset, test_data, timeout=100)
            # wait for write to complete
            await dev_bar1.read(offset, 0, timeout=5000)
            assert tb.regions[1][offset:offset+length] == test_data

            assert await dev_bar1.read(offset, length, timeout=5000) == test_data

    await RisingEdge(dut.user_clk)
    await RisingEdge(dut.user_clk)


async def run_test_dma(dut, idle_inserter=None, backpressure_inserter=None):

    tb = TB(dut)

    mem = tb.rc.mem_pool.alloc_region(16*1024*1024)
    mem_base = mem.get_absolute_address(0)

    io = tb.rc.io_pool.alloc_region(1024)
    io_base = io.get_absolute_address(0)

    tb.set_idle_generator(idle_inserter)
    tb.set_backpressure_generator(backpressure_inserter)

    await FallingEdge(dut.user_reset)
    await Timer(100, 'ns')

    await tb.rc.enumerate()

    dev = tb.rc.find_device(tb.dev.functions[0].pcie_id)
    await dev.enable_device()
    await dev.set_master()

    for length in list(range(0, 32))+[1024]:
        for offset in list(range(8))+list(range(4096-8, 4096)):
            tb.log.info("Memory operation (DMA) length: %d offset: %d", length, offset)
            addr = mem_base+offset
            test_data = bytearray([x % 256 for x in range(length)])

            await tb.dma_mem_write(addr, test_data, 5000, 'ns')
            # wait for write to complete
            await tb.dma_mem_read(addr, 0, 5000, 'ns')
            assert mem[offset:offset+length] == test_data

            assert await tb.dma_mem_read(addr, length, 5000, 'ns') == test_data

    for length in list(range(0, 8)):
        for offset in list(range(8)):
            tb.log.info("IO operation (DMA) length: %d offset: %d", length, offset)
            addr = io_base+offset
            test_data = bytearray([x % 256 for x in range(length)])

            await tb.dma_io_write(addr, test_data, 5000, 'ns')
            assert io[offset:offset+length] == test_data

            assert await tb.dma_io_read(addr, length, 5000, 'ns') == test_data

    await RisingEdge(dut.user_clk)
    await RisingEdge(dut.user_clk)


async def run_test_msi(dut, idle_inserter=None, backpressure_inserter=None):

    tb = TB(dut)

    tb.set_idle_generator(idle_inserter)
    tb.set_backpressure_generator(backpressure_inserter)

    await FallingEdge(dut.user_reset)
    await Timer(100, 'ns')

    await tb.rc.enumerate()

    dev = tb.rc.find_device(tb.dev.functions[0].pcie_id)
    await dev.enable_device()
    await dev.set_master()
    await dev.alloc_irq_vectors(32, 32)

    assert dut.cfg_interrupt_msi_enable.value.integer & 1

    for k in range(32):
        tb.log.info("Send MSI %d", k)

        await RisingEdge(dut.user_clk)
        tb.dut.cfg_interrupt_msi_int.value = 1 << k
        await RisingEdge(dut.user_clk)
        tb.dut.cfg_interrupt_msi_int.value = 0

        while not tb.dut.cfg_interrupt_msi_sent.value.integer and not tb.dut.cfg_interrupt_msi_fail.value.integer:
            await RisingEdge(dut.user_clk)

        event = dev.msi_vectors[k].event
        event.clear()
        await event.wait()

    await RisingEdge(dut.user_clk)
    await RisingEdge(dut.user_clk)


async def run_test_msix(dut, idle_inserter=None, backpressure_inserter=None):

    tb = TB(dut, msix=True)

    tb.set_idle_generator(idle_inserter)
    tb.set_backpressure_generator(backpressure_inserter)

    await FallingEdge(dut.user_reset)
    await Timer(100, 'ns')

    await tb.rc.enumerate()

    dev = tb.rc.find_device(tb.dev.functions[0].pcie_id)
    await dev.enable_device()
    await dev.set_master()
    await dev.alloc_irq_vectors(64, 64)

    for k in range(64):
        tb.log.info("Send MSI %d", k)

        addr = int.from_bytes(tb.regions[4][16*k+0:16*k+8], 'little')
        data = int.from_bytes(tb.regions[4][16*k+8:16*k+12], 'little')

        await RisingEdge(dut.user_clk)
        tb.dut.cfg_interrupt_msix_address.value = addr
        tb.dut.cfg_interrupt_msix_data.value = data
        tb.dut.cfg_interrupt_msix_int.value = 1
        await RisingEdge(dut.user_clk)
        tb.dut.cfg_interrupt_msix_int.value = 0

        while not tb.dut.cfg_interrupt_msix_sent.value.integer and not tb.dut.cfg_interrupt_msix_fail.value.integer:
            await RisingEdge(dut.user_clk)

        event = dev.msi_vectors[k].event
        event.clear()
        await event.wait()

    await RisingEdge(dut.user_clk)
    await RisingEdge(dut.user_clk)


async def run_test_crs(dut, idle_inserter=None, backpressure_inserter=None):

    tb = TB(dut)

    tb.set_idle_generator(idle_inserter)
    tb.set_backpressure_generator(backpressure_inserter)

    await FallingEdge(dut.user_reset)
    await Timer(100, 'ns')

    async def toggle_config_space_enable(dut):
        dut.cfg_config_space_enable.setimmediatevalue(0)
        await Timer(100, 'us')
        dut.cfg_config_space_enable.setimmediatevalue(1)

    cocotb.start_soon(toggle_config_space_enable(dut))

    await tb.rc.enumerate()

    dev = tb.rc.find_device(tb.dev.functions[0].pcie_id)
    await dev.enable_device()

    dut.cfg_config_space_enable.setimmediatevalue(0)

    val = await dev.config_read_dword(0x00)
    tb.log.info("ID register values: 0x%08x", val)

    assert val == 0xffff0001

    dut.cfg_config_space_enable.setimmediatevalue(1)

    val = await dev.config_read_dword(0x00)
    tb.log.info("ID register values: 0x%08x", val)

    assert val != 0xffff0001 and val != 0xffffffff

    await RisingEdge(dut.user_clk)
    await RisingEdge(dut.user_clk)


def cycle_pause():
    return itertools.cycle([1, 1, 1, 0])


if cocotb.SIM_NAME:

    for test in [
                run_test_mem,
                run_test_dma,
                run_test_msi,
                run_test_msix,
                run_test_crs,
            ]:

        factory = TestFactory(test)
        factory.add_option(("idle_inserter", "backpressure_inserter"), [(None, None), (cycle_pause, cycle_pause)])
        factory.generate_tests()


# cocotb-test

tests_dir = os.path.dirname(__file__)


@pytest.mark.parametrize("client_tag", [True, False])
@pytest.mark.parametrize(("data_width", "straddle"),
    [(64, False), (128, False), (256, False), (256, True)])
def test_pcie_us(request, data_width, straddle, client_tag):
    dut = "test_pcie_us"
    module = os.path.splitext(os.path.basename(__file__))[0]
    toplevel = dut

    verilog_sources = [
        os.path.join(tests_dir, f"{dut}.v"),
    ]

    parameters = {}

    parameters['DATA_WIDTH'] = data_width
    parameters['KEEP_WIDTH'] = (parameters['DATA_WIDTH'] // 32)
    parameters['RQ_USER_WIDTH'] = 60
    parameters['RC_USER_WIDTH'] = 75
    parameters['CQ_USER_WIDTH'] = 85
    parameters['CC_USER_WIDTH'] = 33

    extra_env = {f'PARAM_{k}': str(v) for k, v in parameters.items()}

    extra_env['STRADDLE'] = str(int(straddle))
    extra_env['CLIENT_TAG'] = str(int(client_tag))

    sim_build = os.path.join(tests_dir, "sim_build",
        request.node.name.replace('[', '-').replace(']', ''))

    cocotb_test.simulator.run(
        python_search=[tests_dir],
        verilog_sources=verilog_sources,
        toplevel=toplevel,
        module=module,
        parameters=parameters,
        sim_build=sim_build,
        extra_env=extra_env,
    )



================================================
FILE: tests/pcie_us/test_pcie_us.v
================================================
/*

Copyright (c) 2020 Alex Forencich

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

// Language: Verilog 2001

`resetall
`timescale 1ns / 1ns
`default_nettype none

/*
 * Xilinx UltraScale PCIe IP core model test module
 */
module test_pcie_us #
(
    parameter DATA_WIDTH = 64,
    parameter KEEP_WIDTH = (DATA_WIDTH/32),
    parameter RQ_USER_WIDTH = 60,
    parameter RC_USER_WIDTH = 75,
    parameter CQ_USER_WIDTH = 85,
    parameter CC_USER_WIDTH = 33,
    parameter RC_STRADDLE = 0
)
(
    output                      user_clk,
    output                      user_reset,
    output                      user_lnk_up,
    input  [DATA_WIDTH-1:0]     s_axis_rq_tdata,
    input  [KEEP_WIDTH-1:0]     s_axis_rq_tkeep,
    input                       s_axis_rq_tlast,
    output [3:0]                s_axis_rq_tready,
    input  [RQ_USER_WIDTH-1:0]  s_axis_rq_tuser,
    input                       s_axis_rq_tvalid,
    output [DATA_WIDTH-1:0]     m_axis_rc_tdata,
    output [KEEP_WIDTH-1:0]     m_axis_rc_tkeep,
    output                      m_axis_rc_tlast,
    input                       m_axis_rc_tready,
    output [RC_USER_WIDTH-1:0]  m_axis_rc_tuser,
    output                      m_axis_rc_tvalid,
    output [DATA_WIDTH-1:0]     m_axis_cq_tdata,
    output [KEEP_WIDTH-1:0]     m_axis_cq_tkeep,
    output                      m_axis_cq_tlast,
    input                       m_axis_cq_tready,
    output [CQ_USER_WIDTH-1:0]  m_axis_cq_tuser,
    output                      m_axis_cq_tvalid,
    input  [DATA_WIDTH-1:0]     s_axis_cc_tdata,
    input  [KEEP_WIDTH-1:0]     s_axis_cc_tkeep,
    input                       s_axis_cc_tlast,
    output [3:0]                s_axis_cc_tready,
    input  [CC_USER_WIDTH-1:0]  s_axis_cc_tuser,
    input                       s_axis_cc_tvalid,
    output [3:0]                pcie_rq_seq_num,
    output                      pcie_rq_seq_num_vld,
    output [5:0]                pcie_rq_tag,
    output [1:0]                pcie_rq_tag_av,
    output                      pcie_rq_tag_vld,
    output [1:0]                pcie_tfc_nph_av,
    output [1:0]                pcie_tfc_npd_av,
    input                       pcie_cq_np_req,
    output [5:0]                pcie_cq_np_req_count,
    output                      cfg_phy_link_down,
    output [1:0]                cfg_phy_link_status,
    output [3:0]                cfg_negotiated_width,
    output [2:0]                cfg_current_speed,
    output [2:0]                cfg_max_payload,
    output [2:0]                cfg_max_read_req,
    output [15:0]               cfg_function_status,
    output [11:0]               cfg_function_power_state,
    output [15:0]               cfg_vf_status,
    output [23:0]               cfg_vf_power_state,
    output [1:0]                cfg_link_power_state,
    input  [18:0]               cfg_mgmt_addr,
    input                       cfg_mgmt_write,
    input  [31:0]               cfg_mgmt_write_data,
    input  [3:0]                cfg_mgmt_byte_enable,
    input                       cfg_mgmt_read,
    output [31:0]               cfg_mgmt_read_data,
    output                      cfg_mgmt_read_write_done,
    input                       cfg_mgmt_type1_cfg_reg_access,
    output                      cfg_err_cor_out,
    output                      cfg_err_nonfatal_out,
    output                      cfg_err_fatal_out,
    output                      cfg_local_error,
    output                      cfg_ltr_enable,
    output [5:0]                cfg_ltssm_state,
    output [3:0]                cfg_rcb_status,
    output [3:0]                cfg_dpa_substate_change,
    output [1:0]                cfg_obff_enable,
    output                      cfg_pl_status_change,
    output [3:0]                cfg_tph_requester_enable,
    output [11:0]               cfg_tph_st_mode,
    output [7:0]                cfg_vf_tph_requester_enable,
    output [23:0]               cfg_vf_tph_st_mode,
    output                      cfg_msg_received,
    output [7:0]                cfg_msg_received_data,
    output [4:0]                cfg_msg_received_type,
    input                       cfg_msg_transmit,
    input  [2:0]                cfg_msg_transmit_type,
    input  [31:0]               cfg_msg_transmit_data,
    output                      cfg_msg_transmit_done,
    output [7:0]                cfg_fc_ph,
    output [11:0]               cfg_fc_pd,
    output [7:0]                cfg_fc_nph,
    output [11:0]               cfg_fc_npd,
    output [7:0]                cfg_fc_cplh,
    output [11:0]               cfg_fc_cpld,
    input  [2:0]                cfg_fc_sel,
    input  [2:0]                cfg_per_func_status_control,
    output [15:0]               cfg_per_func_status_data,
    input  [3:0]                cfg_per_function_number,
    input                       cfg_per_function_output_request,
    output                      cfg_per_function_update_done,
    input  [63:0]               cfg_dsn,
    input                       cfg_power_state_change_ack,
    output                      cfg_power_state_change_interrupt,
    input                       cfg_err_cor_in,
    input                       cfg_err_uncor_in,
    output [3:0]                cfg_flr_in_process,
    input  [3:0]                cfg_flr_done,
    output [7:0]                cfg_vf_flr_in_process,
    input  [7:0]                cfg_vf_flr_done,
    input                       cfg_link_training_enable,
    input  [3:0]                cfg_interrupt_int,
    input  [3:0]                cfg_interrupt_pending,
    output                      cfg_interrupt_sent,
    output [3:0]                cfg_interrupt_msi_enable,
    output [7:0]                cfg_interrupt_msi_vf_enable,
    output [11:0]               cfg_interrupt_msi_mmenable,
    output                      cfg_interrupt_msi_mask_update,
    output [31:0]               cfg_interrupt_msi_data,
    input  [3:0]                cfg_interrupt_msi_select,
    input  [31:0]               cfg_interrupt_msi_int,
    input  [31:0]               cfg_interrupt_msi_pending_status,
    input                       cfg_interrupt_msi_pending_status_data_enable,
    input  [3:0]                cfg_interrupt_msi_pending_status_function_num,
    output                      cfg_interrupt_msi_sent,
    output                      cfg_interrupt_msi_fail,
    output [1:0]                cfg_interrupt_msix_enable,
    output [1:0]                cfg_interrupt_msix_mask,
    output [7:0]                cfg_interrupt_msix_vf_enable,
    output [7:0]                cfg_interrupt_msix_vf_mask,
    input  [63:0]               cfg_interrupt_msix_address,
    input  [31:0]               cfg_interrupt_msix_data,
    input                       cfg_interrupt_msix_int,
    output                      cfg_interrupt_msix_sent,
    output                      cfg_interrupt_msix_fail,
    input  [2:0]                cfg_interrupt_msi_attr,
    input                       cfg_interrupt_msi_tph_present,
    input  [1:0]                cfg_interrupt_msi_tph_type,
    input  [8:0]                cfg_interrupt_msi_tph_st_tag,
    input  [3:0]                cfg_interrupt_msi_function_number,
    output                      cfg_hot_reset_out,
    input                       cfg_config_space_enable,
    input                       cfg_req_pm_transition_l23_ready,
    input                       cfg_hot_reset_in,
    input  [7:0]                cfg_ds_port_number,
    input  [7:0]                cfg_ds_bus_number,
    input  [4:0]                cfg_ds_device_number,
    input  [2:0]                cfg_ds_function_number,
    input  [15:0]               cfg_subsys_vend_id,
    input                       sys_clk,
    input                       sys_clk_gt,
    input                       sys_reset,
    input                       pcie_perstn1_in,
    output                      pcie_perstn0_out,
    output                      pcie_perstn1_out,
    output [1:0]                int_qpll1lock_out,
    output [1:0]                int_qpll1outrefclk_out,
    output [1:0]                int_qpll1outclk_out,
    output                      phy_rdy_out
);

endmodule

`resetall



================================================
FILE: tests/pcie_usp/Makefile
================================================
# Copyright (c) 2020 Alex Forencich
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

TOPLEVEL_LANG = verilog

SIM ?= icarus
WAVES ?= 0

COCOTB_HDL_TIMEUNIT = 1ns
COCOTB_HDL_TIMEPRECISION = 1ps

DUT      = test_pcie_usp
TOPLEVEL = $(DUT)
MODULE   = $(DUT)
VERILOG_SOURCES  = $(DUT).v

# module parameters
export PARAM_DATA_WIDTH := 64
export PARAM_KEEP_WIDTH := $(shell expr $(PARAM_DATA_WIDTH) / 32 )
export PARAM_RQ_USER_WIDTH := $(if $(filter-out 512,$(PARAM_DATA_WIDTH)),62,137)
export PARAM_RC_USER_WIDTH := $(if $(filter-out 512,$(PARAM_DATA_WIDTH)),75,161)
export PARAM_CQ_USER_WIDTH := $(if $(filter-out 512,$(PARAM_DATA_WIDTH)),88,183)
export PARAM_CC_USER_WIDTH := $(if $(filter-out 512,$(PARAM_DATA_WIDTH)),33,81)
export STRADDLE := $(if $(filter-out 256 512,$(PARAM_DATA_WIDTH)),0,1)
export CLIENT_TAG := 1

ifeq ($(SIM), icarus)
	PLUSARGS += -fst

	COMPILE_ARGS += $(foreach v,$(filter PARAM_%,$(.VARIABLES)),-P $(TOPLEVEL).$(subst PARAM_,,$(v))=$($(v)))

	ifeq ($(WAVES), 1)
		VERILOG_SOURCES += iverilog_dump.v
		COMPILE_ARGS += -s iverilog_dump
	endif
else ifeq ($(SIM), verilator)
	COMPILE_ARGS += -Wno-SELRANGE -Wno-WIDTH

	COMPILE_ARGS += $(foreach v,$(filter PARAM_%,$(.VARIABLES)),-G$(subst PARAM_,,$(v))=$($(v)))

	ifeq ($(WAVES), 1)
		COMPILE_ARGS += --trace-fst
	endif
endif

include $(shell cocotb-config --makefiles)/Makefile.sim

iverilog_dump.v:
	echo 'module iverilog_dump();' > $@
	echo 'initial begin' >> $@
	echo '    $$dumpfile("$(TOPLEVEL).fst");' >> $@
	echo '    $$dumpvars(0, $(TOPLEVEL));' >> $@
	echo 'end' >> $@
	echo 'endmodule' >> $@

clean::
	@rm -rf iverilog_dump.v
	@rm -rf dump.fst $(TOPLEVEL).fst



================================================
FILE: tests/pcie_usp/test_pcie_usp.py
================================================
#!/usr/bin/env python
"""

Copyright (c) 2020 Alex Forencich

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

"""

import itertools
import logging
import mmap
import os

import cocotb_test.simulator
import pytest

import cocotb
from cocotb.queue import Queue
from cocotb.triggers import RisingEdge, FallingEdge, Timer, Event, First
from cocotb.regression import TestFactory

from cocotbext.axi import AxiStreamBus
from cocotbext.pcie.core import RootComplex
from cocotbext.pcie.xilinx.us import UltraScalePlusPcieDevice
from cocotbext.pcie.xilinx.us.interface import RqSource, RcSink, CqSink, CcSource
from cocotbext.pcie.xilinx.us.tlp import Tlp_us
from cocotbext.pcie.core.tlp import TlpType, CplStatus
from cocotbext.pcie.core.utils import PcieId


class TB:
    def __init__(self, dut, msix=False):
        self.dut = dut

        self.log = logging.getLogger("cocotb.tb")
        self.log.setLevel(logging.DEBUG)

        # PCIe
        self.rc = RootComplex()

        cq_straddle = False
        cc_straddle = False
        rq_straddle = False
        rc_straddle = False
        rc_4tlp_straddle = False
        if int(os.getenv("STRADDLE", "0")):
            if len(dut.s_axis_rq_tdata) == 256:
                rc_straddle = True
            if len(dut.s_axis_rq_tdata) == 512:
                cq_straddle = True
                cc_straddle = True
                rq_straddle = True
                rc_straddle = True
                rc_4tlp_straddle = True

        self.client_tag = bool(int(os.getenv("CLIENT_TAG", "1")))

        self.dev = UltraScalePlusPcieDevice(
            # configuration options
            pcie_generation=3,
            # pcie_link_width=2,
            # user_clk_frequency=250e6,
            alignment="dword",
            cq_straddle=cq_straddle,
            cc_straddle=cc_straddle,
            rq_straddle=rq_straddle,
            rc_straddle=rc_straddle,
            rc_4tlp_straddle=rc_4tlp_straddle,
            pf_count=1,
            max_payload_size=128,
            enable_client_tag=self.client_tag,
            enable_extended_tag=False,
            enable_parity=False,
            enable_rx_msg_interface=False,
            enable_sriov=False,
            enable_extended_configuration=False,

            pf0_msi_enable=True,
            pf0_msi_count=32,
            pf1_msi_enable=False,
            pf1_msi_count=1,
            pf2_msi_enable=False,
            pf2_msi_count=1,
            pf3_msi_enable=False,
            pf3_msi_count=1,
            pf0_msix_enable=msix,
            pf0_msix_table_size=63,
            pf0_msix_table_bir=4,
            pf0_msix_table_offset=0x00000000,
            pf0_msix_pba_bir=4,
            pf0_msix_pba_offset=0x00008000,
            pf1_msix_enable=False,
            pf1_msix_table_size=0,
            pf1_msix_table_bir=0,
            pf1_msix_table_offset=0x00000000,
            pf1_msix_pba_bir=0,
            pf1_msix_pba_offset=0x00000000,
            pf2_msix_enable=False,
            pf2_msix_table_size=0,
            pf2_msix_table_bir=0,
            pf2_msix_table_offset=0x00000000,
            pf2_msix_pba_bir=0,
            pf2_msix_pba_offset=0x00000000,
            pf3_msix_enable=False,
            pf3_msix_table_size=0,
            pf3_msix_table_bir=0,
            pf3_msix_table_offset=0x00000000,
            pf3_msix_pba_bir=0,
            pf3_msix_pba_offset=0x00000000,

            # signals
            user_clk=dut.user_clk,
            user_reset=dut.user_reset,
            user_lnk_up=dut.user_lnk_up,
            sys_clk=dut.sys_clk,
            sys_clk_gt=dut.sys_clk_gt,
            sys_reset=dut.sys_reset,
            phy_rdy_out=dut.phy_rdy_out,

            rq_bus=AxiStreamBus.from_prefix(dut, "s_axis_rq"),
            pcie_rq_seq_num0=dut.pcie_rq_seq_num0,
            pcie_rq_seq_num_vld0=dut.pcie_rq_seq_num_vld0,
            pcie_rq_seq_num1=dut.pcie_rq_seq_num1,
            pcie_rq_seq_num_vld1=dut.pcie_rq_seq_num_vld1,
            pcie_rq_tag0=dut.pcie_rq_tag0,
            pcie_rq_tag1=dut.pcie_rq_tag1,
            pcie_rq_tag_av=dut.pcie_rq_tag_av,
            pcie_rq_tag_vld0=dut.pcie_rq_tag_vld0,
            pcie_rq_tag_vld1=dut.pcie_rq_tag_vld1,

            rc_bus=AxiStreamBus.from_prefix(dut, "m_axis_rc"),

            cq_bus=AxiStreamBus.from_prefix(dut, "m_axis_cq"),
            pcie_cq_np_req=dut.pcie_cq_np_req,
            pcie_cq_np_req_count=dut.pcie_cq_np_req_count,

            cc_bus=AxiStreamBus.from_prefix(dut, "s_axis_cc"),

            pcie_tfc_nph_av=dut.pcie_tfc_nph_av,
            pcie_tfc_npd_av=dut.pcie_tfc_npd_av,
            cfg_phy_link_down=dut.cfg_phy_link_down,
            cfg_phy_link_status=dut.cfg_phy_link_status,
            cfg_negotiated_width=dut.cfg_negotiated_width,
            cfg_current_speed=dut.cfg_current_speed,
            cfg_max_payload=dut.cfg_max_payload,
            cfg_max_read_req=dut.cfg_max_read_req,
            cfg_function_status=dut.cfg_function_status,
            cfg_function_power_state=dut.cfg_function_power_state,
            cfg_vf_status=dut.cfg_vf_status,
            cfg_vf_power_state=dut.cfg_vf_power_state,
            cfg_link_power_state=dut.cfg_link_power_state,
            cfg_mgmt_addr=dut.cfg_mgmt_addr,
            cfg_mgmt_function_number=dut.cfg_mgmt_function_number,
            cfg_mgmt_write=dut.cfg_mgmt_write,
            cfg_mgmt_write_data=dut.cfg_mgmt_write_data,
            cfg_mgmt_byte_enable=dut.cfg_mgmt_byte_enable,
            cfg_mgmt_read=dut.cfg_mgmt_read,
            cfg_mgmt_read_data=dut.cfg_mgmt_read_data,
            cfg_mgmt_read_write_done=dut.cfg_mgmt_read_write_done,
            cfg_mgmt_debug_access=dut.cfg_mgmt_debug_access,
            cfg_err_cor_out=dut.cfg_err_cor_out,
            cfg_err_nonfatal_out=dut.cfg_err_nonfatal_out,
            cfg_err_fatal_out=dut.cfg_err_fatal_out,
            cfg_local_error_valid=dut.cfg_local_error_valid,
            cfg_local_error_out=dut.cfg_local_error_out,
            cfg_ltssm_state=dut.cfg_ltssm_state,
            cfg_rx_pm_state=dut.cfg_rx_pm_state,
            cfg_tx_pm_state=dut.cfg_tx_pm_state,
            cfg_rcb_status=dut.cfg_rcb_status,
            cfg_obff_enable=dut.cfg_obff_enable,
            cfg_pl_status_change=dut.cfg_pl_status_change,
            cfg_tph_requester_enable=dut.cfg_tph_requester_enable,
            cfg_tph_st_mode=dut.cfg_tph_st_mode,
            cfg_vf_tph_requester_enable=dut.cfg_vf_tph_requester_enable,
            cfg_vf_tph_st_mode=dut.cfg_vf_tph_st_mode,
            cfg_msg_received=dut.cfg_msg_received,
            cfg_msg_received_data=dut.cfg_msg_received_data,
            cfg_msg_received_type=dut.cfg_msg_received_type,
            cfg_msg_transmit=dut.cfg_msg_transmit,
            cfg_msg_transmit_type=dut.cfg_msg_transmit_type,
            cfg_msg_transmit_data=dut.cfg_msg_transmit_data,
            cfg_msg_transmit_done=dut.cfg_msg_transmit_done,
            cfg_fc_ph=dut.cfg_fc_ph,
            cfg_fc_pd=dut.cfg_fc_pd,
            cfg_fc_nph=dut.cfg_fc_nph,
            cfg_fc_npd=dut.cfg_fc_npd,
            cfg_fc_cplh=dut.cfg_fc_cplh,
            cfg_fc_cpld=dut.cfg_fc_cpld,
            cfg_fc_sel=dut.cfg_fc_sel,
            cfg_dsn=dut.cfg_dsn,
            cfg_bus_number=dut.cfg_bus_number,
            cfg_power_state_change_ack=dut.cfg_power_state_change_ack,
            cfg_power_state_change_interrupt=dut.cfg_power_state_change_interrupt,
            cfg_err_cor_in=dut.cfg_err_cor_in,
            cfg_err_uncor_in=dut.cfg_err_uncor_in,
            cfg_flr_in_process=dut.cfg_flr_in_process,
            cfg_flr_done=dut.cfg_flr_done,
            cfg_vf_flr_in_process=dut.cfg_vf_flr_in_process,
            cfg_vf_flr_func_num=dut.cfg_vf_flr_func_num,
            cfg_vf_flr_done=dut.cfg_vf_flr_done,
            cfg_link_training_enable=dut.cfg_link_training_enable,
            cfg_interrupt_int=dut.cfg_interrupt_int,
            cfg_interrupt_pending=dut.cfg_interrupt_pending,
            cfg_interrupt_sent=dut.cfg_interrupt_sent,
            cfg_interrupt_msi_enable=dut.cfg_interrupt_msi_enable,
            cfg_interrupt_msi_mmenable=dut.cfg_interrupt_msi_mmenable,
            cfg_interrupt_msi_mask_update=dut.cfg_interrupt_msi_mask_update,
            cfg_interrupt_msi_data=dut.cfg_interrupt_msi_data,
            cfg_interrupt_msi_select=dut.cfg_interrupt_msi_select,
            cfg_interrupt_msi_int=dut.cfg_interrupt_msi_int,
            cfg_interrupt_msi_pending_status=dut.cfg_interrupt_msi_pending_status,
            cfg_interrupt_msi_pending_status_data_enable=dut.cfg_interrupt_msi_pending_status_data_enable,
            cfg_interrupt_msi_pending_status_function_num=dut.cfg_interrupt_msi_pending_status_function_num,
            cfg_interrupt_msi_sent=dut.cfg_interrupt_msi_sent,
            cfg_interrupt_msi_fail=dut.cfg_interrupt_msi_fail,
            cfg_interrupt_msix_enable=dut.cfg_interrupt_msix_enable,
            cfg_interrupt_msix_mask=dut.cfg_interrupt_msix_mask,
            cfg_interrupt_msix_vf_enable=dut.cfg_interrupt_msix_vf_enable,
            cfg_interrupt_msix_vf_mask=dut.cfg_interrupt_msix_vf_mask,
            cfg_interrupt_msix_address=dut.cfg_interrupt_msix_address,
            cfg_interrupt_msix_data=dut.cfg_interrupt_msix_data,
            cfg_interrupt_msix_int=dut.cfg_interrupt_msix_int,
            cfg_interrupt_msix_vec_pending=dut.cfg_interrupt_msix_vec_pending,
            cfg_interrupt_msix_vec_pending_status=dut.cfg_interrupt_msix_vec_pending_status,
            cfg_interrupt_msix_sent=dut.cfg_interrupt_msix_sent,
            cfg_interrupt_msix_fail=dut.cfg_interrupt_msix_fail,
            cfg_interrupt_msi_attr=dut.cfg_interrupt_msi_attr,
            cfg_interrupt_msi_tph_present=dut.cfg_interrupt_msi_tph_present,
            cfg_interrupt_msi_tph_type=dut.cfg_interrupt_msi_tph_type,
            cfg_interrupt_msi_tph_st_tag=dut.cfg_interrupt_msi_tph_st_tag,
            cfg_interrupt_msi_function_number=dut.cfg_interrupt_msi_function_number,
            cfg_pm_aspm_l1_entry_reject=dut.cfg_pm_aspm_l1_entry_reject,
            cfg_pm_aspm_tx_l0s_entry_disable=dut.cfg_pm_aspm_tx_l0s_entry_disable,
            cfg_hot_reset_out=dut.cfg_hot_reset_out,
            cfg_config_space_enable=dut.cfg_config_space_enable,
            cfg_req_pm_transition_l23_ready=dut.cfg_req_pm_transition_l23_ready,
            cfg_hot_reset_in=dut.cfg_hot_reset_in,
            cfg_ds_port_number=dut.cfg_ds_port_number,
            cfg_ds_bus_number=dut.cfg_ds_bus_number,
            cfg_ds_device_number=dut.cfg_ds_device_number,
        )

        self.dev.log.setLevel(logging.DEBUG)

        dut.pcie_cq_np_req.setimmediatevalue(1)
        dut.cfg_mgmt_addr.setimmediatevalue(0)
        dut.cfg_mgmt_function_number.setimmediatevalue(0)
        dut.cfg_mgmt_write.setimmediatevalue(0)
        dut.cfg_mgmt_write_data.setimmediatevalue(0)
        dut.cfg_mgmt_byte_enable.setimmediatevalue(0)
        dut.cfg_mgmt_read.setimmediatevalue(0)
        dut.cfg_mgmt_debug_access.setimmediatevalue(0)
        dut.cfg_msg_transmit.setimmediatevalue(0)
        dut.cfg_msg_transmit_type.setimmediatevalue(0)
        dut.cfg_msg_transmit_data.setimmediatevalue(0)
        dut.cfg_fc_sel.setimmediatevalue(0)
        dut.cfg_dsn.setimmediatevalue(0)
        dut.cfg_power_state_change_ack.setimmediatevalue(0)
        dut.cfg_err_cor_in.setimmediatevalue(0)
        dut.cfg_err_uncor_in.setimmediatevalue(0)
        dut.cfg_flr_done.setimmediatevalue(0)
        dut.cfg_vf_flr_func_num.setimmediatevalue(0)
        dut.cfg_vf_flr_done.setimmediatevalue(0)
        dut.cfg_link_training_enable.setimmediatevalue(1)
        dut.cfg_interrupt_int.setimmediatevalue(0)
        dut.cfg_interrupt_pending.setimmediatevalue(0)
        dut.cfg_interrupt_msi_select.setimmediatevalue(0)
        dut.cfg_interrupt_msi_int.setimmediatevalue(0)
        dut.cfg_interrupt_msi_pending_status.setimmediatevalue(0)
        dut.cfg_interrupt_msi_pending_status_data_enable.setimmediatevalue(0)
        dut.cfg_interrupt_msi_pending_status_function_num.setimmediatevalue(0)
        dut.cfg_interrupt_msix_address.setimmediatevalue(0)
        dut.cfg_interrupt_msix_data.setimmediatevalue(0)
        dut.cfg_interrupt_msix_int.setimmediatevalue(0)
        dut.cfg_interrupt_msix_vec_pending.setimmediatevalue(0)
        dut.cfg_interrupt_msi_attr.setimmediatevalue(0)
        dut.cfg_interrupt_msi_tph_present.setimmediatevalue(0)
        dut.cfg_interrupt_msi_tph_type.setimmediatevalue(0)
        dut.cfg_interrupt_msi_tph_st_tag.setimmediatevalue(0)
        dut.cfg_interrupt_msi_function_number.setimmediatevalue(0)
        dut.cfg_pm_aspm_l1_entry_reject.setimmediatevalue(0)
        dut.cfg_pm_aspm_tx_l0s_entry_disable.setimmediatevalue(0)
        dut.cfg_config_space_enable.setimmediatevalue(1)
        dut.cfg_req_pm_transition_l23_ready.setimmediatevalue(0)
        dut.cfg_hot_reset_in.setimmediatevalue(0)
        dut.cfg_ds_port_number.setimmediatevalue(0)
        dut.cfg_ds_bus_number.setimmediatevalue(0)
        dut.cfg_ds_device_number.setimmediatevalue(0)
        dut.sys_clk.setimmediatevalue(0)
        dut.sys_clk_gt.setimmediatevalue(0)
        dut.sys_reset.setimmediatevalue(1)

        self.rc.make_port().connect(self.dev)

        # user logic
        cq_segments = 2 if cq_straddle else 1
        cc_segments = 2 if cc_straddle else 1
        rq_segments = 2 if rq_straddle else 1
        rc_segments = 4 if rc_4tlp_straddle else (2 if rc_straddle else 1)

        self.rq_source = RqSource(AxiStreamBus.from_prefix(dut, "s_axis_rq"), dut.user_clk, dut.user_reset, segments=rq_segments)
        self.rc_sink = RcSink(AxiStreamBus.from_prefix(dut, "m_axis_rc"), dut.user_clk, dut.user_reset, segments=rc_segments)
        self.cq_sink = CqSink(AxiStreamBus.from_prefix(dut, "m_axis_cq"), dut.user_clk, dut.user_reset, segments=cq_segments)
        self.cc_source = CcSource(AxiStreamBus.from_prefix(dut, "s_axis_cc"), dut.user_clk, dut.user_reset, segments=cc_segments)

        self.regions = [None]*6
        self.regions[0] = mmap.mmap(-1, 1024*1024)
        self.regions[1] = mmap.mmap(-1, 1024*1024)
        self.regions[3] = mmap.mmap(-1, 1024)
        self.regions[4] = mmap.mmap(-1, 1024*64)

        self.current_tag = 0
        self.tag_count = 256
        self.tag_active = [False]*256
        self.tag_release = Event()

        self.rq_tag = Queue()

        self.rx_cpl_queues = [Queue() for k in range(256)]
        self.rx_cpl_sync = [Event() for k in range(256)]

        self.dev.functions[0].configure_bar(0, len(self.regions[0]))
        self.dev.functions[0].configure_bar(1, len(self.regions[1]), True, True)
        self.dev.functions[0].configure_bar(3, len(self.regions[3]), False, False, True)
        self.dev.functions[0].configure_bar(4, len(self.regions[4]))

        if not self.client_tag:
            cocotb.start_soon(self._run_rq_tags())
        cocotb.start_soon(self._run_rc())
        cocotb.start_soon(self._run_cq())

    def set_idle_generator(self, generator=None):
        if generator:
            self.dev.rc_source.set_pause_generator(generator())
            self.dev.cq_source.set_pause_generator(generator())

    def set_backpressure_generator(self, generator=None):
        if generator:
            self.dev.rq_sink.set_pause_generator(generator())
            self.dev.cc_sink.set_pause_generator(generator())

    async def recv_cpl(self, tag, timeout=0, timeout_unit='ns'):
        queue = self.rx_cpl_queues[tag]
        sync = self.rx_cpl_sync[tag]

        if not queue.empty():
            return queue.get_nowait()

        sync.clear()
        if timeout:
            await First(sync.wait(), Timer(timeout, timeout_unit))
        else:
            await sync.wait()

        if not queue.empty():
            return queue.get_nowait()

        return None

    async def alloc_tag(self):
        tag_count = min(256 if self.dev.functions[0].pcie_cap.extended_tag_field_enable else 32, self.tag_count)

        while True:
            tag = self.current_tag
            for k in range(tag_count):
                tag = (tag + 1) % tag_count
                if not self.tag_active[tag]:
                    self.tag_active[tag] = True
                    self.current_tag = tag
                    return tag

            self.tag_release.clear()
            await self.tag_release.wait()

    def release_tag(self, tag):
        assert self.tag_active[tag]
        self.tag_active[tag] = False
        self.tag_release.set()

    async def perform_posted_operation(self, req):
        await self.rq_source.send(req.pack_us_rq())

    async def perform_nonposted_operation(self, req, timeout=0, timeout_unit='ns'):
        completions = []

        if self.client_tag:
            req.tag = await self.alloc_tag()
            await self.rq_source.send(req.pack_us_rq())
        else:
            await self.rq_source.send(req.pack_us_rq())
            req.tag = await self.rq_tag.get()

        while True:
            cpl = await self.recv_cpl(req.tag, timeout, timeout_unit)

            if not cpl:
                break

            completions.append(cpl)

            if cpl.status != CplStatus.SC:
                # bad status
                break
            elif req.fmt_type in {TlpType.MEM_READ, TlpType.MEM_READ_64}:
                # completion for memory read request

                # request completed
                if cpl.byte_count <= cpl.length*4 - (cpl.lower_address & 0x3):
                    break

                # completion for read request has SC status but no data
                if cpl.fmt_type in {TlpType.CPL, TlpType.CPL_LOCKED}:
                    break

            else:
                # completion for other request
                break

        if self.client_tag:
            self.release_tag(req.tag)

        return completions

    async def dma_io_write(self, addr, data, timeout=0, timeout_unit='ns'):
        n = 0

        zero_len = len(data) == 0
        if zero_len:
            data = b'\x00'

        op_list = []

        while n < len(data):
            req = Tlp_us()
            req.fmt_type = TlpType.IO_WRITE
            req.requester_id = PcieId(0, 0, 0)

            first_pad = addr % 4
            byte_length = min(len(data)-n, 4-first_pad)
            req.set_addr_be_data(addr, data[n:n+byte_length])

            if zero_len:
                req.first_be = 0

            op_list.append(cocotb.start_soon(self.perform_nonposted_operation(req, timeout, timeout_unit)))

            n += byte_length
            addr += byte_length

        for op in op_list:
            cpl_list = await op.join()

            if not cpl_list:
                raise Exception("Timeout")
            if cpl_list[0].status != CplStatus.SC:
                raise Exception("Unsuccessful completion")

    async def dma_io_read(self, addr, length, timeout=0, timeout_unit='ns'):
        data = bytearray()
        n = 0

        zero_len = length <= 0
        if zero_len:
            length = 1

        op_list = []

        while n < length:
            req = Tlp_us()
            req.fmt_type = TlpType.IO_READ
            req.requester_id = PcieId(0, 0, 0)

            first_pad = addr % 4
            byte_length = min(length-n, 4-first_pad)
            req.set_addr_be(addr, byte_length)

            if zero_len:
                req.first_be = 0

            op_list.append((first_pad, cocotb.start_soon(self.perform_nonposted_operation(req, timeout, timeout_unit))))

            n += byte_length
            addr += byte_length

        for first_pad, op in op_list:
            cpl_list = await op.join()

            if not cpl_list:
                raise Exception("Timeout")
            cpl = cpl_list[0]
            if cpl.status != CplStatus.SC:
                raise Exception("Unsuccessful completion")

            assert cpl.length == 1
            d = cpl.get_data()

            data.extend(d[first_pad:])

        if zero_len:
            return b''

        return bytes(data[:length])

    async def dma_mem_write(self, addr, data, timeout=0, timeout_unit='ns'):
        n = 0

        zero_len = len(data) == 0
        if zero_len:
            data = b'\x00'

        while n < len(data):
            req = Tlp_us()
            if addr > 0xffffffff:
                req.fmt_type = TlpType.MEM_WRITE_64
            else:
                req.fmt_type = TlpType.MEM_WRITE
            req.requester_id = PcieId(0, 0, 0)

            first_pad = addr % 4
            byte_length = len(data)-n
            # max payload size
            byte_length = min(byte_length, (128 << self.dut.cfg_max_payload.value.integer)-first_pad)
            # 4k address align
            byte_length = min(byte_length, 0x1000 - (addr & 0xfff))
            req.set_addr_be_data(addr, data[n:n+byte_length])

            if zero_len:
                req.first_be = 0

            await self.perform_posted_operation(req)

            n += byte_length
            addr += byte_length

    async def dma_mem_read(self, addr, length, timeout=0, timeout_unit='ns'):
        data = bytearray()
        n = 0

        zero_len = length <= 0
        if zero_len:
            length = 1

        op_list = []

        while n < length:
            req = Tlp_us()
            if addr > 0xffffffff:
                req.fmt_type = TlpType.MEM_READ_64
            else:
                req.fmt_type = TlpType.MEM_READ
            req.requester_id = PcieId(0, 0, 0)

            first_pad = addr % 4
            # remaining length
            byte_length = length-n
            # limit to max read request size
            if byte_length > (128 << self.dut.cfg_max_read_req.value.integer) - first_pad:
                # split on 128-byte read completion boundary
                byte_length = min(byte_length, (128 << self.dut.cfg_max_read_req.value.integer) - (addr & 0x7f))
            # 4k align
            byte_length = min(byte_length, 0x1000 - (addr & 0xfff))
            req.set_addr_be(addr, byte_length)

            if zero_len:
                req.first_be = 0

            op_list.append((byte_length, cocotb.start_soon(self.perform_nonposted_operation(req, timeout, timeout_unit))))

            n += byte_length
            addr += byte_length

        for byte_length, op in op_list:
            cpl_list = await op.join()

            m = 0

            while m < byte_length:
                if not cpl_list:
                    raise Exception("Timeout")

                cpl = cpl_list.pop(0)

                if cpl.status != CplStatus.SC:
                    raise Exception("Unsuccessful completion")

                assert cpl.byte_count+3+(cpl.lower_address & 3) >= cpl.length*4
                assert cpl.byte_count == max(byte_length - m, 1)

                d = cpl.get_data()

                offset = cpl.lower_address & 3
                data.extend(d[offset:offset+cpl.byte_count])

                m += len(d)-offset

        if zero_len:
            return b''

        return bytes(data[:length])

    async def _run_rq_tags(self):
        clock_edge_event = RisingEdge(self.dut.user_clk)

        while True:
            await clock_edge_event

            if self.dut.pcie_rq_tag_vld0.value:
                self.rq_tag.put_nowait(self.dut.pcie_rq_tag0.value.integer)
            if self.dut.pcie_rq_tag_vld1.value:
                self.rq_tag.put_nowait(self.dut.pcie_rq_tag1.value.integer)

    async def _run_rc(self):
        while True:
            pkt = await self.rc_sink.recv()

            tlp = Tlp_us.unpack_us_rc(pkt)

            self.log.debug("RC TLP: %s", repr(tlp))

            self.rx_cpl_queues[tlp.tag].put_nowait(tlp)
            self.rx_cpl_sync[tlp.tag].set()

    async def _run_cq(self):
        while True:
            pkt = await self.cq_sink.recv()

            tlp = Tlp_us.unpack_us_cq(pkt)

            self.log.debug("CQ TLP: %s", repr(tlp))

            if tlp.fmt_type == TlpType.IO_READ:
                self.log.info("IO read")

                cpl = Tlp_us.create_completion_data_for_tlp(tlp, PcieId(0, 0, 0))

                region = tlp.bar_id
                addr = tlp.address % len(self.regions[region])
                offset = 0
                start_offset = None
                mask = tlp.first_be

                # perform operation
                data = bytearray(4)

                for k in range(4):
                    if mask & (1 << k):
                        if start_offset is None:
                            start_offset = offset
                    else:
                        if start_offset is not None and offset != start_offset:
                            data[start_offset:offset] = self.regions[region][addr+start_offset:addr+offset]
                        start_offset = None

                    offset += 1

                if start_offset is not None and offset != start_offset:
                    data[start_offset:offset] = self.regions[region][addr+start_offset:addr+offset]

                cpl.set_data(data)
                cpl.byte_count = 4
                cpl.length = 1

                self.log.debug("Completion: %s", repr(cpl))
                await self.cc_source.send(cpl.pack_us_cc())

            elif tlp.fmt_type == TlpType.IO_WRITE:
                self.log.info("IO write")

                cpl = Tlp_us.create_completion_for_tlp(tlp, PcieId(0, 0, 0))

                region = tlp.bar_id
                addr = tlp.address % len(self.regions[region])
                offset = 0
                start_offset = None
                mask = tlp.first_be

                # perform operation
                data = tlp.get_data()

                for k in range(4):
                    if mask & (1 << k):
                        if start_offset is None:
                            start_offset = offset
                    else:
                        if start_offset is not None and offset != start_offset:
                            self.regions[region][addr+start_offset:addr+offset] = data[start_offset:offset]
                        start_offset = None

                    offset += 1

                if start_offset is not None and offset != start_offset:
                    self.regions[region][addr+start_offset:addr+offset] = data[start_offset:offset]

                self.log.debug("Completion: %s", repr(cpl))
                await self.cc_source.send(cpl.pack_us_cc())

            elif tlp.fmt_type in {TlpType.MEM_READ, TlpType.MEM_READ_64}:
                self.log.info("Memory read")

                # perform operation
                region = tlp.bar_id
                addr = tlp.address % len(self.regions[region])
                offset = 0
                length = tlp.length

                # perform read
                data = self.regions[region][addr:addr+length*4]

                # prepare completion TLP(s)
                m = 0
                n = 0
                addr = tlp.address+tlp.get_first_be_offset()
                dw_length = tlp.length
                byte_length = tlp.get_be_byte_count()

                while m < dw_length:
                    cpl = Tlp_us.create_completion_data_for_tlp(tlp, PcieId(0, 0, 0))

                    cpl_dw_length = dw_length - m
                    cpl_byte_length = byte_length - n
                    cpl.byte_count = cpl_byte_length
                    if cpl_dw_length > 32 << self.dut.cfg_max_payload.value.integer:
                        # max payload size
                        cpl_dw_length = 32 << self.dut.cfg_max_payload.value.integer
                        # RCB align
                        cpl_dw_length -= (addr & 0x7c) >> 2

                    cpl.lower_address = addr & 0x7f

                    cpl.set_data(data[m*4:(m+cpl_dw_length)*4])

                    self.log.debug("Completion: %s", repr(cpl))
                    await self.cc_source.send(cpl.pack_us_cc())

                    m += cpl_dw_length
                    n += cpl_dw_length*4 - (addr & 3)
                    addr += cpl_dw_length*4 - (addr & 3)

            elif tlp.fmt_type in {TlpType.MEM_WRITE, TlpType.MEM_WRITE_64}:
                self.log.info("Memory write")

                # perform operation
                region = tlp.bar_id
                addr = tlp.address % len(self.regions[region])
                offset = 0
                start_offset = None
                mask = tlp.first_be
                length = tlp.length

                # perform write
                data = tlp.get_data()

                # first dword
                for k in range(4):
                    if mask & (1 << k):
                        if start_offset is None:
                            start_offset = offset
                    else:
                        if start_offset is not None and offset != start_offset:
                            self.regions[region][addr+start_offset:addr+offset] = data[start_offset:offset]
                        start_offset = None

                    offset += 1

                if length > 2:
                    # middle dwords
                    if start_offset is None:
                        start_offset = offset
                    offset += (length-2)*4

                if length > 1:
                    # last dword
                    mask = tlp.last_be

                    for k in range(4):
                        if mask & (1 << k):
                            if start_offset is None:
                                start_offset = offset
                        else:
                            if start_offset is not None and offset != start_offset:
                                self.regions[region][addr+start_offset:addr+offset] = data[start_offset:offset]
                            start_offset = None

                        offset += 1

                if start_offset is not None and offset != start_offset:
                    self.regions[region][addr+start_offset:addr+offset] = data[start_offset:offset]


async def run_test_mem(dut, idle_inserter=None, backpressure_inserter=None):

    tb = TB(dut)

    tb.set_idle_generator(idle_inserter)
    tb.set_backpressure_generator(backpressure_inserter)

    await FallingEdge(dut.user_reset)
    await Timer(100, 'ns')

    await tb.rc.enumerate()

    dev = tb.rc.find_device(tb.dev.functions[0].pcie_id)
    await dev.enable_device()

    dev_bar0 = dev.bar_window[0]
    dev_bar1 = dev.bar_window[1]
    dev_bar3 = dev.bar_window[3]

    for length in list(range(0, 8)):
        for offset in list(range(8)):
            tb.log.info("IO operation length: %d offset: %d", length, offset)
            test_data = bytearray([x % 256 for x in range(length)])

            await dev_bar3.write(offset, test_data, timeout=5000)
            assert tb.regions[3][offset:offset+length] == test_data

            assert await dev_bar3.read(offset, length, timeout=5000) == test_data

    for length in list(range(0, 32))+[1024]:
        for offset in list(range(8))+list(range(4096-8, 4096)):
            tb.log.info("Memory operation (32-bit BAR) length: %d offset: %d", length, offset)
            test_data = bytearray([x % 256 for x in range(length)])

            await dev_bar0.write(offset, test_data, timeout=100)
            # wait for write to complete
            await dev_bar0.read(offset, 0, timeout=5000)
            assert tb.regions[0][offset:offset+length] == test_data

            assert await dev_bar0.read(offset, length, timeout=5000) == test_data

    for length in list(range(0, 32))+[1024]:
        for offset in list(range(8))+list(range(4096-8, 4096)):
            tb.log.info("Memory operation (64-bit BAR) length: %d offset: %d", length, offset)
            test_data = bytearray([x % 256 for x in range(length)])

            await dev_bar1.write(offset, test_data, timeout=100)
            # wait for write to complete
            await dev_bar1.read(offset, 0, timeout=5000)
            assert tb.regions[1][offset:offset+length] == test_data

            assert await dev_bar1.read(offset, length, timeout=5000) == test_data

    await RisingEdge(dut.user_clk)
    await RisingEdge(dut.user_clk)


async def run_test_dma(dut, idle_inserter=None, backpressure_inserter=None):

    tb = TB(dut)

    mem = tb.rc.mem_pool.alloc_region(16*1024*1024)
    mem_base = mem.get_absolute_address(0)

    io = tb.rc.io_pool.alloc_region(1024)
    io_base = io.get_absolute_address(0)

    tb.set_idle_generator(idle_inserter)
    tb.set_backpressure_generator(backpressure_inserter)

    await FallingEdge(dut.user_reset)
    await Timer(100, 'ns')

    await tb.rc.enumerate()

    dev = tb.rc.find_device(tb.dev.functions[0].pcie_id)
    await dev.enable_device()
    await dev.set_master()

    for length in list(range(0, 32))+[1024]:
        for offset in list(range(8))+list(range(4096-8, 4096)):
            tb.log.info("Memory operation (DMA) length: %d offset: %d", length, offset)
            addr = mem_base+offset
            test_data = bytearray([x % 256 for x in range(length)])

            await tb.dma_mem_write(addr, test_data, 5000, 'ns')
            # wait for write to complete
            await tb.dma_mem_read(addr, 0, 5000, 'ns')
            assert mem[offset:offset+length] == test_data

            assert await tb.dma_mem_read(addr, length, 5000, 'ns') == test_data

    for length in list(range(0, 8)):
        for offset in list(range(8)):
            tb.log.info("IO operation (DMA) length: %d offset: %d", length, offset)
            addr = io_base+offset
            test_data = bytearray([x % 256 for x in range(length)])

            await tb.dma_io_write(addr, test_data, 5000, 'ns')
            assert io[offset:offset+length] == test_data

            assert await tb.dma_io_read(addr, length, 5000, 'ns') == test_data

    await RisingEdge(dut.user_clk)
    await RisingEdge(dut.user_clk)


async def run_test_msi(dut, idle_inserter=None, backpressure_inserter=None):

    tb = TB(dut)

    tb.set_idle_generator(idle_inserter)
    tb.set_backpressure_generator(backpressure_inserter)

    await FallingEdge(dut.user_reset)
    await Timer(100, 'ns')

    await tb.rc.enumerate()

    dev = tb.rc.find_device(tb.dev.functions[0].pcie_id)
    await dev.enable_device()
    await dev.set_master()
    await dev.alloc_irq_vectors(32, 32)

    assert dut.cfg_interrupt_msi_enable.value.integer & 1

    for k in range(32):
        tb.log.info("Send MSI %d", k)

        await RisingEdge(dut.user_clk)
        tb.dut.cfg_interrupt_msi_int.value = 1 << k
        await RisingEdge(dut.user_clk)
        tb.dut.cfg_interrupt_msi_int.value = 0

        while not tb.dut.cfg_interrupt_msi_sent.value.integer and not tb.dut.cfg_interrupt_msi_fail.value.integer:
            await RisingEdge(dut.user_clk)

        event = dev.msi_vectors[k].event
        event.clear()
        await event.wait()

    await RisingEdge(dut.user_clk)
    await RisingEdge(dut.user_clk)


async def run_test_msix(dut, idle_inserter=None, backpressure_inserter=None):

    tb = TB(dut, msix=True)

    tb.set_idle_generator(idle_inserter)
    tb.set_backpressure_generator(backpressure_inserter)

    await FallingEdge(dut.user_reset)
    await Timer(100, 'ns')

    await tb.rc.enumerate()

    dev = tb.rc.find_device(tb.dev.functions[0].pcie_id)
    await dev.enable_device()
    await dev.set_master()
    await dev.alloc_irq_vectors(64, 64)

    for k in range(64):
        tb.log.info("Send MSI %d", k)

        addr = int.from_bytes(tb.regions[4][16*k+0:16*k+8], 'little')
        data = int.from_bytes(tb.regions[4][16*k+8:16*k+12], 'little')

        await RisingEdge(dut.user_clk)
        tb.dut.cfg_interrupt_msix_address.value = addr
        tb.dut.cfg_interrupt_msix_data.value = data
        tb.dut.cfg_interrupt_msix_int.value = 1
        await RisingEdge(dut.user_clk)
        tb.dut.cfg_interrupt_msix_int.value = 0

        while not tb.dut.cfg_interrupt_msix_sent.value.integer and not tb.dut.cfg_interrupt_msix_fail.value.integer:
            await RisingEdge(dut.user_clk)

        event = dev.msi_vectors[k].event
        event.clear()
        await event.wait()

    await RisingEdge(dut.user_clk)
    await RisingEdge(dut.user_clk)


async def run_test_crs(dut, idle_inserter=None, backpressure_inserter=None):

    tb = TB(dut)

    tb.set_idle_generator(idle_inserter)
    tb.set_backpressure_generator(backpressure_inserter)

    await FallingEdge(dut.user_reset)
    await Timer(100, 'ns')

    async def toggle_config_space_enable(dut):
        dut.cfg_config_space_enable.setimmediatevalue(0)
        await Timer(100, 'us')
        dut.cfg_config_space_enable.setimmediatevalue(1)

    cocotb.start_soon(toggle_config_space_enable(dut))

    await tb.rc.enumerate()

    dev = tb.rc.find_device(tb.dev.functions[0].pcie_id)
    await dev.enable_device()

    dut.cfg_config_space_enable.setimmediatevalue(0)

    val = await dev.config_read_dword(0x00)
    tb.log.info("ID register values: 0x%08x", val)

    assert val == 0xffff0001

    dut.cfg_config_space_enable.setimmediatevalue(1)

    val = await dev.config_read_dword(0x00)
    tb.log.info("ID register values: 0x%08x", val)

    assert val != 0xffff0001 and val != 0xffffffff

    await RisingEdge(dut.user_clk)
    await RisingEdge(dut.user_clk)


def cycle_pause():
    return itertools.cycle([1, 1, 1, 0])


if cocotb.SIM_NAME:

    for test in [
                run_test_mem,
                run_test_dma,
                run_test_msi,
                run_test_msix,
                run_test_crs,
            ]:

        factory = TestFactory(test)
        factory.add_option(("idle_inserter", "backpressure_inserter"), [(None, None), (cycle_pause, cycle_pause)])
        factory.generate_tests()


# cocotb-test

tests_dir = os.path.dirname(__file__)


@pytest.mark.parametrize("client_tag", [True, False])
@pytest.mark.parametrize(("data_width", "straddle"),
    [(64, False), (128, False), (256, False), (256, True), (512, False), (512, True)])
def test_pcie_usp(request, data_width, straddle, client_tag):
    dut = "test_pcie_usp"
    module = os.path.splitext(os.path.basename(__file__))[0]
    toplevel = dut

    verilog_sources = [
        os.path.join(tests_dir, f"{dut}.v"),
    ]

    parameters = {}

    parameters['DATA_WIDTH'] = data_width
    parameters['KEEP_WIDTH'] = (parameters['DATA_WIDTH'] // 32)
    parameters['RQ_USER_WIDTH'] = 62 if parameters['DATA_WIDTH'] < 512 else 137
    parameters['RC_USER_WIDTH'] = 75 if parameters['DATA_WIDTH'] < 512 else 161
    parameters['CQ_USER_WIDTH'] = 88 if parameters['DATA_WIDTH'] < 512 else 183
    parameters['CC_USER_WIDTH'] = 33 if parameters['DATA_WIDTH'] < 512 else 81

    extra_env = {f'PARAM_{k}': str(v) for k, v in parameters.items()}

    extra_env['STRADDLE'] = str(int(straddle))
    extra_env['CLIENT_TAG'] = str(int(client_tag))

    sim_build = os.path.join(tests_dir, "sim_build",
        request.node.name.replace('[', '-').replace(']', ''))

    cocotb_test.simulator.run(
        python_search=[tests_dir],
        verilog_sources=verilog_sources,
        toplevel=toplevel,
        module=module,
        parameters=parameters,
        sim_build=sim_build,
        extra_env=extra_env,
    )



================================================
FILE: tests/pcie_usp/test_pcie_usp.v
================================================
/*

Copyright (c) 2020 Alex Forencich

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

// Language: Verilog 2001

`resetall
`timescale 1ns / 1ns
`default_nettype none

/*
 * Xilinx UltraScale+ PCIe IP core model test module
 */
module test_pcie_usp #
(
    parameter DATA_WIDTH = 64,
    parameter KEEP_WIDTH = (DATA_WIDTH/32),
    parameter RQ_USER_WIDTH = 62,
    parameter RC_USER_WIDTH = 75,
    parameter CQ_USER_WIDTH = 88,
    parameter CC_USER_WIDTH = 33
)
(
    output                      user_clk,
    output                      user_reset,
    output                      user_lnk_up,
    input  [DATA_WIDTH-1:0]     s_axis_rq_tdata,
    input  [KEEP_WIDTH-1:0]     s_axis_rq_tkeep,
    input                       s_axis_rq_tlast,
    output [3:0]                s_axis_rq_tready,
    input  [RQ_USER_WIDTH-1:0]  s_axis_rq_tuser,
    input                       s_axis_rq_tvalid,
    output [DATA_WIDTH-1:0]     m_axis_rc_tdata,
    output [KEEP_WIDTH-1:0]     m_axis_rc_tkeep,
    output                      m_axis_rc_tlast,
    input                       m_axis_rc_tready,
    output [RC_USER_WIDTH-1:0]  m_axis_rc_tuser,
    output                      m_axis_rc_tvalid,
    output [DATA_WIDTH-1:0]     m_axis_cq_tdata,
    output [KEEP_WIDTH-1:0]     m_axis_cq_tkeep,
    output                      m_axis_cq_tlast,
    input                       m_axis_cq_tready,
    output [CQ_USER_WIDTH-1:0]  m_axis_cq_tuser,
    output                      m_axis_cq_tvalid,
    input  [DATA_WIDTH-1:0]     s_axis_cc_tdata,
    input  [KEEP_WIDTH-1:0]     s_axis_cc_tkeep,
    input                       s_axis_cc_tlast,
    output [3:0]                s_axis_cc_tready,
    input  [CC_USER_WIDTH-1:0]  s_axis_cc_tuser,
    input                       s_axis_cc_tvalid,
    output [5:0]                pcie_rq_seq_num0,
    output                      pcie_rq_seq_num_vld0,
    output [5:0]                pcie_rq_seq_num1,
    output                      pcie_rq_seq_num_vld1,
    output [7:0]                pcie_rq_tag0,
    output [7:0]                pcie_rq_tag1,
    output [3:0]                pcie_rq_tag_av,
    output                      pcie_rq_tag_vld0,
    output                      pcie_rq_tag_vld1,
    output [3:0]                pcie_tfc_nph_av,
    output [3:0]                pcie_tfc_npd_av,
    input  [1:0]                pcie_cq_np_req,
    output [5:0]                pcie_cq_np_req_count,
    output                      cfg_phy_link_down,
    output [1:0]                cfg_phy_link_status,
    output [2:0]                cfg_negotiated_width,
    output [1:0]                cfg_current_speed,
    output [1:0]                cfg_max_payload,
    output [2:0]                cfg_max_read_req,
    output [15:0]               cfg_function_status,
    output [11:0]               cfg_function_power_state,
    output [503:0]              cfg_vf_status,
    output [755:0]              cfg_vf_power_state,
    output [1:0]                cfg_link_power_state,
    input  [9:0]                cfg_mgmt_addr,
    input  [7:0]                cfg_mgmt_function_number,
    input                       cfg_mgmt_write,
    input  [31:0]               cfg_mgmt_write_data,
    input  [3:0]                cfg_mgmt_byte_enable,
    input                       cfg_mgmt_read,
    output [31:0]               cfg_mgmt_read_data,
    output                      cfg_mgmt_read_write_done,
    input                       cfg_mgmt_debug_access,
    output                      cfg_err_cor_out,
    output                      cfg_err_nonfatal_out,
    output                      cfg_err_fatal_out,
    output                      cfg_local_error_valid,
    output [4:0]                cfg_local_error_out,
    output [5:0]                cfg_ltssm_state,
    output [1:0]                cfg_rx_pm_state,
    output [1:0]                cfg_tx_pm_state,
    output [3:0]                cfg_rcb_status,
    output [1:0]                cfg_obff_enable,
    output                      cfg_pl_status_change,
    output [3:0]                cfg_tph_requester_enable,
    output [11:0]               cfg_tph_st_mode,
    output [251:0]              cfg_vf_tph_requester_enable,
    output [755:0]              cfg_vf_tph_st_mode,
    output                      cfg_msg_received,
    output [7:0]                cfg_msg_received_data,
    output [4:0]                cfg_msg_received_type,
    input                       cfg_msg_transmit,
    input  [2:0]                cfg_msg_transmit_type,
    input  [31:0]               cfg_msg_transmit_data,
    output                      cfg_msg_transmit_done,
    output [7:0]                cfg_fc_ph,
    output [11:0]               cfg_fc_pd,
    output [7:0]                cfg_fc_nph,
    output [11:0]               cfg_fc_npd,
    output [7:0]                cfg_fc_cplh,
    output [11:0]               cfg_fc_cpld,
    input  [2:0]                cfg_fc_sel,
    input  [63:0]               cfg_dsn,
    output [7:0]                cfg_bus_number,
    input                       cfg_power_state_change_ack,
    output                      cfg_power_state_change_interrupt,
    input                       cfg_err_cor_in,
    input                       cfg_err_uncor_in,
    output [3:0]                cfg_flr_in_process,
    input  [3:0]                cfg_flr_done,
    output [251:0]              cfg_vf_flr_in_process,
    input  [7:0]                cfg_vf_flr_func_num,
    input  [0:0]                cfg_vf_flr_done,
    input                       cfg_link_training_enable,
    input  [3:0]                cfg_interrupt_int,
    input  [3:0]                cfg_interrupt_pending,
    output                      cfg_interrupt_sent,
    output [3:0]                cfg_interrupt_msi_enable,
    output [11:0]               cfg_interrupt_msi_mmenable,
    output                      cfg_interrupt_msi_mask_update,
    output [31:0]               cfg_interrupt_msi_data,
    input  [1:0]                cfg_interrupt_msi_select,
    input  [31:0]               cfg_interrupt_msi_int,
    input  [31:0]               cfg_interrupt_msi_pending_status,
    input                       cfg_interrupt_msi_pending_status_data_enable,
    input  [1:0]                cfg_interrupt_msi_pending_status_function_num,
    output                      cfg_interrupt_msi_sent,
    output                      cfg_interrupt_msi_fail,
    output [3:0]                cfg_interrupt_msix_enable,
    output [3:0]                cfg_interrupt_msix_mask,
    output [251:0]              cfg_interrupt_msix_vf_enable,
    output [251:0]              cfg_interrupt_msix_vf_mask,
    input  [63:0]               cfg_interrupt_msix_address,
    input  [31:0]               cfg_interrupt_msix_data,
    input                       cfg_interrupt_msix_int,
    input  [1:0]                cfg_interrupt_msix_vec_pending,
    output                      cfg_interrupt_msix_vec_pending_status,
    output                      cfg_interrupt_msix_sent,
    output                      cfg_interrupt_msix_fail,
    input  [2:0]                cfg_interrupt_msi_attr,
    input                       cfg_interrupt_msi_tph_present,
    input  [1:0]                cfg_interrupt_msi_tph_type,
    input  [7:0]                cfg_interrupt_msi_tph_st_tag,
    input  [7:0]                cfg_interrupt_msi_function_number,
    input                       cfg_pm_aspm_l1_entry_reject,
    input                       cfg_pm_aspm_tx_l0s_entry_disable,
    output                      cfg_hot_reset_out,
    input                       cfg_config_space_enable,
    input                       cfg_req_pm_transition_l23_ready,
    input                       cfg_hot_reset_in,
    input  [7:0]                cfg_ds_port_number,
    input  [7:0]                cfg_ds_bus_number,
    input  [4:0]                cfg_ds_device_number,
    input                       sys_clk,
    input                       sys_clk_gt,
    input                       sys_reset,
    output                      phy_rdy_out
);

endmodule

`resetall



================================================
FILE: .github/workflows/regression-tests.yml
================================================
name: Regression Tests

on: [push, pull_request]

jobs:
  build:
    name: Python ${{matrix.python-version}}
    runs-on: ubuntu-24.04
    
    strategy:
      matrix:
        python-version: ["3.8", "3.9", "3.10", "3.11", "3.12", "3.13"]

    steps:
    - uses: actions/checkout@v3

    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ matrix.python-version }}

    - name: Install Icarus Verilog
      run: |
        sudo apt install -y --no-install-recommends iverilog

    - name: Install Python dependencies
      run: |
        python -m pip install --upgrade pip
        pip install tox tox-gh-actions

    - name: Test with tox
      run: tox

    - name: Upload coverage to codecov
      run: |
        pip install codecov
        codecov


