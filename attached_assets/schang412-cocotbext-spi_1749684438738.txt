Directory structure:
└── schang412-cocotbext-spi/
    ├── README.md
    ├── COPYING
    ├── MANIFEST.in
    ├── pyproject.toml
    ├── tox.ini
    ├── uv.lock
    ├── .pre-commit-config.yaml
    ├── cocotbext/
    │   └── spi/
    │       ├── __init__.py
    │       ├── about.py
    │       ├── exceptions.py
    │       ├── spi.py
    │       └── devices/
    │           ├── generic.py
    │           ├── ADI/
    │           │   ├── __init__.py
    │           │   └── ADXL345.py
    │           ├── TI/
    │           │   ├── __init__.py
    │           │   ├── ADS8028.py
    │           │   └── DRV8304.py
    │           └── Trinamic/
    │               ├── __init__.py
    │               └── TMC4671.py
    ├── tests/
    │   ├── spi/
    │   │   ├── Makefile
    │   │   ├── test_spi.py
    │   │   └── test_spi.v
    │   └── spi_devices/
    │       ├── ADI/
    │       │   └── adxl345/
    │       │       ├── Makefile
    │       │       ├── test_adxl345.py
    │       │       └── test_adxl345.v
    │       ├── TI/
    │       │   ├── ads8028/
    │       │   │   ├── Makefile
    │       │   │   ├── test_ads8028.py
    │       │   │   └── test_ads8028.v
    │       │   └── drv8304/
    │       │       ├── Makefile
    │       │       ├── test_drv8304.py
    │       │       └── test_drv8304.v
    │       └── Trinamic/
    │           └── tmc4671/
    │               ├── Makefile
    │               ├── test_tmc4671.py
    │               └── test_tmc4671.v
    └── .github/
        └── workflows/
            └── regression-tests.yml

================================================
FILE: README.md
================================================
# SPI Interface for Cocotb

[![Regression Tests](https://github.com/schang412/cocotbext-spi/actions/workflows/regression-tests.yml/badge.svg)](https://github.com/schang412/cocotbext-spi/actions/workflows/regression-tests.yml)
[![uv](https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/astral-sh/uv/main/assets/badge/v0.json)](https://github.com/astral-sh/uv)
[![pre-commit](https://img.shields.io/badge/pre--commit-enabled-brightgreen?logo=pre-commit)](https://github.com/pre-commit/pre-commit)

GitHub repository: https://github.com/schang412/cocotbext-spi

## Introduction

SPI simulation framework for [cocotb](https://github.com/cocotb/cocotb).

## Installation

Installation from pip (release version, stable):

```bash
pip install cocotbext-spi
```

Installation from git (latest development version, potentially unstable):

```bash
pip install https://github.com/schang412/cocotbext-spi/archive/main.zip
```

Installation for active development:

```bash
git clone https://github.com/schang412/cocotbext-spi
pip install -e cocotbext-spi
```

## Documentation and Usage

See the `tests` directory for complete testbenches using these modules.

### SPI Signals

The SPI bus signals are bundled together into a `SpiBus` class.

If the port instantiations look like:

```verilog
module my_module(
    input  wire sclk, 
    input  wire mosi,
    output wire miso,
    input  wire cs,  // active-low
)

```
The `SpiBus` class can be created as:

```python
from cocotbext.spi import SpiBus
spi_bus = SpiBus.from_entity(dut)
```

If there is some prefix, the `from_prefix` class method may be used:

```verilog
module my_module(
    input  wire spi0_sclk, 
    input  wire spi0_mosi,
    output wire spi0_miso,
    input  wire spi0_cs,  // active-low
)
```

```python
spi_bus = SpiBus.from_prefix(dut, "spi0")
```

If some signals have been renamed for clarity:

```verilog
module my_module(
    input  wire spi0__sck,
    input  wire spi0__mosi,
    output wire spi0__miso,
    input  wire spi0__ncs,  // active-low
)
```

```python
spi_bus = SpiBus.from_prefix(dut, "spi0", bus_separator="__", sclk_name="sck", cs_name="ncs")
```

### SPI Config

SPI Configuration parameters are bundled together into a `SpiConfig` class.

To create the object simply call it like a class and pass in arguments:

```python
from cocotbext.spi import SpiConfig

spi_config = SpiConfig(
    word_width = 16,        # number of bits in a SPI transaction
    sclk_freq  = 25e6,      # clock rate in Hz
    cpol       = False,     # clock idle polarity
    cpha       = True,      # clock phase (CPHA=True means data sampled on second edge)
    msb_first  = True,      # the order that bits are clocked onto the wire
    data_output_idle = 1,   # the idle value of the MOSI or MISO line
    frame_spacing_ns = 1,   # the spacing between frames that the master waits for or the slave obeys
                            #       the slave should raise SpiFrameError if this is not obeyed.
    ignore_rx_value = None, # MISO value that should be ignored when received
    cs_active_low = True    # the chip select is active low
)
```

All parameters are optional, and the defaults are shown above.

### SPI Master

The `SpiMaster` class acts as an SPI Master endpoint.

To use this class, import it, configure it, and connect to the dut.

```python
from cocotbext.spi import SpiMaster, SpiBus, SpiConfig

spi_bus = SpiBus.from_entity(dut)

spi_config = SpiConfig(
    word_width = 16,     # all parameters optional
    sclk_freq  = 25e6,   # these are the defaults
    cpol       = False,
    cpha       = True,
    msb_first  = True,
    cs_active_low = True # optional (assumed True)
)

spi_master = SpiMaster(spi_bus, spi_config)
```

To send data into a design with `SpiMaster`, call `write()` or `write_nowait()`. Accepted data types are iterables of ints including lists, bytes, bytearrays, etc. Optionally, call wait() to wait for the transmit operation to complete. We can take a look at the data received back with `read()` or `read_nowait()`

```python
# TX/RX transaction example
spi_master.write_nowait([0xFFFF])
await spi_master.wait()
read_bytes = await spi_master.read()
print(read_bytes)

# we can alternatively call (which has equivalent functionality)
await spi_master.write([0xFFFF])
read_bytes = await spi_masetr.read()
```

#### Constructor Parameters

- `bus`: SpiBus
- `config`: SpiConfig

#### Methods

- `write(data)`: send data (blocking)
- `write_nowait(data)`: send data (non-blocking)
- `read(count=-1)`: read count bytes from buffer, reading whole buffer by default (blocking)
- `read_nowait(count=-1)`: read count bytes from buffer, reading whole buffer by default (non-blocking)
- `count_tx()`: returns the number of items in the transmit queue
- `count_rx()`: returns the number of items in the receive queue
- `empty_tx()`: returns True if the transmit queue is empty
- `empty_rx()`: returns True if the receive queue is empty
- `idle()`: returns True if the transmit and receive buffers are empty
- `clear()`: drop all data in the queue

### SPI Slave

The `SpiSlaveBase` acts as an abstract class for a SPI Slave Endpoint.

To use this class, import it and inherit it. Then use the subclass as the slave and connect it to the dut.

```python
from cocotbext.spi import SpiMaster, SpiBus, SpiConfig

class SimpleSpiSlave(SpiSlaveBase):
    def __init__(self, bus):
        self._config = SpiConfig()
        self.content = 0
        super().__init__(bus)

    async def get_content(self):
        await self.idle.wait()
        return self.content

    async def _transaction(self, frame_start, frame_end):
        await frame_start
        self.idle.clear()

        self.content = int(await self._shift(16, tx_word=(0xAAAA)))

        await frame_end

spi_slave = SimpleSpiSlave(SpiBus.from_entity(dut))
```

#### Implementation

All SPI Slave Classes should:

- inherit the SpiSlaveBase class
- define `self._config` adjust the values for:
    - `word_width`
    - `cpha`
    - `cpol`
    - `msb_first`
    - `frame_spacing_ns`
- implement a `_transaction` coroutine
    - the coroutine should take 3 arguments, self, frame_start and frame_end
    - the coroutine should await frame_start at the transaction start, and frame_end when done.
        - frame_start and frame_end are Rising and Falling edges of the chip select based on the chip select polarity
    - when the coroutine receives a frame_start signal, it should clear the `self.idle` Event.
        - `self.idle` is automatically set when `_transaction` returns
- when implementing a method to read the class contents, make sure to await the `self.idle`, otherwise the data may not be up to date because the device is in the middle of a transaction.

#### Simulated Devices

This framework includes some SPI Slave devices built in. A list of supported devices can be found in `cocotbext/spi/devices` and are sorted by vendor.

To use these devices, you can simply import them.

```python
from cocotbext.spi.devices.TI import DRV8306

spi_slave = DRV8306(SpiBus.from_entity(dut, cs_name="ncs"))
```

To submit a new device, make a pull request.



================================================
FILE: COPYING
================================================
Copyright (c) 2021 Spencer Chang

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.



================================================
FILE: MANIFEST.in
================================================
include LICENSE
include README.md
recursive-include tests Makefile test_*.py test_*.v



================================================
FILE: pyproject.toml
================================================
[build-system]
build-backend = "setuptools.build_meta"
requires = [
  "setuptools>=61",
  "setuptools_scm[toml]>=6.2",
  "wheel",
]

[project]
name = "cocotbext-spi"
description = "SPI modules for cocotb"
readme = "README.md"
license = "MIT"
authors = [
    {name = "Spencer Chang", email = "spencer@sycee.xyz"},
]
requires-python = ">=3.9"
classifiers = [
    "Development Status :: 3 - Alpha",
    "Programming Language :: Python :: 3",
    "Operating System :: OS Independent",
    "Topic :: Scientific/Engineering :: Electronic Design Automation (EDA)",
]
dynamic = [
  "version",
]
dependencies = [
  "cocotb>=1.6",
  "cocotb-bus>=0.2.1",
]
[project.urls]
repository = "https://github.com/schang412/cocotbext-spi"


[tool.setuptools_scm]
write_to = "cocotbext/spi/_version.py"

[tool.pytest.ini_options]
testpaths = [
    "tests"
]
addopts = "--import-mode importlib"

[dependency-groups]
dev = [
    "cocotb-test>=0.2.6",
    "pytest>=8.3.5",
    "pytest-xdist>=3.6.1",
    "tox>=4.25.0",
]
lint = [
    "flake8>=5.0.4",
]



================================================
FILE: tox.ini
================================================
[tox]
isolated_build = true
envlist = py{39,310,311},lint,check-dist

[flake8]
max-line-length = 120

[testenv]
deps = uv
commands =
    uv sync --active
    uv run --active pytest tests -n auto

[testenv:lint]
deps = uv
commands =
    uv sync --active --only-group lint
    uv run --active flake8 cocotbext/ tests/

[testenv:check-dist]
skip_install = true
deps =
    uv
    twine
commands =
    uv build
    twine check dist/*



================================================
FILE: uv.lock
================================================
version = 1
revision = 1
requires-python = ">=3.9"

[[package]]
name = "cachetools"
version = "5.5.2"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/6c/81/3747dad6b14fa2cf53fcf10548cf5aea6913e96fab41a3c198676f8948a5/cachetools-5.5.2.tar.gz", hash = "sha256:1a661caa9175d26759571b2e19580f9d6393969e5dfca11fdb1f947a23e640d4", size = 28380 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/72/76/20fa66124dbe6be5cafeb312ece67de6b61dd91a0247d1ea13db4ebb33c2/cachetools-5.5.2-py3-none-any.whl", hash = "sha256:d26a22bcc62eb95c3beabd9f1ee5e820d3d2704fe2967cbe350e20c8ffcd3f0a", size = 10080 },
]

[[package]]
name = "chardet"
version = "5.2.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/f3/0d/f7b6ab21ec75897ed80c17d79b15951a719226b9fababf1e40ea74d69079/chardet-5.2.0.tar.gz", hash = "sha256:1b3b6ff479a8c414bc3fa2c0852995695c4a026dcd6d0633b2dd092ca39c1cf7", size = 2069618 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/38/6f/f5fbc992a329ee4e0f288c1fe0e2ad9485ed064cac731ed2fe47dcc38cbf/chardet-5.2.0-py3-none-any.whl", hash = "sha256:e1cf59446890a00105fe7b7912492ea04b6e6f06d4b742b2c788469e34c82970", size = 199385 },
]

[[package]]
name = "cocotb"
version = "1.9.2"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "find-libpython" },
]
sdist = { url = "https://files.pythonhosted.org/packages/5c/dc/4bd01e86f7ad85dfc6eec681a94db1a856aa35c58777a297e271100ac24c/cocotb-1.9.2.tar.gz", hash = "sha256:e4cdeaf51ec1b14e5430083ac56edc0b48ad05184f0307d90de44ff7bfdb1652", size = 300696 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/2d/48/b90db9fc14e829bfdca797f1a0cc656950d63a438ab311207d6882caf934/cocotb-1.9.2-cp310-cp310-macosx_10_9_x86_64.whl", hash = "sha256:25396c1650eb9002dbebe013f8c3fad64b1646e4b2ff06f953cf2f8aac51b7d2", size = 620027 },
    { url = "https://files.pythonhosted.org/packages/38/43/b7c3ab67e8f789e629ee9090dde89df1fd6ba9b2589f2c8ff183332cf4ab/cocotb-1.9.2-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:47f82e32c2485ae953f482d1e19f227c7c95b05bb5542eee2b4c4250d787df64", size = 4209565 },
    { url = "https://files.pythonhosted.org/packages/82/b9/9f3aaa7677ddce0feffe6bd4f12382574794aaa26c5a79d259d339ac7a7a/cocotb-1.9.2-cp310-cp310-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:940ca22d386962bc538e4aa2c94d50a23e83758f6d0b721aabb67760d37dedea", size = 4092830 },
    { url = "https://files.pythonhosted.org/packages/68/4b/50f20f8990c12e9714da2f23eb694deb0bef9c6dc2f7206355697eeda16d/cocotb-1.9.2-cp310-cp310-win32.whl", hash = "sha256:4ee9f6a3cdebf88ecec9a69789111559260898dcbebffff11593076f4cbf29c9", size = 491952 },
    { url = "https://files.pythonhosted.org/packages/85/8c/a7ef7e479cdda84680d14c123d3f93508b801a58c92ad3d50d6f96a07348/cocotb-1.9.2-cp310-cp310-win_amd64.whl", hash = "sha256:6901bb667ad3ffd0233558c496691062c72f30f0cb9686e86ca05bf3019d0ee0", size = 523350 },
    { url = "https://files.pythonhosted.org/packages/04/4f/64e2e6338a4c0666d2a53fdc160832bf1dd29d758fd8d6e7c72c98d22f26/cocotb-1.9.2-cp311-cp311-macosx_10_9_x86_64.whl", hash = "sha256:ac8cef8162a01369cbb6428b5d252274fe8a6bcae360fb68ba12dcda344b468a", size = 620030 },
    { url = "https://files.pythonhosted.org/packages/2d/49/591bbe8961cfb540b3b17fda8e07b19d7e0203a2e272706c71aba37426c0/cocotb-1.9.2-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:57fb05bc1bf79f92964d3a633153056bd885538dac9c2f5d3a724e83cdc65d51", size = 4211516 },
    { url = "https://files.pythonhosted.org/packages/1b/d6/560c22b3b8cad20f159ba93b076483dd9db101e3823f795f07b26cfa3f30/cocotb-1.9.2-cp311-cp311-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:08c6dc004324b36015975b14aa24dca3cf1ac771d0ddd9ccacdcf4af7c77c3e1", size = 4094459 },
    { url = "https://files.pythonhosted.org/packages/07/e7/24ef11f4854ae82758a73a4ce0cfd3a6c5ed459c923891d10d44adb6c586/cocotb-1.9.2-cp311-cp311-win32.whl", hash = "sha256:d2b28fb592586cf210243bacf3c53be5c5ca383555aafc8619605f34529bfae0", size = 491943 },
    { url = "https://files.pythonhosted.org/packages/4a/f9/55036ca2bab83c27519b6497dce6f78d8ef74ff1a166ad17d59bba4ad48b/cocotb-1.9.2-cp311-cp311-win_amd64.whl", hash = "sha256:7f171a4eb095b45556275fba414785eaf7b41937690a93dc0dfa8f568e699687", size = 523342 },
    { url = "https://files.pythonhosted.org/packages/f1/86/39f5f75366e46c665b86a46ab7acb5149994c55f4ad6f89057e99acc7400/cocotb-1.9.2-cp312-cp312-macosx_10_9_x86_64.whl", hash = "sha256:17c19553dbc5442f079495a2fd6e8fc7924cd9c527ae0d5c92d864f12d3ed865", size = 620182 },
    { url = "https://files.pythonhosted.org/packages/f3/50/4e6c84dc1d2002e0cc4587a4516feb12c47e2953f43f8f2f136941e7c0bb/cocotb-1.9.2-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:ff2460fb60444bfbe28a8119aad7f7297a97b53356426f03d0cdee2b90d3bc1a", size = 4213411 },
    { url = "https://files.pythonhosted.org/packages/ad/1a/8875eecc17f681e6fd7bfff5e75a9338c156b3530c5559fe77753174e19a/cocotb-1.9.2-cp312-cp312-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:5a2333ee6e5f2316c425e501ea9a116439cf8f08ceb8816c762842fe88ea9748", size = 4094531 },
    { url = "https://files.pythonhosted.org/packages/0c/ae/2a536de0f747bd5756e62165a429c9249c6e0715cc77c9a5fdd851821adb/cocotb-1.9.2-cp312-cp312-win32.whl", hash = "sha256:85d175f6e6054f3d046903790fe61ccf454e1a5e39392682c728a3418be935cf", size = 492077 },
    { url = "https://files.pythonhosted.org/packages/05/b3/5026f529ffd707dcb6cf58d68d0b1b7d47fc6afecf009a4158bf7e2141b4/cocotb-1.9.2-cp312-cp312-win_amd64.whl", hash = "sha256:42fde03b858cd84e0284d9cee6bf34cc0892167921bd1da100abf181ac5e2ea4", size = 523524 },
    { url = "https://files.pythonhosted.org/packages/4a/9b/68332cd317d449c32e5ed8318343805f59e73481d6c5dcb01b8060ac412e/cocotb-1.9.2-cp313-cp313-macosx_10_13_x86_64.whl", hash = "sha256:a60f6b3c4e4f5e9265a18c86927af1d773fb79b32edf577ce2ba8d59d74acafc", size = 611792 },
    { url = "https://files.pythonhosted.org/packages/9a/79/dadc212d62e57bc381ab403bae8a442b8903f84c4807075bd236071092ce/cocotb-1.9.2-cp313-cp313-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:9cc00e5ddf5fea392a8a3406869396c7e5a736a08afc8e0fe45ad159151438ba", size = 4213277 },
    { url = "https://files.pythonhosted.org/packages/a0/22/4578c0f67443ae00e63f6d9987bd48287b1ad141941780277a9bd8faa4ce/cocotb-1.9.2-cp313-cp313-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:6264826ee4dd6acc678dd2572f3cd683da6a48013af82de81bf8a45b5e064b8e", size = 4094427 },
    { url = "https://files.pythonhosted.org/packages/29/71/6b77f173866dd64f3b898ec15ec1103eee43fb7b212108e51fea9b866a67/cocotb-1.9.2-cp313-cp313-win32.whl", hash = "sha256:7cdb25ca9dd2483d96f30b1cf3c070e4a6527d43e0af2d66660de29727c81cd4", size = 492087 },
    { url = "https://files.pythonhosted.org/packages/01/f0/71d15e3735df2135f600cac25e2174c7fee55d250e46a00fe800417c1aab/cocotb-1.9.2-cp313-cp313-win_amd64.whl", hash = "sha256:c816972ec4b3360372075fb0563cf98e8ad7d0f158e8dfe3165824936383a888", size = 523541 },
    { url = "https://files.pythonhosted.org/packages/f5/f4/37d2edfc26b0298612f03690c9981dbe557154c1b83fd42909cfefbddce2/cocotb-1.9.2-cp39-cp39-macosx_10_9_x86_64.whl", hash = "sha256:504a0926cf07f59dfce3141d58ce0d20bc4ecafdd7adc3153b6b4ba2e62ed52a", size = 620028 },
    { url = "https://files.pythonhosted.org/packages/44/55/b95e7883d3514d27b071276cdb81c8a5bf14bf943ef40d88f1c5a79941da/cocotb-1.9.2-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:df0aef26de38326440395edf5f2dddd11254a0cfa121151e89095cc5c75c9564", size = 4208720 },
    { url = "https://files.pythonhosted.org/packages/e6/e7/577168b65b57c065c4eff1668a3b2520296f706cdad49ef20d8688dd1850/cocotb-1.9.2-cp39-cp39-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:349ff4ac56e3d07c49f1b38426461c2e0239e603c5a3e6bc1221d01774c97656", size = 4092032 },
    { url = "https://files.pythonhosted.org/packages/c8/c4/5d17391e8acdc03f0ac9feda7fadface8ac91ac0c05a61aab9c1e63aaa5c/cocotb-1.9.2-cp39-cp39-win32.whl", hash = "sha256:bcaa79fc55e68f1769c381f494b5c35fce7a597aa660c420a1e9015acf95b263", size = 491947 },
    { url = "https://files.pythonhosted.org/packages/3a/0c/3bfa1d6d65199b12d1ba685b4bec3c07b9c2b9a8014821c3064035edeb47/cocotb-1.9.2-cp39-cp39-win_amd64.whl", hash = "sha256:58bf87c7c71ba8c8e8f217aaf41841951aea10efe57d824eb32596b8fb47d18e", size = 523357 },
]

[[package]]
name = "cocotb-bus"
version = "0.2.1"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "cocotb" },
]
sdist = { url = "https://files.pythonhosted.org/packages/b6/2b/71975ab8c15f9a2c4c4fe9da4a873ea164eb348449858358f2762b24c0be/cocotb-bus-0.2.1.tar.gz", hash = "sha256:a197aa4b0e0ad28469c8877b41b3fb2ec0206da9f491b9276d1578ce6dd8aa8d", size = 28461 }

[[package]]
name = "cocotb-test"
version = "0.2.6"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "cocotb" },
    { name = "find-libpython" },
    { name = "pytest" },
]
sdist = { url = "https://files.pythonhosted.org/packages/cd/49/2d00e3518fcff0abc4c15207b1d14745420c6b4b4c7ece60d5c35717842e/cocotb_test-0.2.6.tar.gz", hash = "sha256:a4661948ca145eee6bccaf832174b5efb9f6d3420677157c04ade72bb2160692", size = 21254 }

[[package]]
name = "cocotbext-spi"
source = { editable = "." }
dependencies = [
    { name = "cocotb" },
    { name = "cocotb-bus" },
]

[package.dev-dependencies]
dev = [
    { name = "cocotb-test" },
    { name = "pytest" },
    { name = "pytest-xdist" },
    { name = "tox" },
]
lint = [
    { name = "flake8" },
]

[package.metadata]
requires-dist = [
    { name = "cocotb", specifier = ">=1.6" },
    { name = "cocotb-bus", specifier = ">=0.2.1" },
]

[package.metadata.requires-dev]
dev = [
    { name = "cocotb-test", specifier = ">=0.2.6" },
    { name = "pytest", specifier = ">=8.3.5" },
    { name = "pytest-xdist", specifier = ">=3.6.1" },
    { name = "tox", specifier = ">=4.25.0" },
]
lint = [{ name = "flake8", specifier = ">=5.0.4" }]

[[package]]
name = "colorama"
version = "0.4.6"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/d8/53/6f443c9a4a8358a93a6792e2acffb9d9d5cb0a5cfd8802644b7b1c9a02e4/colorama-0.4.6.tar.gz", hash = "sha256:08695f5cb7ed6e0531a20572697297273c47b8cae5a63ffc6d6ed5c201be6e44", size = 27697 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/d1/d6/3965ed04c63042e047cb6a3e6ed1a63a35087b6a609aa3a15ed8ac56c221/colorama-0.4.6-py2.py3-none-any.whl", hash = "sha256:4f1d9991f5acc0ca119f9d443620b77f9d6b33703e51011c16baf57afb285fc6", size = 25335 },
]

[[package]]
name = "distlib"
version = "0.3.9"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/0d/dd/1bec4c5ddb504ca60fc29472f3d27e8d4da1257a854e1d96742f15c1d02d/distlib-0.3.9.tar.gz", hash = "sha256:a60f20dea646b8a33f3e7772f74dc0b2d0772d2837ee1342a00645c81edf9403", size = 613923 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/91/a1/cf2472db20f7ce4a6be1253a81cfdf85ad9c7885ffbed7047fb72c24cf87/distlib-0.3.9-py2.py3-none-any.whl", hash = "sha256:47f8c22fd27c27e25a65601af709b38e4f0a45ea4fc2e710f65755fa8caaaf87", size = 468973 },
]

[[package]]
name = "exceptiongroup"
version = "1.2.2"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/09/35/2495c4ac46b980e4ca1f6ad6db102322ef3ad2410b79fdde159a4b0f3b92/exceptiongroup-1.2.2.tar.gz", hash = "sha256:47c2edf7c6738fafb49fd34290706d1a1a2f4d1c6df275526b62cbb4aa5393cc", size = 28883 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/02/cc/b7e31358aac6ed1ef2bb790a9746ac2c69bcb3c8588b41616914eb106eaf/exceptiongroup-1.2.2-py3-none-any.whl", hash = "sha256:3111b9d131c238bec2f8f516e123e14ba243563fb135d3fe885990585aa7795b", size = 16453 },
]

[[package]]
name = "execnet"
version = "2.1.1"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/bb/ff/b4c0dc78fbe20c3e59c0c7334de0c27eb4001a2b2017999af398bf730817/execnet-2.1.1.tar.gz", hash = "sha256:5189b52c6121c24feae288166ab41b32549c7e2348652736540b9e6e7d4e72e3", size = 166524 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/43/09/2aea36ff60d16dd8879bdb2f5b3ee0ba8d08cbbdcdfe870e695ce3784385/execnet-2.1.1-py3-none-any.whl", hash = "sha256:26dee51f1b80cebd6d0ca8e74dd8745419761d3bef34163928cbebbdc4749fdc", size = 40612 },
]

[[package]]
name = "filelock"
version = "3.18.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/0a/10/c23352565a6544bdc5353e0b15fc1c563352101f30e24bf500207a54df9a/filelock-3.18.0.tar.gz", hash = "sha256:adbc88eabb99d2fec8c9c1b229b171f18afa655400173ddc653d5d01501fb9f2", size = 18075 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/4d/36/2a115987e2d8c300a974597416d9de88f2444426de9571f4b59b2cca3acc/filelock-3.18.0-py3-none-any.whl", hash = "sha256:c401f4f8377c4464e6db25fff06205fd89bdd83b65eb0488ed1b160f780e21de", size = 16215 },
]

[[package]]
name = "find-libpython"
version = "0.4.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/db/86/b1d3a9c49d907cac74f9d8bcead2c8e807a878c0e218d8ef1d38e6a4f59a/find_libpython-0.4.0.tar.gz", hash = "sha256:46f9cdcd397ddb563b2d7592ded3796a41c1df5222443bd9d981721c906c03e6", size = 8979 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/1d/89/6b4624122d5c61a86e8aebcebd377866338b705ce4f115c45b046dc09b99/find_libpython-0.4.0-py3-none-any.whl", hash = "sha256:034a4253bd57da3408aefc59aeac1650150f6c1f42e10fdd31615cf1df0842e3", size = 8670 },
]

[[package]]
name = "flake8"
version = "7.2.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "mccabe" },
    { name = "pycodestyle" },
    { name = "pyflakes" },
]
sdist = { url = "https://files.pythonhosted.org/packages/e7/c4/5842fc9fc94584c455543540af62fd9900faade32511fab650e9891ec225/flake8-7.2.0.tar.gz", hash = "sha256:fa558ae3f6f7dbf2b4f22663e5343b6b6023620461f8d4ff2019ef4b5ee70426", size = 48177 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/83/5c/0627be4c9976d56b1217cb5187b7504e7fd7d3503f8bfd312a04077bd4f7/flake8-7.2.0-py2.py3-none-any.whl", hash = "sha256:93b92ba5bdb60754a6da14fa3b93a9361fd00a59632ada61fd7b130436c40343", size = 57786 },
]

[[package]]
name = "iniconfig"
version = "2.1.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/f2/97/ebf4da567aa6827c909642694d71c9fcf53e5b504f2d96afea02718862f3/iniconfig-2.1.0.tar.gz", hash = "sha256:3abbd2e30b36733fee78f9c7f7308f2d0050e88f0087fd25c2645f63c773e1c7", size = 4793 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/2c/e1/e6716421ea10d38022b952c159d5161ca1193197fb744506875fbb87ea7b/iniconfig-2.1.0-py3-none-any.whl", hash = "sha256:9deba5723312380e77435581c6bf4935c94cbfab9b1ed33ef8d238ea168eb760", size = 6050 },
]

[[package]]
name = "mccabe"
version = "0.7.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/e7/ff/0ffefdcac38932a54d2b5eed4e0ba8a408f215002cd178ad1df0f2806ff8/mccabe-0.7.0.tar.gz", hash = "sha256:348e0240c33b60bbdf4e523192ef919f28cb2c3d7d5c7794f74009290f236325", size = 9658 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/27/1a/1f68f9ba0c207934b35b86a8ca3aad8395a3d6dd7921c0686e23853ff5a9/mccabe-0.7.0-py2.py3-none-any.whl", hash = "sha256:6c2d30ab6be0e4a46919781807b4f0d834ebdd6c6e3dca0bda5a15f863427b6e", size = 7350 },
]

[[package]]
name = "packaging"
version = "24.2"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/d0/63/68dbb6eb2de9cb10ee4c9c14a0148804425e13c4fb20d61cce69f53106da/packaging-24.2.tar.gz", hash = "sha256:c228a6dc5e932d346bc5739379109d49e8853dd8223571c7c5b55260edc0b97f", size = 163950 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/88/ef/eb23f262cca3c0c4eb7ab1933c3b1f03d021f2c48f54763065b6f0e321be/packaging-24.2-py3-none-any.whl", hash = "sha256:09abb1bccd265c01f4a3aa3f7a7db064b36514d2cba19a2f694fe6150451a759", size = 65451 },
]

[[package]]
name = "platformdirs"
version = "4.3.7"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/b6/2d/7d512a3913d60623e7eb945c6d1b4f0bddf1d0b7ada5225274c87e5b53d1/platformdirs-4.3.7.tar.gz", hash = "sha256:eb437d586b6a0986388f0d6f74aa0cde27b48d0e3d66843640bfb6bdcdb6e351", size = 21291 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/6d/45/59578566b3275b8fd9157885918fcd0c4d74162928a5310926887b856a51/platformdirs-4.3.7-py3-none-any.whl", hash = "sha256:a03875334331946f13c549dbd8f4bac7a13a50a895a0eb1e8c6a8ace80d40a94", size = 18499 },
]

[[package]]
name = "pluggy"
version = "1.5.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/96/2d/02d4312c973c6050a18b314a5ad0b3210edb65a906f868e31c111dede4a6/pluggy-1.5.0.tar.gz", hash = "sha256:2cffa88e94fdc978c4c574f15f9e59b7f4201d439195c3715ca9e2486f1d0cf1", size = 67955 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/88/5f/e351af9a41f866ac3f1fac4ca0613908d9a41741cfcf2228f4ad853b697d/pluggy-1.5.0-py3-none-any.whl", hash = "sha256:44e1ad92c8ca002de6377e165f3e0f1be63266ab4d554740532335b9d75ea669", size = 20556 },
]

[[package]]
name = "pycodestyle"
version = "2.13.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/04/6e/1f4a62078e4d95d82367f24e685aef3a672abfd27d1a868068fed4ed2254/pycodestyle-2.13.0.tar.gz", hash = "sha256:c8415bf09abe81d9c7f872502a6eee881fbe85d8763dd5b9924bb0a01d67efae", size = 39312 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/07/be/b00116df1bfb3e0bb5b45e29d604799f7b91dd861637e4d448b4e09e6a3e/pycodestyle-2.13.0-py2.py3-none-any.whl", hash = "sha256:35863c5974a271c7a726ed228a14a4f6daf49df369d8c50cd9a6f58a5e143ba9", size = 31424 },
]

[[package]]
name = "pyflakes"
version = "3.3.2"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/af/cc/1df338bd7ed1fa7c317081dcf29bf2f01266603b301e6858856d346a12b3/pyflakes-3.3.2.tar.gz", hash = "sha256:6dfd61d87b97fba5dcfaaf781171ac16be16453be6d816147989e7f6e6a9576b", size = 64175 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/15/40/b293a4fa769f3b02ab9e387c707c4cbdc34f073f945de0386107d4e669e6/pyflakes-3.3.2-py2.py3-none-any.whl", hash = "sha256:5039c8339cbb1944045f4ee5466908906180f13cc99cc9949348d10f82a5c32a", size = 63164 },
]

[[package]]
name = "pyproject-api"
version = "1.9.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "packaging" },
    { name = "tomli", marker = "python_full_version < '3.11'" },
]
sdist = { url = "https://files.pythonhosted.org/packages/7e/66/fdc17e94486836eda4ba7113c0db9ac7e2f4eea1b968ee09de2fe75e391b/pyproject_api-1.9.0.tar.gz", hash = "sha256:7e8a9854b2dfb49454fae421cb86af43efbb2b2454e5646ffb7623540321ae6e", size = 22714 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/b0/1d/92b7c765df46f454889d9610292b0ccab15362be3119b9a624458455e8d5/pyproject_api-1.9.0-py3-none-any.whl", hash = "sha256:326df9d68dea22d9d98b5243c46e3ca3161b07a1b9b18e213d1e24fd0e605766", size = 13131 },
]

[[package]]
name = "pytest"
version = "8.3.5"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "colorama", marker = "sys_platform == 'win32'" },
    { name = "exceptiongroup", marker = "python_full_version < '3.11'" },
    { name = "iniconfig" },
    { name = "packaging" },
    { name = "pluggy" },
    { name = "tomli", marker = "python_full_version < '3.11'" },
]
sdist = { url = "https://files.pythonhosted.org/packages/ae/3c/c9d525a414d506893f0cd8a8d0de7706446213181570cdbd766691164e40/pytest-8.3.5.tar.gz", hash = "sha256:f4efe70cc14e511565ac476b57c279e12a855b11f48f212af1080ef2263d3845", size = 1450891 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/30/3d/64ad57c803f1fa1e963a7946b6e0fea4a70df53c1a7fed304586539c2bac/pytest-8.3.5-py3-none-any.whl", hash = "sha256:c69214aa47deac29fad6c2a4f590b9c4a9fdb16a403176fe154b79c0b4d4d820", size = 343634 },
]

[[package]]
name = "pytest-xdist"
version = "3.6.1"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "execnet" },
    { name = "pytest" },
]
sdist = { url = "https://files.pythonhosted.org/packages/41/c4/3c310a19bc1f1e9ef50075582652673ef2bfc8cd62afef9585683821902f/pytest_xdist-3.6.1.tar.gz", hash = "sha256:ead156a4db231eec769737f57668ef58a2084a34b2e55c4a8fa20d861107300d", size = 84060 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/6d/82/1d96bf03ee4c0fdc3c0cbe61470070e659ca78dc0086fb88b66c185e2449/pytest_xdist-3.6.1-py3-none-any.whl", hash = "sha256:9ed4adfb68a016610848639bb7e02c9352d5d9f03d04809919e2dafc3be4cca7", size = 46108 },
]

[[package]]
name = "tomli"
version = "2.2.1"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/18/87/302344fed471e44a87289cf4967697d07e532f2421fdaf868a303cbae4ff/tomli-2.2.1.tar.gz", hash = "sha256:cd45e1dc79c835ce60f7404ec8119f2eb06d38b1deba146f07ced3bbc44505ff", size = 17175 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/43/ca/75707e6efa2b37c77dadb324ae7d9571cb424e61ea73fad7c56c2d14527f/tomli-2.2.1-cp311-cp311-macosx_10_9_x86_64.whl", hash = "sha256:678e4fa69e4575eb77d103de3df8a895e1591b48e740211bd1067378c69e8249", size = 131077 },
    { url = "https://files.pythonhosted.org/packages/c7/16/51ae563a8615d472fdbffc43a3f3d46588c264ac4f024f63f01283becfbb/tomli-2.2.1-cp311-cp311-macosx_11_0_arm64.whl", hash = "sha256:023aa114dd824ade0100497eb2318602af309e5a55595f76b626d6d9f3b7b0a6", size = 123429 },
    { url = "https://files.pythonhosted.org/packages/f1/dd/4f6cd1e7b160041db83c694abc78e100473c15d54620083dbd5aae7b990e/tomli-2.2.1-cp311-cp311-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:ece47d672db52ac607a3d9599a9d48dcb2f2f735c6c2d1f34130085bb12b112a", size = 226067 },
    { url = "https://files.pythonhosted.org/packages/a9/6b/c54ede5dc70d648cc6361eaf429304b02f2871a345bbdd51e993d6cdf550/tomli-2.2.1-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:6972ca9c9cc9f0acaa56a8ca1ff51e7af152a9f87fb64623e31d5c83700080ee", size = 236030 },
    { url = "https://files.pythonhosted.org/packages/1f/47/999514fa49cfaf7a92c805a86c3c43f4215621855d151b61c602abb38091/tomli-2.2.1-cp311-cp311-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:c954d2250168d28797dd4e3ac5cf812a406cd5a92674ee4c8f123c889786aa8e", size = 240898 },
    { url = "https://files.pythonhosted.org/packages/73/41/0a01279a7ae09ee1573b423318e7934674ce06eb33f50936655071d81a24/tomli-2.2.1-cp311-cp311-musllinux_1_2_aarch64.whl", hash = "sha256:8dd28b3e155b80f4d54beb40a441d366adcfe740969820caf156c019fb5c7ec4", size = 229894 },
    { url = "https://files.pythonhosted.org/packages/55/18/5d8bc5b0a0362311ce4d18830a5d28943667599a60d20118074ea1b01bb7/tomli-2.2.1-cp311-cp311-musllinux_1_2_i686.whl", hash = "sha256:e59e304978767a54663af13c07b3d1af22ddee3bb2fb0618ca1593e4f593a106", size = 245319 },
    { url = "https://files.pythonhosted.org/packages/92/a3/7ade0576d17f3cdf5ff44d61390d4b3febb8a9fc2b480c75c47ea048c646/tomli-2.2.1-cp311-cp311-musllinux_1_2_x86_64.whl", hash = "sha256:33580bccab0338d00994d7f16f4c4ec25b776af3ffaac1ed74e0b3fc95e885a8", size = 238273 },
    { url = "https://files.pythonhosted.org/packages/72/6f/fa64ef058ac1446a1e51110c375339b3ec6be245af9d14c87c4a6412dd32/tomli-2.2.1-cp311-cp311-win32.whl", hash = "sha256:465af0e0875402f1d226519c9904f37254b3045fc5084697cefb9bdde1ff99ff", size = 98310 },
    { url = "https://files.pythonhosted.org/packages/6a/1c/4a2dcde4a51b81be3530565e92eda625d94dafb46dbeb15069df4caffc34/tomli-2.2.1-cp311-cp311-win_amd64.whl", hash = "sha256:2d0f2fdd22b02c6d81637a3c95f8cd77f995846af7414c5c4b8d0545afa1bc4b", size = 108309 },
    { url = "https://files.pythonhosted.org/packages/52/e1/f8af4c2fcde17500422858155aeb0d7e93477a0d59a98e56cbfe75070fd0/tomli-2.2.1-cp312-cp312-macosx_10_13_x86_64.whl", hash = "sha256:4a8f6e44de52d5e6c657c9fe83b562f5f4256d8ebbfe4ff922c495620a7f6cea", size = 132762 },
    { url = "https://files.pythonhosted.org/packages/03/b8/152c68bb84fc00396b83e7bbddd5ec0bd3dd409db4195e2a9b3e398ad2e3/tomli-2.2.1-cp312-cp312-macosx_11_0_arm64.whl", hash = "sha256:8d57ca8095a641b8237d5b079147646153d22552f1c637fd3ba7f4b0b29167a8", size = 123453 },
    { url = "https://files.pythonhosted.org/packages/c8/d6/fc9267af9166f79ac528ff7e8c55c8181ded34eb4b0e93daa767b8841573/tomli-2.2.1-cp312-cp312-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:4e340144ad7ae1533cb897d406382b4b6fede8890a03738ff1683af800d54192", size = 233486 },
    { url = "https://files.pythonhosted.org/packages/5c/51/51c3f2884d7bab89af25f678447ea7d297b53b5a3b5730a7cb2ef6069f07/tomli-2.2.1-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:db2b95f9de79181805df90bedc5a5ab4c165e6ec3fe99f970d0e302f384ad222", size = 242349 },
    { url = "https://files.pythonhosted.org/packages/ab/df/bfa89627d13a5cc22402e441e8a931ef2108403db390ff3345c05253935e/tomli-2.2.1-cp312-cp312-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:40741994320b232529c802f8bc86da4e1aa9f413db394617b9a256ae0f9a7f77", size = 252159 },
    { url = "https://files.pythonhosted.org/packages/9e/6e/fa2b916dced65763a5168c6ccb91066f7639bdc88b48adda990db10c8c0b/tomli-2.2.1-cp312-cp312-musllinux_1_2_aarch64.whl", hash = "sha256:400e720fe168c0f8521520190686ef8ef033fb19fc493da09779e592861b78c6", size = 237243 },
    { url = "https://files.pythonhosted.org/packages/b4/04/885d3b1f650e1153cbb93a6a9782c58a972b94ea4483ae4ac5cedd5e4a09/tomli-2.2.1-cp312-cp312-musllinux_1_2_i686.whl", hash = "sha256:02abe224de6ae62c19f090f68da4e27b10af2b93213d36cf44e6e1c5abd19fdd", size = 259645 },
    { url = "https://files.pythonhosted.org/packages/9c/de/6b432d66e986e501586da298e28ebeefd3edc2c780f3ad73d22566034239/tomli-2.2.1-cp312-cp312-musllinux_1_2_x86_64.whl", hash = "sha256:b82ebccc8c8a36f2094e969560a1b836758481f3dc360ce9a3277c65f374285e", size = 244584 },
    { url = "https://files.pythonhosted.org/packages/1c/9a/47c0449b98e6e7d1be6cbac02f93dd79003234ddc4aaab6ba07a9a7482e2/tomli-2.2.1-cp312-cp312-win32.whl", hash = "sha256:889f80ef92701b9dbb224e49ec87c645ce5df3fa2cc548664eb8a25e03127a98", size = 98875 },
    { url = "https://files.pythonhosted.org/packages/ef/60/9b9638f081c6f1261e2688bd487625cd1e660d0a85bd469e91d8db969734/tomli-2.2.1-cp312-cp312-win_amd64.whl", hash = "sha256:7fc04e92e1d624a4a63c76474610238576942d6b8950a2d7f908a340494e67e4", size = 109418 },
    { url = "https://files.pythonhosted.org/packages/04/90/2ee5f2e0362cb8a0b6499dc44f4d7d48f8fff06d28ba46e6f1eaa61a1388/tomli-2.2.1-cp313-cp313-macosx_10_13_x86_64.whl", hash = "sha256:f4039b9cbc3048b2416cc57ab3bda989a6fcf9b36cf8937f01a6e731b64f80d7", size = 132708 },
    { url = "https://files.pythonhosted.org/packages/c0/ec/46b4108816de6b385141f082ba99e315501ccd0a2ea23db4a100dd3990ea/tomli-2.2.1-cp313-cp313-macosx_11_0_arm64.whl", hash = "sha256:286f0ca2ffeeb5b9bd4fcc8d6c330534323ec51b2f52da063b11c502da16f30c", size = 123582 },
    { url = "https://files.pythonhosted.org/packages/a0/bd/b470466d0137b37b68d24556c38a0cc819e8febe392d5b199dcd7f578365/tomli-2.2.1-cp313-cp313-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:a92ef1a44547e894e2a17d24e7557a5e85a9e1d0048b0b5e7541f76c5032cb13", size = 232543 },
    { url = "https://files.pythonhosted.org/packages/d9/e5/82e80ff3b751373f7cead2815bcbe2d51c895b3c990686741a8e56ec42ab/tomli-2.2.1-cp313-cp313-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:9316dc65bed1684c9a98ee68759ceaed29d229e985297003e494aa825ebb0281", size = 241691 },
    { url = "https://files.pythonhosted.org/packages/05/7e/2a110bc2713557d6a1bfb06af23dd01e7dde52b6ee7dadc589868f9abfac/tomli-2.2.1-cp313-cp313-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:e85e99945e688e32d5a35c1ff38ed0b3f41f43fad8df0bdf79f72b2ba7bc5272", size = 251170 },
    { url = "https://files.pythonhosted.org/packages/64/7b/22d713946efe00e0adbcdfd6d1aa119ae03fd0b60ebed51ebb3fa9f5a2e5/tomli-2.2.1-cp313-cp313-musllinux_1_2_aarch64.whl", hash = "sha256:ac065718db92ca818f8d6141b5f66369833d4a80a9d74435a268c52bdfa73140", size = 236530 },
    { url = "https://files.pythonhosted.org/packages/38/31/3a76f67da4b0cf37b742ca76beaf819dca0ebef26d78fc794a576e08accf/tomli-2.2.1-cp313-cp313-musllinux_1_2_i686.whl", hash = "sha256:d920f33822747519673ee656a4b6ac33e382eca9d331c87770faa3eef562aeb2", size = 258666 },
    { url = "https://files.pythonhosted.org/packages/07/10/5af1293da642aded87e8a988753945d0cf7e00a9452d3911dd3bb354c9e2/tomli-2.2.1-cp313-cp313-musllinux_1_2_x86_64.whl", hash = "sha256:a198f10c4d1b1375d7687bc25294306e551bf1abfa4eace6650070a5c1ae2744", size = 243954 },
    { url = "https://files.pythonhosted.org/packages/5b/b9/1ed31d167be802da0fc95020d04cd27b7d7065cc6fbefdd2f9186f60d7bd/tomli-2.2.1-cp313-cp313-win32.whl", hash = "sha256:d3f5614314d758649ab2ab3a62d4f2004c825922f9e370b29416484086b264ec", size = 98724 },
    { url = "https://files.pythonhosted.org/packages/c7/32/b0963458706accd9afcfeb867c0f9175a741bf7b19cd424230714d722198/tomli-2.2.1-cp313-cp313-win_amd64.whl", hash = "sha256:a38aa0308e754b0e3c67e344754dff64999ff9b513e691d0e786265c93583c69", size = 109383 },
    { url = "https://files.pythonhosted.org/packages/6e/c2/61d3e0f47e2b74ef40a68b9e6ad5984f6241a942f7cd3bbfbdbd03861ea9/tomli-2.2.1-py3-none-any.whl", hash = "sha256:cb55c73c5f4408779d0cf3eef9f762b9c9f147a77de7b258bef0a5628adc85cc", size = 14257 },
]

[[package]]
name = "tox"
version = "4.25.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "cachetools" },
    { name = "chardet" },
    { name = "colorama" },
    { name = "filelock" },
    { name = "packaging" },
    { name = "platformdirs" },
    { name = "pluggy" },
    { name = "pyproject-api" },
    { name = "tomli", marker = "python_full_version < '3.11'" },
    { name = "typing-extensions", marker = "python_full_version < '3.11'" },
    { name = "virtualenv" },
]
sdist = { url = "https://files.pythonhosted.org/packages/fe/87/692478f0a194f1cad64803692642bd88c12c5b64eee16bf178e4a32e979c/tox-4.25.0.tar.gz", hash = "sha256:dd67f030317b80722cf52b246ff42aafd3ed27ddf331c415612d084304cf5e52", size = 196255 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/f9/38/33348de6fc4b1afb3d76d8485c8aecbdabcfb3af8da53d40c792332e2b37/tox-4.25.0-py3-none-any.whl", hash = "sha256:4dfdc7ba2cc6fdc6688dde1b21e7b46ff6c41795fb54586c91a3533317b5255c", size = 172420 },
]

[[package]]
name = "typing-extensions"
version = "4.13.2"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/f6/37/23083fcd6e35492953e8d2aaaa68b860eb422b34627b13f2ce3eb6106061/typing_extensions-4.13.2.tar.gz", hash = "sha256:e6c81219bd689f51865d9e372991c540bda33a0379d5573cddb9a3a23f7caaef", size = 106967 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/8b/54/b1ae86c0973cc6f0210b53d508ca3641fb6d0c56823f288d108bc7ab3cc8/typing_extensions-4.13.2-py3-none-any.whl", hash = "sha256:a439e7c04b49fec3e5d3e2beaa21755cadbbdc391694e28ccdd36ca4a1408f8c", size = 45806 },
]

[[package]]
name = "virtualenv"
version = "20.30.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "distlib" },
    { name = "filelock" },
    { name = "platformdirs" },
]
sdist = { url = "https://files.pythonhosted.org/packages/38/e0/633e369b91bbc664df47dcb5454b6c7cf441e8f5b9d0c250ce9f0546401e/virtualenv-20.30.0.tar.gz", hash = "sha256:800863162bcaa5450a6e4d721049730e7f2dae07720e0902b0e4040bd6f9ada8", size = 4346945 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/4c/ed/3cfeb48175f0671ec430ede81f628f9fb2b1084c9064ca67ebe8c0ed6a05/virtualenv-20.30.0-py3-none-any.whl", hash = "sha256:e34302959180fca3af42d1800df014b35019490b119eba981af27f2fa486e5d6", size = 4329461 },
]



================================================
FILE: .pre-commit-config.yaml
================================================
# See https://pre-commit.com for more information
# See https://pre-commit.com/hooks.html for more hooks
repos:
-   repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v3.2.0
    hooks:
    -   id: trailing-whitespace
    -   id: end-of-file-fixer
    -   id: check-yaml
    -   id: check-added-large-files
    -   id: debug-statements
-   repo: https://github.com/PyCQA/flake8
    rev: 6.0.0
    hooks:
    -   id: flake8
-   repo: https://github.com/asottile/pyupgrade
    rev: v3.3.1
    hooks:
    -   id: pyupgrade
        args: [--py37-plus]
-   repo: https://github.com/tox-dev/pyproject-fmt
    rev: "0.8.0"
    hooks:
    -   id: pyproject-fmt
-   repo: https://github.com/asottile/reorder_python_imports
    rev: v3.9.0
    hooks:
    -   id: reorder-python-imports
-   repo: https://github.com/asottile/add-trailing-comma
    rev: v2.4.0
    hooks:
    -   id: add-trailing-comma
        args: [--py36-plus]
-   repo: https://github.com/pre-commit/mirrors-autopep8
    rev: v2.0.1
    hooks:
    -   id: autopep8



================================================
FILE: cocotbext/spi/__init__.py
================================================
"""
Copyright (c) 2021 Spencer Chang

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
"""
from .about import __version__
from .exceptions import SpiFrameError
from .exceptions import SpiFrameTimeout
from .spi import reverse_word
from .spi import SpiBus
from .spi import SpiConfig
from .spi import SpiMaster
from .spi import SpiSlaveBase


__all__ = [
    "__version__",
    "SpiMaster",
    "SpiSlaveBase",
    "SpiBus",
    "SpiConfig",
    "SpiFrameError",
    "SpiFrameTimeout",
    "reverse_word",
]



================================================
FILE: cocotbext/spi/about.py
================================================
try:
    from importlib.metadata import version, PackageNotFoundError
except ImportError:
    from pkg_resources import get_distribution, DistributionNotFound

    try:
        __version__ = get_distribution("cocotbext-spi").version
    except DistributionNotFound:
        __version__ = "0.0.0"
else:
    try:
        __version__ = version("cocotbext-spi")
    except PackageNotFoundError:
        __version__ = "0.0.0"



================================================
FILE: cocotbext/spi/exceptions.py
================================================
class SpiFrameError(Exception):
    pass


class SpiFrameTimeout(Exception):
    pass



================================================
FILE: cocotbext/spi/spi.py
================================================
# SPDX-License-Identifier: MIT
# SPDX-FileCopyrightText: 2021 Spencer Chang
import logging
from abc import ABC
from abc import abstractmethod
from collections import deque
from dataclasses import dataclass
from typing import Deque
from typing import Iterable
from typing import Optional
from typing import Tuple

import cocotb
from cocotb.clock import BaseClock
from cocotb.triggers import Edge
from cocotb.triggers import Event
from cocotb.triggers import FallingEdge
from cocotb.triggers import First
from cocotb.triggers import RisingEdge
from cocotb.triggers import Timer
from cocotb_bus.bus import Bus

from .exceptions import SpiFrameError


class SpiBus(Bus):
    def __init__(
        self,
        entity=None,
        prefix=None,
        sclk_name='sclk',
        mosi_name='mosi',
        miso_name='miso',
        cs_name=None,
        **kwargs,
    ):
        signals = {'sclk': sclk_name, 'mosi': mosi_name, 'miso': miso_name}
        if cs_name is None:
            optional_signals = {}
        else:
            optional_signals = {'cs': cs_name}
        super().__init__(entity, prefix, signals, optional_signals=optional_signals, **kwargs)

    @classmethod
    def from_entity(cls, entity, **kwargs):
        return cls(entity, **kwargs)

    @classmethod
    def from_prefix(cls, entity, prefix, **kwargs):
        return cls(entity, prefix, **kwargs)

@dataclass
class SpiConfig:
    word_width: int = 8
    sclk_freq: Optional[float] = 25e6
    cpol: bool = False
    cpha: bool = False
    msb_first: bool = True
    frame_spacing_ns: int = 1
    data_output_idle: int = 1
    ignore_rx_value: Optional[int] = None
    cs_active_low: bool = True


class SpiMaster:
    def __init__(self, bus: SpiBus, config: SpiConfig) -> None:
        self.log = logging.getLogger(f"cocotb.{bus.sclk._path}")

        # spi signals
        self._sclk = bus.sclk
        self._mosi = bus.mosi
        self._miso = bus.miso
        self.has_cs = hasattr(bus, 'cs')
        if self.has_cs:
            self._cs = bus.cs

        # size of a transfer
        self._config = config

        self.queue_tx: Deque[Tuple[int, bool]] = deque()
        self.queue_rx: Deque[int] = deque()

        self.sync = Event()

        self._idle = Event()
        self._idle.set()

        self._sclk.setimmediatevalue(int(self._config.cpol))
        self._mosi.setimmediatevalue(self._config.data_output_idle)
        if self.has_cs:
            self._cs.setimmediatevalue(1 if self._config.cs_active_low else 0)

        self._SpiClock = _SpiClock(
            signal=self._sclk,
            period=(1 / self._config.sclk_freq),
            units="sec",
            start_high=self._config.cpha,
        )

        self._run_coroutine_obj = None
        self._restart()

    def _restart(self) -> None:
        if self._run_coroutine_obj is not None:
            self._run_coroutine_obj.kill()
        self._run_coroutine_obj = cocotb.start_soon(self._run())

    async def write(self, data: Iterable[int], *, burst: bool = False):
        self.write_nowait(data, burst=burst)
        await self._idle.wait()

    def write_nowait(self, data: Iterable[int], *, burst: bool = False) -> None:
        """ Write the data to the MOSI line

        Args:
            data: an iterable of ints, if the wordwidth is 8, a bytearray is typically appropriate
            burst: if true, CS is not deasserted between writes
        """
        if self._config.msb_first:
            for b in data:
                self.queue_tx.append((int(b), burst))
        else:
            for b in data:
                self.queue_tx.append((reverse_word(int(b), self._config.word_width), burst))
        self.sync.set()
        self._idle.clear()

    async def read(self, count: int = -1):
        while self.empty_rx():
            self.sync.clear()
            await self.sync.wait()
        return self.read_nowait(count)

    def read_nowait(self, count: int = -1) -> Iterable[int]:
        if count < 0:
            count = len(self.queue_rx)
        if self._config.word_width == 8:
            data = bytearray()
        else:
            data = []
        for k in range(count):
            data.append(self.queue_rx.popleft())
        return data

    def count_tx(self) -> int:
        return len(self.queue_tx)

    def empty_tx(self) -> bool:
        return not self.queue_tx

    def count_rx(self) -> int:
        return len(self.queue_rx)

    def empty_rx(self) -> bool:
        return not self.queue_rx

    def idle(self) -> bool:
        return self.empty_tx() and self.empty_rx()

    def clear(self) -> None:
        """ Clears the RX and TX queues """
        self.queue_tx.clear()
        self.queue_rx.clear()

    async def wait(self) -> None:
        """ Wait for idle """
        await self._idle.wait()

    async def _run(self):
        while True:
            while not self.queue_tx:
                self._sclk.value = int(self._config.cpol)
                self._idle.set()
                self.sync.clear()
                await self.sync.wait()

            tx_word, burst = self.queue_tx.popleft()
            rx_word = 0

            self.log.debug("Write byte 0x%02x", tx_word)

            # the timing diagrams are CPHA/CPOL convention come from
            # https://en.wikipedia.org/wiki/Serial_Peripheral_Interface
            # this is also compliant with Linux Kernel definiton of SPI

            # if CPHA=0, the first bit is typically clocked out on edge of chip select
            if not self._config.cpha:
                self._mosi.value = bool(tx_word & (1 << self._config.word_width - 1))

            # set the chip select
            if self.has_cs:
                self._cs.value = int(not self._config.cs_active_low)
            await Timer(self._SpiClock.period, units='step')

            await self._SpiClock.start()

            if self._config.cpha:
                # if CPHA=1, the first edge is propagate, the second edge is sample
                for k in range(self._config.word_width):
                    # the out changes on the leading edge of clock
                    await Edge(self._sclk)
                    self._mosi.value = bool(tx_word & (1 << (self._config.word_width - 1 - k)))

                    # while the in captures on the trailing edge of the clock
                    await Edge(self._sclk)
                    rx_word |= bool(self._miso.value.integer) << (self._config.word_width - 1 - k)
            else:
                # if CPHA=0, the first edge is sample, the second edge is propagate
                # we already clocked out one bit on edge of chip select, so we will clock out less bits
                for k in range(self._config.word_width - 1):
                    await Edge(self._sclk)
                    rx_word |= bool(self._miso.value.integer) << (self._config.word_width - 1 - k)

                    await Edge(self._sclk)
                    self._mosi.value = bool(tx_word & (1 << (self._config.word_width - 2 - k)))

                # but we haven't sampled enough times, so we will wait for another edge to sample
                await Edge(self._sclk)
                rx_word |= bool(self._miso.value.integer)

            # set sclk back to idle state
            await self._SpiClock.stop()
            self._sclk.value = self._config.cpol

            # wait another sclk period before restoring the chip select and mosi to idle (not necessarily part of spec)
            await Timer(self._SpiClock.period, units='step')
            self._mosi.value = int(self._config.data_output_idle)
            if self.has_cs:
                if not burst or self.empty_tx():
                    self._cs.value = int(self._config.cs_active_low)

            # wait some time before starting the next transaction
            if not 0 == self._config.frame_spacing_ns:
                await Timer(self._config.frame_spacing_ns, units='ns')

            if not self._config.msb_first:
                rx_word = reverse_word(rx_word, self._config.word_width)

            # if the ignore_rx_value has been set, ignore all rx_word equal to the set value
            if rx_word != self._config.ignore_rx_value:
                self.queue_rx.append(rx_word)

            self.sync.set()


class SpiSlaveBase(ABC):
    _config: SpiConfig

    def __init__(self, bus: SpiBus):
        self.log = logging.getLogger(f"cocotb.{bus.sclk._path}")

        self._sclk = bus.sclk
        self._mosi = bus.mosi
        self._miso = bus.miso
        self._cs = bus.cs

        self._miso.value = self._config.data_output_idle

        self.idle = Event()
        self.idle.set()

        self._run_coroutine_obj = None
        self._restart()

    def _restart(self):
        if self._run_coroutine_obj is not None:
            self._run_coroutine_obj.kill()
        self._run_coroutine_obj = cocotb.start_soon(self._run())

    async def _shift(self, num_bits: int, tx_word: Optional[int] = None) -> int:
        """ Shift in data on the MOSI signal. Shift out the tx_word on the MISO signal.

        Args:
            num_bits: the number of bits to shift
            tx_word: the word to be transmitted on the wire

        Returns:
            the received word on the MOSI line
        """
        rx_word = 0

        frame_end = RisingEdge(self._cs) if self._config.cs_active_low else FallingEdge(self._cs)

        for k in range(num_bits):
            # If both events happen at the same time, the returned one is indeterminate, thus
            # checking for cs = 1
            if (await First(Edge(self._sclk), frame_end)) == frame_end or self._cs.value == 1:
                raise SpiFrameError("End of frame in the middle of a transaction")

            if self._config.cpha:
                # when CPHA=1, the slave should shift out on the first edge
                if tx_word is not None:
                    self._miso.value = bool(tx_word & (1 << (num_bits - 1 - k)))
                else:
                    self._miso.value = self._config.data_output_idle
            else:
                # when CPHA=0, the slave should sample on the first edge
                rx_word |= int(self._mosi.value.integer) << (num_bits - 1 - k)

            # do the opposite of what was done on the first edge
            if (await First(Edge(self._sclk), frame_end)) == frame_end or self._cs.value == 1:
                raise SpiFrameError("End of frame in the middle of a transaction")

            if self._config.cpha:
                rx_word |= int(self._mosi.value.integer) << (num_bits - 1 - k)
            else:
                if tx_word is not None:
                    self._miso.value = bool(tx_word & (1 << (num_bits - 1 - k)))
                else:
                    self._miso.value = self._config.data_output_idle

        return rx_word

    async def _transparent_shift(self, num_bits: int, delay: int = 0, delay_units: str = 'ns') -> int:
        """ Shift in data on the MOSI signal, and present on MISO after a delay.

        As the data is shifted in from MOSI, present it back out on the MISO signal
        after a specified delay. This is equivalent to a fork in the flip flop output:
            MOSI > DFF |-> MISO
                       |-> RX_WORD_SHIFT_REGISTER


        Args:
            num_bits: the numbers of bits to transparently shift
            delay: the time to delay before copying MOSI to MISO (default=0)
            delay_units: the time units for the delay (default='ns')

        Returns:
            the received word on the MOSI line
        """
        rx_word = 0

        frame_end = RisingEdge(self._cs) if self._config.cs_active_low else FallingEdge(self._cs)
        propagate_out_delay = Timer(delay, units=delay_units)

        for k in range(num_bits):
            f = await First(Edge(self._sclk), frame_end)
            if not self._config.cpha:
                # when CPHA=0, the first thing the slave should do is read in
                rx_word |= int(self._mosi.value.integer) << (num_bits - 1 - k)
                most_recent_bit = int(self._mosi.value.integer)

                w = await First(propagate_out_delay, frame_end, Edge(self._sclk))

                if w != propagate_out_delay:
                    if w == frame_end:
                        raise SpiFrameError("Unexpected end of frame in the middle of a transaction")
                    else:
                        raise SpiFrameError("Unexpected edge of sclk while waiting to propagate next bit")

                self._miso.value = bool(most_recent_bit)

            s = await First(Edge(self._sclk), frame_end)

            if self._config.cpha:
                # when CPHA=1, the second thing we should do is read in
                rx_word |= int(self._mosi.value.integer) << (num_bits - 1 - k)
                most_recent_bit = int(self._mosi.value.integer)

                w = await First(propagate_out_delay, frame_end, Edge(self._sclk))

                if w != propagate_out_delay:
                    if w == frame_end:
                        raise SpiFrameError("Unexpected end of frame in the middle of a transaction")
                    else:
                        raise SpiFrameError("Unexpected edge of sclk while waiting to propagate next bit")

                self._miso.value = bool(most_recent_bit)

            if frame_end in (f, s):
                raise SpiFrameError("End of frame in the middle of a transaction")

        return rx_word

    @abstractmethod
    async def _transaction(self, frame_start, frame_end):
        """Implement the details of an SPI transaction """
        raise NotImplementedError("Please implement the _transaction method")

    async def _run(self):
        if self._config.cs_active_low:
            frame_start = FallingEdge(self._cs)
            frame_end = RisingEdge(self._cs)
        else:
            frame_start = RisingEdge(self._cs)
            frame_end = FallingEdge(self._cs)

        frame_spacing = Timer(self._config.frame_spacing_ns, units='ns')

        while True:
            self.idle.set()
            if (await First(frame_start, frame_spacing)) == frame_start:
                raise SpiFrameError(f"There must be at least {self._config.frame_spacing_ns} ns between frames")
            await self._transaction(frame_start, frame_end)


class _SpiClock(BaseClock):
    def __init__(self, signal, period, units="step", start_high=True):
        BaseClock.__init__(self, signal)
        self.period = cocotb.utils.get_sim_steps(period, units, round_mode="round")
        self.half_period = cocotb.utils.get_sim_steps(period / 2.0, units, round_mode="round")
        self.frequency = 1.0 / cocotb.utils.get_time_from_sim_steps(self.period, units='us')

        self.signal = signal

        self.start_high = start_high

        self._idle = Event()
        self._sync = Event()
        self._start = Event()

        self._idle.set()

        self._run_coroutine_obj = None
        self._restart()

    def _restart(self):
        if self._run_coroutine_obj is not None:
            self._run_cr.kill()
        self._run_cr = cocotb.start_soon(self._run())

    async def stop(self) -> None:
        self.stop_no_wait()
        await self._idle.wait()

    def stop_no_wait(self) -> None:
        self._start.clear()
        self._sync.set()

    async def start(self) -> None:
        self.start_no_wait()

    def start_no_wait(self) -> None:
        self._start.set()
        self._sync.set()

    async def _run(self):
        t = Timer(self.half_period)
        if self.start_high:
            while True:
                while not self._start.is_set():
                    self._idle.set()
                    self._sync.clear()
                    await self._sync.wait()

                self._idle.clear()
                self.signal.value = 1
                await t
                if self._start.is_set():
                    self.signal.value = 0
                    await t
        else:
            while True:
                while not self._start.is_set():
                    self._idle.set()
                    self._sync.clear()
                    await self._sync.wait()

                self._idle.clear()
                self.signal.value = 0
                await t
                if self._start.is_set():
                    self.signal.value = 1
                    await t


def reverse_word(n: int, width: int) -> int:
    return int('{:0{width}b}'.format(n, width=width)[::-1], 2)



================================================
FILE: cocotbext/spi/devices/generic.py
================================================
# SPDX-License-Identifier: MIT
# SPDX-FileCopyrightText: 2021 Spencer Chang
# Transmits the previously received word on the next transaction
from collections import deque

from cocotb.triggers import Edge
from cocotb.triggers import First

from ..exceptions import SpiFrameError
from ..spi import reverse_word
from ..spi import SpiBus
from ..spi import SpiConfig
from ..spi import SpiSlaveBase


class SpiSlaveLoopback(SpiSlaveBase):
    def __init__(self, bus: SpiBus, config: SpiConfig):
        self._config = config

        self._out_queue = deque()
        self._out_queue.append(0)

        super().__init__(bus)

    async def get_contents(self):
        await self.idle.wait()
        if self._config.msb_first:
            return self._out_queue[0]
        else:
            return reverse_word(self._out_queue[0], self._config.word_width)

    async def _transaction(self, frame_start, frame_end):
        await frame_start
        self.idle.clear()

        # we do not have to reverse the word based on msb or lsb since we are just looping back
        tx_word = self._out_queue.popleft()
        if not self._config.cpha:
            # when CPHA=0, we use the chip select edge (frame start) to propagate data.
            self._miso.value = bool(tx_word & (1 << self._config.word_width - 1))
            # now we can do the sclk cycles, but we do one less (because we don't have all the words
            content = int(await self._shift(self._config.word_width - 1, tx_word=tx_word))

            # get the last data bit
            r = await First(Edge(self._sclk), frame_end)
            content = (content << 1) | int(self._mosi.value.integer)

            # check to make sure we didn't lose the frame
            if r == frame_end:
                raise SpiFrameError("End of frame before last bit was sampled")
        else:
            content = int(await self._shift(self._config.word_width, tx_word=tx_word))

        await frame_end
        self._out_queue.append(content)



================================================
FILE: cocotbext/spi/devices/ADI/__init__.py
================================================
"""
Copyright (c) 2021 Spencer Chang

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
"""
import os
import sys

from ... import SpiSlaveBase

__dir_path = os.path.dirname(os.path.abspath(__file__))
__ignore = ['__init__.py']

for f in [f[:-3] for f in os.listdir(__dir_path) if f.endswith('.py') and f not in __ignore]:
    mod = __import__('.'.join([__name__, f]), fromlist=[f])
    objects = [getattr(mod, x) for x in dir(mod)]
    to_import = []

    for a in objects:
        try:
            if issubclass(a, SpiSlaveBase):
                to_import.append(a)
        except TypeError:
            pass

    for i in to_import:
        try:
            setattr(sys.modules[__name__], i.__name__, i)
        except AttributeError:
            pass



================================================
FILE: cocotbext/spi/devices/ADI/ADXL345.py
================================================
from cocotb.triggers import FallingEdge
from cocotb.triggers import First
from cocotb.triggers import RisingEdge

from ...spi import SpiBus
from ...spi import SpiConfig
from ...spi import SpiFrameError
from ...spi import SpiSlaveBase


class ADXL345(SpiSlaveBase):
    _config = SpiConfig(
        # technically, a word is 16 bits long on this chip, but this chip allows for 16+8n bits if the multibyte is set
        word_width=8,
        cpol=True,
        cpha=True,
        msb_first=True,
        frame_spacing_ns=150,
        cs_active_low=True,
    )

    def __init__(self, bus: SpiBus):
        self._registers = {
            0x00: 0b1110_0101,  # DEVID
            0x1D: 0x00,         # Tap Threshold
            0x1E: 0x00,         # OFSX
            0x1F: 0x00,         # OFSY
            0x20: 0x00,         # OFSZ
            0x21: 0x00,         # DUR
            0x22: 0x00,         # LATENT
            0x23: 0x00,         # WINDOW
            0x24: 0x00,         # THRESH_ACT
            0x25: 0x00,         # THRESH_INACT
            0x26: 0x00,         # TIME_INACT
            0x27: 0x00,         # ACT_INACT_CTL
            0x28: 0x00,         # THRESH_FF
            0x29: 0x00,         # TIME_FF
            0x2A: 0x00,         # TAP_AXES
            0x2B: 0x00,         # ACT_TAP_STATUS
            0x2C: 0b0000_1010,  # BW_RATE
            0x2D: 0x00,         # POWER_CTL
            0x2E: 0x00,         # INT_ENABLE
            0x2F: 0x00,         # INT_MAP
            0x30: 0b0000_0010,  # INT_SOURCE
            0x31: 0x00,         # DATA_FORMAT
            0x32: 0x00,         # DATAX0
            0x33: 0x00,         # DATAX1
            0x34: 0x00,         # DATAY0
            0x35: 0x00,         # DATAY1
            0x36: 0x00,         # DATAZ0
            0x37: 0x00,         # DATAZ1
            0x38: 0x00,         # FIFO_CTL
            0x39: 0x00,         # FIFO_STATUS
        }
        super().__init__(bus)

    async def get_register(self, reg_num: int) -> int:
        await self.idle.wait()
        return self._registers[reg_num]

    def create_spi_command(self, operation: str, address: int, *, multibyte: bool = False) -> int:
        command = 0
        if operation == "read":
            command |= 1 << 7
        elif operation == "write":
            # it is already 0
            pass
        else:
            raise ValueError("Expected operation to bein ['read', 'write']")

        if address not in self._registers:
            raise ValueError(f"Expected address to be in {list(self._registers.keys())}")

        if multibyte:
            command |= 1 << 6

        return command | (address & 0x0f_ff)

    async def _transaction(self, frame_start, frame_end) -> None:
        await frame_start
        self.idle.clear()

        if not bool(self._sclk.value):
            raise SpiFrameError("ADXL345: sclk should be high at chip select edge")

        do_write = not bool(await self._shift(1))
        do_multibyte = bool(await self._shift(1))
        address = int(await self._shift(6))
        content = int(await self._shift(8, tx_word=self._registers[address]))

        if do_write:
            self._registers[address] = content

        if do_multibyte:
            # check for multibyte read/write by seeing which is first, a clk edge or frame end
            while await First(frame_end, FallingEdge(self._sclk)) != frame_end:
                address = address + 1
                self._miso.value = bool(self._registers[address] & 0b1000_0000)

                # shift in the remaining words
                rx_word = int(await self._shift(7, tx_word=(self._registers[address] & 0b0111_1111))) << 1

                # grab the last bit
                if (await First(RisingEdge(self._sclk), frame_end)) == frame_end or self._cs.value == 1:
                    raise SpiFrameError("End of frame in the middle of a transaction")
                rx_word |= int(self._mosi.value.integer)

                # perform write if necessary
                if do_write:
                    self._registers[address] = rx_word
        else:
            if await First(frame_end, FallingEdge(self._sclk)) != frame_end:
                raise SpiFrameError("ADXL345: received another clock edge when end of frame expected")

        if not bool(self._sclk.value):
            raise SpiFrameError("ADXL345: sclk should be high on chip select edge")



================================================
FILE: cocotbext/spi/devices/TI/__init__.py
================================================
"""
Copyright (c) 2021 Spencer Chang

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
"""
import os
import sys

from ... import SpiSlaveBase

__dir_path = os.path.dirname(os.path.abspath(__file__))
__ignore = ['__init__.py']

for f in [f[:-3] for f in os.listdir(__dir_path) if f.endswith('.py') and f not in __ignore]:
    mod = __import__('.'.join([__name__, f]), fromlist=[f])
    objects = [getattr(mod, x) for x in dir(mod)]
    to_import = []

    for a in objects:
        try:
            if issubclass(a, SpiSlaveBase):
                to_import.append(a)
        except TypeError:
            pass

    for i in to_import:
        try:
            setattr(sys.modules[__name__], i.__name__, i)
        except AttributeError:
            pass



================================================
FILE: cocotbext/spi/devices/TI/ADS8028.py
================================================
# SPDX-License-Identifier: MIT
# SPDX-FileCopyrightText: 2021 Spencer Chang
from collections import deque

from cocotb.triggers import FallingEdge
from cocotb.triggers import First
from cocotb.triggers import RisingEdge

from ...exceptions import SpiFrameError
from ...spi import SpiBus
from ...spi import SpiConfig
from ...spi import SpiSlaveBase


class ADS8028(SpiSlaveBase):
    _config = SpiConfig(
        word_width=16,
        cpol=True,
        cpha=False,
        msb_first=True,
        frame_spacing_ns=6,
        cs_active_low=True,
    )

    def __init__(self, bus: SpiBus):
        self._control_register = 0
        self._control_register_updated = False
        self.adc_values = {
            0: 0,  # ain0
            1: 1,
            2: 2,
            3: 3,
            4: 4,
            5: 5,
            6: 6,
            7: 7,  # ain7
            8: 8,  # temperature
        }
        self._out_queue = deque()

        super().__init__(bus)

    async def get_control_register(self):
        await self.idle.wait()
        return self._control_register

    def create_spi_word(self, operation, content):
        command = 0
        if operation == "read":
            # it is already 0
            pass
        elif operation == "write":
            command |= 1 << 15
        else:
            raise ValueError("Expected operation to be in ['read', 'write']")

        command |= (content & 0b111111111111111)

        return command

    def _generate_output(self):

        # check standby
        if self._control_register & (1 << 0):
            return 0

        # if we just updated the register, or its repeat, lets queue up the next one
        if self._control_register_updated or ((self._control_register & (1 << 14)) and not self._out_queue):
            self._control_register_updated = False

            for i in range(9):
                if not self._control_register & (1 << (13 - i)):
                    continue
                address = i << 12
                if i == 8 and (self._control_register & (1 << 1)):
                    address |= (1 << 12)
                self._out_queue.append((address & 0xF000) + (self.adc_values[i] & 0xFFF))

        if self._out_queue:
            return self._out_queue.popleft()
        return 0

    async def _transaction(self, frame_start, frame_end):
        await frame_start
        self.idle.clear()

        # SCLK pin should be high at the chip select edge
        if not bool(self._sclk.value):
            raise SpiFrameError("ADS8028: sclk should be high at chip select edge")

        tx_word = self._generate_output()

        # propagate the first bit on the fram start
        self._miso.value = bool(tx_word & (1 << 15))

        do_write = bool(await self._shift(1, tx_word=(tx_word & (1 << 14))))
        content = int(await self._shift(14, tx_word=(tx_word & (0x3FFF))))

        # get the last data bit
        r = await First(RisingEdge(self._sclk), frame_end)
        content = (content << 1) | int(self._mosi.value.integer)

        if r == frame_end:
            raise SpiFrameError("ADS8028: end of frame before last bit was sampled")

        # end of frame
        if await First(frame_end, FallingEdge(self._sclk)) != frame_end:
            raise SpiFrameError("ADS8028: clocked more than 16 bits")

        if not bool(self._sclk.value):
            raise SpiFrameError("ADS8028: sclk should be high at chip select edge")

        if do_write:
            self._control_register = content
            self._control_register_updated = True
            self._out_queue.clear()
            self._out_queue.append(0)



================================================
FILE: cocotbext/spi/devices/TI/DRV8304.py
================================================
# SPDX-License-Identifier: MIT
# SPDX-FileCopyrightText: 2021 Spencer Chang
from cocotb.triggers import First
from cocotb.triggers import RisingEdge

from ...exceptions import SpiFrameError
from ...spi import SpiBus
from ...spi import SpiConfig
from ...spi import SpiSlaveBase


class DRV8304(SpiSlaveBase):
    _config = SpiConfig(
        word_width=16,
        cpol=False,
        cpha=True,
        msb_first=True,
        frame_spacing_ns=400,
        cs_active_low=True,
    )

    def __init__(self, bus: SpiBus):
        self._registers = {
            0: 0b00000000000,
            1: 0b00000000000,
            2: 0b00000000000,
            3: 0b01101110111,
            4: 0b11101110111,
            5: 0b00101000101,
            6: 0b01010000011,
        }

        super().__init__(bus)

    async def get_register(self, reg_num):
        await self.idle.wait()
        return self._registers[reg_num]

    def create_spi_word(self, operation, address, content):
        command = 0
        if operation == "read":
            command |= 1 << 15
        elif operation == "write":
            # it is already 0
            pass
        else:
            raise ValueError("Expected operation to be in ['read', 'write']")

        try:
            self._registers[address]
        except KeyError:
            raise ValueError(
                f"Expected address to be in {list(self._registers.keys())}",
            )
        command |= (address & 0b1111) << 11
        command |= content & 0b11111111111

        return command

    async def _transaction(self, frame_start, frame_end):
        await frame_start
        self.idle.clear()

        # SCLK pin should be low at the chip select edge
        if bool(self._sclk.value):
            raise SpiFrameError("DRV8304: sclk should be low at chip select edge")

        do_write = not bool(await self._shift(1))
        address = int(await self._shift(4))
        content = int(await self._shift(11, tx_word=self._registers[address]))

        # end of frame
        if await First(frame_end, RisingEdge(self._sclk)) != frame_end:
            raise SpiFrameError("DRV8304: clocked more than 16 bits")

        if bool(self._sclk.value):
            raise SpiFrameError("DRV8304: sclk should be low at chip select edge")

        if do_write:
            self._registers[address] = content



================================================
FILE: cocotbext/spi/devices/Trinamic/__init__.py
================================================
"""
Copyright (c) 2021 Spencer Chang

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
"""
import os
import sys

from ... import SpiSlaveBase

__dir_path = os.path.dirname(os.path.abspath(__file__))
__ignore = ['__init__.py']

for f in [f[:-3] for f in os.listdir(__dir_path) if f.endswith('.py') and f not in __ignore]:
    mod = __import__('.'.join([__name__, f]), fromlist=[f])
    objects = [getattr(mod, x) for x in dir(mod)]
    to_import = []

    for a in objects:
        try:
            if issubclass(a, SpiSlaveBase):
                to_import.append(a)
        except TypeError:
            pass

    for i in to_import:
        try:
            setattr(sys.modules[__name__], i.__name__, i)
        except AttributeError:
            pass



================================================
FILE: cocotbext/spi/devices/Trinamic/TMC4671.py
================================================
# SPDX-License-Identifier: MIT
# SPDX-FileCopyrightText: 2021 Spencer Chang
from cocotb.triggers import FallingEdge
from cocotb.triggers import First
from cocotb.triggers import RisingEdge
from cocotb.triggers import Timer

from ...exceptions import SpiFrameError
from ...spi import SpiBus
from ...spi import SpiConfig
from ...spi import SpiSlaveBase


class TMC4671(SpiSlaveBase):
    _config = SpiConfig(
        word_width=40,
        cpol=True,
        cpha=True,
        msb_first=True,
        frame_spacing_ns=6,
        cs_active_low=True,
    )

    def __init__(self, bus: SpiBus):
        self._address_change_callbacks = {}

        # mockup of the test registers
        self._registers = {
            0x00: int.from_bytes(b"4671", byteorder='big'),
            0x01: 0x0000_0000,
        }

        self._register_address_changed_hook(
            0x01, [0x00],
            lambda: {
                0: int.from_bytes(b"4671", byteorder='big'),
                1: 0x0000_0100,
                2: 0x2022_0323,
                3: 0x0010_1029,
                4: int.from_bytes(b"var2", byteorder='big'),
                5: int.from_bytes(b"rev3", byteorder='big'),
            }[self._registers[0x01]],
        )

        super().__init__(bus)

    async def get_register(self, reg_num):
        await self.idle.wait()
        return self._registers[reg_num]

    def create_spi_word(self, operation, address, content):
        command = 0
        if operation == "read":
            # it is already 0
            pass
        elif operation == "write":
            command |= 1 << 39
        else:
            raise ValueError("Expected operation to be in ['read', 'write']")

        try:
            self._registers[address]
        except KeyError:
            raise ValueError(f"Expected address to be in {list(self._registers.keys())}")
        command |= (address & 0b1111) << 32
        command |= (content & 0xFFFF_FFFF)

        return command

    def _register_address_changed_hook(self, watch_address, update_addresses, f):
        self._address_change_callbacks[watch_address] = (update_addresses, f)

    async def _transaction(self, frame_start, frame_end):
        await frame_start
        self.idle.clear()

        # SCLK pin should be low at the chip select edge
        if not bool(self._sclk.value):
            raise SpiFrameError("TMC4671: sclk should be high at chip select edge")

        s = await FallingEdge(self._sclk)
        t = await Timer(20, units='ns')
        self._miso.value = self._mosi.value
        do_write = bool(int(self._mosi.value))

        if frame_end in (s, t):
            raise SpiFrameError("TMC4671: chip select deasserted in middle of transaction")

        address = 0
        for k in range(7):
            s = await First(FallingEdge(self._sclk), frame_end)
            t = await First(Timer(20, units='ns'), frame_end)
            address |= int(self._mosi.value.integer) << (7 - 1 - k)
            self._miso.value = self._mosi.value

            if frame_end in (s, t):
                raise SpiFrameError("TMC4671: chip select deasserted in middle of transaction")

        if await First(RisingEdge(self._sclk), frame_end) == frame_end:
            raise SpiFrameError("TMC4671: chip select deasserted in middle of transaction")

        # wait to make sure that enough time has passed after the address selection
        post_read_wait = Timer(250, units='ns')
        if not do_write and (await First(FallingEdge(self._sclk), post_read_wait) != post_read_wait):
            raise SpiFrameError("TMC4671: SPI Timing of Read Access requires a 500ns pause")

        # read in the content, while writing out the respective data
        content = 0
        for k in range(32):
            s = await First(FallingEdge(self._sclk), frame_end)
            t = await First(Timer(20, units='ns'), frame_end)
            content |= int(self._mosi.value.integer) << (32 - 1 - k)
            self._miso.value = bool(self._registers[address] & (1 << (32 - 1 - k)))

            if frame_end in (s, t):
                raise SpiFrameError("TMC4671: chip select deasserted in middle of transaction")

        # end of frame
        if await First(frame_end, FallingEdge(self._sclk)) != frame_end:
            raise SpiFrameError("TMC4671: sampled more than 16 bits")

        if not bool(self._sclk.value):
            raise SpiFrameError("TMC4671: sclk should be high at chip select edge")

        if do_write:
            self._registers[address] = content

            if address in self._address_change_callbacks:
                cb = self._address_change_callbacks[address]
                for addr in cb[0]:
                    self._registers[addr] = cb[1]()



================================================
FILE: tests/spi/Makefile
================================================
TOPLEVEL_LANG = verilog

SIM ?= icarus
WAVES ?= 1

COCOTB_HDL_TIMEUNIT = 1ns
COCOTB_HDL_TIMEPRECISION = 1ps

DUT      = test_spi
TOPLEVEL = $(DUT)
MODULE   = $(DUT)

VERILOG_SOURCES = $(DUT).v


ifeq ($(SIM), icarus)
	PLUSARGS += -fst

	ifeq ($(WAVES), 1)
		VERILOG_SOURCES += iverilog_dump.v
		COMPILE_ARGS += -s iverilog_dump
	endif
endif

include $(shell cocotb-config --makefiles)/Makefile.sim

iverilog_dump.v:
	echo 'module iverilog_dump();' > $@
	echo 'initial begin' >> $@
	echo '    $$dumpfile("$(TOPLEVEL).fst");' >> $@
	echo '    $$dumpvars(0, $(TOPLEVEL));' >> $@
	echo 'end' >> $@
	echo 'endmodule' >> $@

clean::
	@rm -rf iverilog_dump.v
	@rm -rf dump.fst $(TOPLEVEL).fst
	@rm -rf results.xml



================================================
FILE: tests/spi/test_spi.py
================================================
"""
Copyright (c) 2021 Spencer Chang

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
"""
import itertools
import logging
import os

import cocotb
import cocotb_test.simulator
from cocotb.regression import TestFactory
from cocotb.triggers import Timer

from cocotbext.spi import SpiBus
from cocotbext.spi import SpiConfig
from cocotbext.spi import SpiMaster
from cocotbext.spi.devices.generic import SpiSlaveLoopback


class TB:
    def __init__(self, dut, sclk_freq, word_width, spi_mode, msb_first, ignore_rx_value):
        self.dut = dut
        self.log = logging.getLogger("cocotb.tb")
        self.log.setLevel(logging.DEBUG)

        self.bus = SpiBus.from_entity(dut, cs_name="ncs")

        self.config = SpiConfig(
            word_width=word_width,
            sclk_freq=sclk_freq,
            cpol=bool(spi_mode in [2, 3]),
            cpha=bool(spi_mode in [1, 3]),
            msb_first=msb_first,
            frame_spacing_ns=10,
            ignore_rx_value=ignore_rx_value,
            cs_active_low=True,
        )

        dut.spi_mode.value = spi_mode
        dut.spi_word_width.value = word_width

        self.source = SpiMaster(self.bus, self.config)
        self.sink = SpiSlaveLoopback(self.bus, self.config)


async def run_test(dut, payload_lengths, payload_data, sclk_freq=25e6, word_width=16, spi_mode=1, msb_first=True, ignore_rx_value=None):
    tb = TB(dut, sclk_freq, word_width, spi_mode, msb_first, ignore_rx_value)
    tb.log.info(
        "Running test with sclk_freq=%s mode=%s, msb_first=%s, word_width=%s, ignore_rx_value=%s",
        sclk_freq,
        spi_mode,
        msb_first,
        word_width,
        ignore_rx_value,
    )

    await Timer(10, 'us')

    for test_data in [payload_data(x) for x in payload_lengths()]:
        tb.log.info("Write data: %s", ','.join(['0x%02x' % x for x in test_data]))
        await tb.source.write(test_data)

        # if the rx_queue is empty after write do not wait for read,
        # otherwise it will crash. (This happens when ignore_rx_value is set)
        rx_data = tb.source.read_nowait() if tb.source.empty_rx() else await tb.source.read()
        sink_content = await tb.sink.get_contents()

        # remove ignore_rx_value from sink and test_data for assert
        filtered_test_data = list(filter(lambda v: v != ignore_rx_value, test_data))
        filtered_sink = [sink_content] if sink_content != ignore_rx_value else []

        tb.log.info("Read data: %s", ','.join(['0x%02x' % x for x in rx_data]))
        tb.log.info(f"In register: 0x{sink_content:02x}")
        assert list(rx_data[1:]) + filtered_sink == filtered_test_data

    await Timer(100, 'us')


def size_list():
    return list(range(1, 16)) + [128]


def incrementing_payload(length):
    return bytearray(itertools.islice(itertools.cycle(range(256)), length))


if cocotb.SIM_NAME:
    factory = TestFactory(run_test)
    factory.add_option("sclk_freq", [15e6, 25e6])
    factory.add_option("payload_lengths", [size_list])
    factory.add_option("payload_data", [incrementing_payload])
    factory.add_option("word_width", [8, 16, 32])
    factory.add_option("spi_mode", [0, 1, 2, 3])
    factory.add_option("msb_first", [True, False])
    factory.add_option("ignore_rx_value", [None, 0, 128])
    factory.generate_tests()


# cocotb-test
tests_dir = os.path.dirname(__file__)


def test_spi(request):
    dut = "test_spi"
    module = os.path.splitext(os.path.basename(__file__))[0]
    toplevel = dut

    verilog_sources = [
        os.path.join(tests_dir, f"{dut}.v"),
    ]

    parameters = {}

    extra_env = {f'PARAM_{k}': str(v) for k, v in parameters.items()}

    sim_build = os.path.join(
        tests_dir, "sim_build",
        request.node.name.replace('[', '-').replace(']', ''),
    )

    cocotb_test.simulator.run(
        python_search=[tests_dir],
        verilog_sources=verilog_sources,
        toplevel=toplevel,
        module=module,
        parameters=parameters,
        sim_build=sim_build,
        extra_env=extra_env,
    )



================================================
FILE: tests/spi/test_spi.v
================================================
`timescale 1ns / 1ps

module test_spi
(
    inout wire sclk,
    inout wire mosi,
    inout wire miso,
    inout wire ncs,
    inout wire [1:0] spi_mode,
    inout wire [5:0] spi_word_width
);

endmodule // test_spi



================================================
FILE: tests/spi_devices/ADI/adxl345/Makefile
================================================
TOPLEVEL_LANG = verilog

SIM ?= icarus
WAVES ?= 1

COCOTB_HDL_TIMEUNIT = 1ns
COCOTB_HDL_TIMEPRECISION = 1ps

DUT      = test_adxl345
TOPLEVEL = $(DUT)
MODULE   = $(DUT)

VERILOG_SOURCES = $(DUT).v


ifeq ($(SIM), icarus)
	PLUSARGS += -fst

	ifeq ($(WAVES), 1)
		VERILOG_SOURCES += iverilog_dump.v
		COMPILE_ARGS += -s iverilog_dump
	endif
endif

include $(shell cocotb-config --makefiles)/Makefile.sim

iverilog_dump.v:
	echo 'module iverilog_dump();' > $@
	echo 'initial begin' >> $@
	echo '    $$dumpfile("$(TOPLEVEL).fst");' >> $@
	echo '    $$dumpvars(0, $(TOPLEVEL));' >> $@
	echo 'end' >> $@
	echo 'endmodule' >> $@

clean::
	@rm -rf iverilog_dump.v
	@rm -rf dump.fst $(TOPLEVEL).fst
	@rm -rf results.xml



================================================
FILE: tests/spi_devices/ADI/adxl345/test_adxl345.py
================================================
# SPDX-License-Identifier: MIT
# SPDX-FileCopyrightText: 2023 Spencer Chang
import logging
import os

import cocotb
import cocotb_test.simulator
from cocotb.triggers import Timer

from cocotbext.spi import SpiBus
from cocotbext.spi import SpiConfig
from cocotbext.spi import SpiMaster
from cocotbext.spi.devices.ADI import ADXL345


class TB:
    def __init__(self, dut):
        self.dut = dut
        self.log = logging.getLogger("cocotb.tb")
        self.log.setLevel(logging.DEBUG)

        self.bus = SpiBus.from_entity(dut, cs_name="ncs")

        self.config = SpiConfig(
            word_width=8,
            sclk_freq=25e6,
            cpol=True,
            cpha=True,
            msb_first=True,
            cs_active_low=True,
        )

        self.source = SpiMaster(self.bus, self.config)
        self.sink = ADXL345(self.bus)


@cocotb.test()
async def run_test_adxl345(dut):
    tb = TB(dut)
    await Timer(10, 'us')

    # test a single byte read
    await tb.source.write([tb.sink.create_spi_command("read", 0x00), 0x00], burst=True)
    read_word = (await tb.source.read(2))[1]
    assert read_word == 0b1110_0101

    # await the necessary time between transactions
    await Timer(200, units='ns')

    # test a multibyte read
    await tb.source.write(
        [
            tb.sink.create_spi_command("read", 0x2C, multibyte=True),
            0x00, 0x00, 0x00, 0x00, 0x00,
        ], burst=True,
    )
    read_word = (await tb.source.read(6))[1:]
    assert list(read_word) == [0b0000_1010, 0x00, 0x00, 0x00, 0b0000_0010]

    await Timer(200, units='ns')

    # test a multibyte write
    await tb.source.write([tb.sink.create_spi_command("write", 0x1e, multibyte=True), 0x01, 0b11, 0xAA], burst=True)
    assert (await tb.sink.get_register(0x1e)) == 0x01
    assert (await tb.sink.get_register(0x1f)) == 0b11
    assert (await tb.sink.get_register(0x20)) == 0xAA

    await Timer(5, 'us')


# cocotb-test

tests_dir = os.path.dirname(__file__)


def test_adxl345(request):
    dut = "test_adxl345"
    module = os.path.splitext(os.path.basename(__file__))[0]
    toplevel = dut

    verilog_sources = [
        os.path.join(tests_dir, f"{dut}.v"),
    ]

    parameters = {}

    extra_env = {f'PARAM_{k}': str(v) for k, v in parameters.items()}

    sim_build = os.path.join(
        tests_dir, "sim_build",
        request.node.name.replace('[', '-').replace(']', ''),
    )

    cocotb_test.simulator.run(
        python_search=[tests_dir],
        verilog_sources=verilog_sources,
        toplevel=toplevel,
        module=module,
        parameters=parameters,
        sim_build=sim_build,
        extra_env=extra_env,
    )



================================================
FILE: tests/spi_devices/ADI/adxl345/test_adxl345.v
================================================
`timescale 1ns / 1ps

module test_adxl345
(
    inout wire sclk,
    inout wire mosi,
    inout wire miso,
    inout wire ncs
);

endmodule // test_adxl345



================================================
FILE: tests/spi_devices/TI/ads8028/Makefile
================================================
TOPLEVEL_LANG = verilog

SIM ?= icarus
WAVES ?= 1

COCOTB_HDL_TIMEUNIT = 1ns
COCOTB_HDL_TIMEPRECISION = 1ps

DUT      = test_ads8028
TOPLEVEL = $(DUT)
MODULE   = $(DUT)

VERILOG_SOURCES = $(DUT).v


ifeq ($(SIM), icarus)
	PLUSARGS += -fst

	ifeq ($(WAVES), 1)
		VERILOG_SOURCES += iverilog_dump.v
		COMPILE_ARGS += -s iverilog_dump
	endif
endif

include $(shell cocotb-config --makefiles)/Makefile.sim

iverilog_dump.v:
	echo 'module iverilog_dump();' > $@
	echo 'initial begin' >> $@
	echo '    $$dumpfile("$(TOPLEVEL).fst");' >> $@
	echo '    $$dumpvars(0, $(TOPLEVEL));' >> $@
	echo 'end' >> $@
	echo 'endmodule' >> $@

clean::
	@rm -rf iverilog_dump.v
	@rm -rf dump.fst $(TOPLEVEL).fst
	@rm -rf results.xml



================================================
FILE: tests/spi_devices/TI/ads8028/test_ads8028.py
================================================
"""
Copyright (c) 2021 Spencer Chang

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
"""
import logging
import os

import cocotb
import cocotb_test.simulator
from cocotb.triggers import Timer

from cocotbext.spi import SpiBus
from cocotbext.spi import SpiConfig
from cocotbext.spi import SpiMaster
from cocotbext.spi.devices.TI import ADS8028


class TB:
    def __init__(self, dut):
        self.dut = dut
        self.log = logging.getLogger("cocotb.tb")
        self.log.setLevel(logging.DEBUG)

        self.bus = SpiBus.from_entity(dut, cs_name="ncs")

        self.config = SpiConfig(
            word_width=16,
            sclk_freq=25e6,
            cpol=True,
            cpha=False,
            msb_first=True,
            cs_active_low=True,
        )

        self.source = SpiMaster(self.bus, self.config)
        self.sink = ADS8028(self.bus)


@cocotb.test()
async def run_test_ads8028(dut):
    tb = TB(dut)
    await Timer(10, 'us')

    address_mask = 0xF000
    data_mask = 0x0FFF

    await tb.source.write([tb.sink.create_spi_word("write", 0b111100011100100)])
    _ = await tb.source.read()

    await Timer(20, units='ns')

    await tb.source.write([tb.sink.create_spi_word("read", 0x0000)])
    _ = await tb.source.read()

    await Timer(20, units='ns')

    await tb.source.write([tb.sink.create_spi_word("read", 0x0000)])
    ain0 = (await tb.source.read())[0]
    assert ain0 & address_mask == 0 << 12
    assert ain0 & data_mask == 0

    await Timer(20, units='ns')

    await tb.source.write([tb.sink.create_spi_word("read", 0x0000)])
    ain1 = (await tb.source.read())[0]
    assert ain1 & address_mask == 1 << 12
    assert ain1 & data_mask == 1

    await Timer(5, 'us')

# cocotb-test

tests_dir = os.path.dirname(__file__)


def test_ads8028(request):
    dut = "test_ads8028"
    module = os.path.splitext(os.path.basename(__file__))[0]
    toplevel = dut

    verilog_sources = [
        os.path.join(tests_dir, f"{dut}.v"),
    ]

    parameters = {}

    extra_env = {f'PARAM_{k}': str(v) for k, v in parameters.items()}

    sim_build = os.path.join(
        tests_dir, "sim_build",
        request.node.name.replace('[', '-').replace(']', ''),
    )

    cocotb_test.simulator.run(
        python_search=[tests_dir],
        verilog_sources=verilog_sources,
        toplevel=toplevel,
        module=module,
        parameters=parameters,
        sim_build=sim_build,
        extra_env=extra_env,
    )



================================================
FILE: tests/spi_devices/TI/ads8028/test_ads8028.v
================================================
`timescale 1ns / 1ps

module test_ads8028
(
    inout wire sclk,
    inout wire mosi,
    inout wire miso,
    inout wire ncs
);

endmodule // test_ads8028



================================================
FILE: tests/spi_devices/TI/drv8304/Makefile
================================================
TOPLEVEL_LANG = verilog

SIM ?= icarus
WAVES ?= 1

COCOTB_HDL_TIMEUNIT = 1ns
COCOTB_HDL_TIMEPRECISION = 1ps

DUT      = test_drv8304
TOPLEVEL = $(DUT)
MODULE   = $(DUT)

VERILOG_SOURCES = $(DUT).v


ifeq ($(SIM), icarus)
	PLUSARGS += -fst

	ifeq ($(WAVES), 1)
		VERILOG_SOURCES += iverilog_dump.v
		COMPILE_ARGS += -s iverilog_dump
	endif
endif

include $(shell cocotb-config --makefiles)/Makefile.sim

iverilog_dump.v:
	echo 'module iverilog_dump();' > $@
	echo 'initial begin' >> $@
	echo '    $$dumpfile("$(TOPLEVEL).fst");' >> $@
	echo '    $$dumpvars(0, $(TOPLEVEL));' >> $@
	echo 'end' >> $@
	echo 'endmodule' >> $@

clean::
	@rm -rf iverilog_dump.v
	@rm -rf dump.fst $(TOPLEVEL).fst
	@rm -rf results.xml



================================================
FILE: tests/spi_devices/TI/drv8304/test_drv8304.py
================================================
"""
Copyright (c) 2021 Spencer Chang

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
"""
import logging
import os

import cocotb
import cocotb_test.simulator
from cocotb.triggers import Timer

from cocotbext.spi import SpiBus
from cocotbext.spi import SpiConfig
from cocotbext.spi import SpiMaster
from cocotbext.spi.devices.TI import DRV8304


class TB:
    def __init__(self, dut):
        self.dut = dut
        self.log = logging.getLogger("cocotb.tb")
        self.log.setLevel(logging.DEBUG)

        self.bus = SpiBus.from_entity(dut, cs_name="ncs")

        self.config = SpiConfig(
            word_width=16,
            sclk_freq=25e6,
            cpol=False,
            cpha=True,
            msb_first=True,
            cs_active_low=True,
        )

        self.source = SpiMaster(self.bus, self.config)
        self.sink = DRV8304(self.bus)


@cocotb.test()
async def run_test_drv8304(dut):
    tb = TB(dut)
    await Timer(10, 'us')

    # we are working with 11 bit words
    bit_mask = 0x7FF

    # simulate a read event on a register of DRV8304
    await tb.source.write([tb.sink.create_spi_word("read", 0x03, 0b00000000000)])
    read_word = await tb.source.read(1)
    assert read_word[0] & bit_mask == 0x377

    # let the line idle for some time
    await Timer(500, units='ns')

    # simulate a write event on a register of DRV8304
    await tb.source.write([tb.sink.create_spi_word("write", 0x02, 0b00001000000)])

    read_word = await tb.source.read(1)
    assert read_word[0] & bit_mask == 0x00

    read_register = await tb.sink.get_register(0x02)
    assert read_register == 0b00001000000

    await Timer(5, 'us')

# cocotb-test

tests_dir = os.path.dirname(__file__)


def test_drv8304(request):
    dut = "test_drv8304"
    module = os.path.splitext(os.path.basename(__file__))[0]
    toplevel = dut

    verilog_sources = [
        os.path.join(tests_dir, f"{dut}.v"),
    ]

    parameters = {}

    extra_env = {f'PARAM_{k}': str(v) for k, v in parameters.items()}

    sim_build = os.path.join(
        tests_dir, "sim_build",
        request.node.name.replace('[', '-').replace(']', ''),
    )

    cocotb_test.simulator.run(
        python_search=[tests_dir],
        verilog_sources=verilog_sources,
        toplevel=toplevel,
        module=module,
        parameters=parameters,
        sim_build=sim_build,
        extra_env=extra_env,
    )



================================================
FILE: tests/spi_devices/TI/drv8304/test_drv8304.v
================================================
`timescale 1ns / 1ps

module test_drv8304
(
    inout wire sclk,
    inout wire mosi,
    inout wire miso,
    inout wire ncs
);

endmodule // test_drv8304



================================================
FILE: tests/spi_devices/Trinamic/tmc4671/Makefile
================================================
TOPLEVEL_LANG = verilog

SIM ?= icarus
WAVES ?= 1

COCOTB_HDL_TIMEUNIT = 1ns
COCOTB_HDL_TIMEPRECISION = 1ps

DUT      = test_tmc4671
TOPLEVEL = $(DUT)
MODULE   = $(DUT)

VERILOG_SOURCES = $(DUT).v


ifeq ($(SIM), icarus)
	PLUSARGS += -fst

	ifeq ($(WAVES), 1)
		VERILOG_SOURCES += iverilog_dump.v
		COMPILE_ARGS += -s iverilog_dump
	endif
endif

include $(shell cocotb-config --makefiles)/Makefile.sim

iverilog_dump.v:
	echo 'module iverilog_dump();' > $@
	echo 'initial begin' >> $@
	echo '    $$dumpfile("$(TOPLEVEL).fst");' >> $@
	echo '    $$dumpvars(0, $(TOPLEVEL));' >> $@
	echo 'end' >> $@
	echo 'endmodule' >> $@

clean::
	@rm -rf iverilog_dump.v
	@rm -rf dump.fst $(TOPLEVEL).fst
	@rm -rf results.xml



================================================
FILE: tests/spi_devices/Trinamic/tmc4671/test_tmc4671.py
================================================
"""
Copyright (c) 2022 Spencer Chang

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
"""
import logging
import os

import cocotb
import cocotb_test.simulator
from cocotb.triggers import Timer

from cocotbext.spi import SpiBus
from cocotbext.spi import SpiConfig
from cocotbext.spi import SpiMaster
from cocotbext.spi.devices.Trinamic import TMC4671


class TB:
    def __init__(self, dut):
        self.dut = dut
        self.log = logging.getLogger("cocotb.tb")
        self.log.setLevel(logging.DEBUG)

        self.bus = SpiBus.from_entity(dut, cs_name="ncs")

        self.config = SpiConfig(
            word_width=40,
            sclk_freq=2e6,
            cpol=True,
            cpha=True,
            msb_first=True,
            cs_active_low=True,
        )

        self.source = SpiMaster(self.bus, self.config)
        self.sink = TMC4671(self.bus)


@cocotb.test()
async def run_test_tmc4671(dut):
    tb = TB(dut)
    await Timer(10, 'us')

    # we are working with 32 bit words
    bit_mask = 0xFFFF_FFFF

    # set the CHIPINFO_ADDR register to 0 (to get SI_TYPE)
    await tb.source.write([tb.sink.create_spi_word("write", 0x01, 0)])
    _ = await tb.source.read(1)

    await Timer(20, units='ns')

    # read the CHIPINFO_DATA register for the SI_TYPE value
    await tb.source.write([tb.sink.create_spi_word("read", 0x00, 0)])
    read_word = await tb.source.read(1)
    assert read_word[0] & bit_mask == 0x34363731

    await Timer(20, units='ns')

    # set the CHIPINFO_ADDR register to 1 (to get SI_VERSION)
    await tb.source.write([tb.sink.create_spi_word("write", 0x01, 1)])
    _ = await tb.source.read(1)

    await Timer(20, units='ns')

    # read the CHIPINFO_DATA register for the SI_VERSION
    await tb.source.write([tb.sink.create_spi_word("read", 0x00, 0)])
    read_word = await tb.source.read(1)
    assert read_word[0] & bit_mask == 0x0000_0100

    await Timer(5, 'us')

# cocotb-test

tests_dir = os.path.dirname(__file__)


def test_tmc4671(request):
    dut = "test_tmc4671"
    module = os.path.splitext(os.path.basename(__file__))[0]
    toplevel = dut

    verilog_sources = [
        os.path.join(tests_dir, f"{dut}.v"),
    ]

    parameters = {}

    extra_env = {f'PARAM_{k}': str(v) for k, v in parameters.items()}

    sim_build = os.path.join(
        tests_dir, "sim_build",
        request.node.name.replace('[', '-').replace(']', ''),
    )

    cocotb_test.simulator.run(
        python_search=[tests_dir],
        verilog_sources=verilog_sources,
        toplevel=toplevel,
        module=module,
        parameters=parameters,
        sim_build=sim_build,
        extra_env=extra_env,
    )



================================================
FILE: tests/spi_devices/Trinamic/tmc4671/test_tmc4671.v
================================================
`timescale 1ns / 1ps

module test_tmc4671
(
    inout wire sclk,
    inout wire mosi,
    inout wire miso,
    inout wire ncs
);

endmodule // test_tmc4671



================================================
FILE: .github/workflows/regression-tests.yml
================================================
name: Regression Tests

on: [push, pull_request]

jobs:
  build:
    name: Python ${{matrix.python-version}}
    runs-on: ubuntu-latest

    strategy:
      matrix:
        python-version: ['3.9', '3.10', '3.11']

    steps:
    - uses: actions/checkout@v3

    - name: Set up Python ${{matrix.python-version}}
      uses: actions/setup-python@v4
      with:
        python-version: ${{matrix.python-version}}

    - name: Install Icarus Verilog
      run: |
        sudo apt install -y --no-install-recommends iverilog
    - name: Install Python dependencies
      run: |
        python -m pip install --upgrade pip
        pip install tox tox-gh-actions
    - name: Test with tox
      run: tox

  publish_pypi:
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags')
    needs: [build]
    steps:
      - uses: actions/checkout@v3
      - name: Set up Python
        with:
          python-version: '3.10'
        uses: actions/setup-python@v4
      - name: Install uv
        run: |
          python -m pip install --upgrade pip
          pip install uv
      - name: Publish to PyPI
        env:
          UV_PUBLISH_TOKEN: ${{ secrets.PYPI_TOKEN }}
        run: |
          uv publish
      - name: Create Release on Github
        uses: softprops/action-gh-release@v1
        with:
          draft: true
          prerelease: false
          files: ./dist/*
          token: ${{ secrets.CUSTOM_GITHUB_TOKEN }}


